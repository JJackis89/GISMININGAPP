import{r as g,m as I,di as Ie,a as ce,l as Be,id as be,am as re,e as se,M as B,z as U,p as M,H as we,f as _e,bo as Ce,dQ as De,_ as Y,P as ze,eA as $e,bf as Me,Z as Je,c1 as He}from"./index-8ee34b61.js";import{r as V,g as ve,N as Ne,i as Ee,a as Oe,b as Se,u as We,c as he,l as Le,p as Ae,d as qe,j as Ge,f as je,e as me,W as fe,h as Ve,k as Ue,w as Qe,v as Xe,m as Ze,n as Ye,q as Ke,D as et,z as tt,B as de,o as it,s as pe}from"./RasterJobHandlerMixin-37a6e01c.js";import{T as ie,j as nt,l as rt,D as ke,a as st,u as ot,b as at,g as lt,d as ct,h as ut,_ as ht}from"./dataUtils-200c0f44.js";import{j as K,l as mt}from"./TileInfo-ce8dbde4.js";import{QueueProcessor as ft}from"./QueueProcessor-68074791.js";import{e as X,v as oe,A as ye,u as xe,f as dt,o as ne,Q as Z,s as pt,i as yt,_ as xt,r as ae,V as le,p as gt,T as Rt}from"./rasterFunctionHelper-4e794af5.js";let It=class{constructor(t=15e3,r=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=t,this._interval=Math.min(t,r)}decreaseRefCount(t,r){const e=t+"/"+r,n=this._cachedBlocks;if(n.has(e)){const o=n.get(e);return o.refCount--,o.refCount<=0&&(n.delete(e),o.controller&&o.controller.abort()),o.refCount}return 0}getBlock(t,r){const e=t+"/"+r,n=this._cachedBlocks;if(n.has(e)){const o=n.get(e);return o.ts=Date.now(),o.refCount++,n.delete(e),n.set(e,o),o.block}return null}putBlock(t,r,e,n){const o=this._cachedBlocks,s=t+"/"+r;if(o.has(s)){const a=o.get(s);a.ts=Date.now(),a.refCount++}else o.set(s,{block:e,ts:Date.now(),refCount:1,controller:n});this._trim(),this._updateTimer()}deleteBlock(t,r){const e=this._cachedBlocks,n=t+"/"+r;e.has(n)&&e.delete(n)}updateMaxSize(t){this._size=t,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(this._timer!=null)return;const t=this._cachedBlocks;this._timer=setInterval(()=>{const r=Array.from(t),e=Date.now();for(let n=0;n<r.length&&r[n][1].ts<=e-this._duration;n++)t.delete(r[n][0]);t.size===0&&this._clearTimer()},this._interval)}_trim(){const t=this._cachedBlocks;if(this._size===-1||this._size>=t.size)return;const r=Array.from(t);for(let e=0;e<r.length-this._size;e++)t.delete(r[e][0])}_clearTimer(){this._timer!=null&&(clearInterval(this._timer),this._timer=null)}};const te=new Map,E=new It;function bt(i,t,r){const e=[];return t!=null&&e.push(`sliceId=${t}`),r!=null&&e.push(`bandIds=${r.join(",")}`),e.length?`${i}?${e.join("&")}`:i}function wt(i,t,r){const e=te.get(i);if(!e)return t==null?E.decreaseRefCount(i,r):0;if(t==null||e[t]==null)return E.decreaseRefCount(i,r);const n=e[t]?.cache,o=n?.get(r);if(n&&o){if(o.refCount--,o.refCount===0){n.delete(r);for(let s=0;s<e.length;s++)e[s]?.cache.delete(r);o.controller&&o.controller.abort()}return o.refCount}return 0}function _t(i,t,r){const e=te.get(i);if(!e)return t==null?E.getBlock(i,r):null;if(t==null||e[t]==null){for(let o=0;o<e.length;o++){const s=e[o]?.cache.get(r);if(s)return s.refCount++,s.block}return E.getBlock(i,r)}const n=e[t]?.cache.get(r);if(n)return n.refCount++,n.block;for(let o=0;o<e.length;o++){if(o===t||!e[o])continue;const s=e[o]?.cache,a=s?.get(r);if(s&&a)return a.refCount++,s.set(r,a),a.block}return null}function vt(i,t,r,e,n=null){const o=te.get(i);if(!o)return void(t==null&&E.putBlock(i,r,e,n));if(t==null||o[t]==null)return void E.putBlock(i,r,e,n);const s={refCount:1,block:e,isResolved:!1,isRejected:!1,controller:n};e.then(()=>s.isResolved=!0).catch(()=>s.isRejected=!0),o[t]?.cache.set(r,s)}function St(i,t,r){const e=te.get(i);e?t!=null&&e[t]!=null?e[t]?.cache.delete(r):E.deleteBlock(i,r):t==null&&E.deleteBlock(i,r)}const ge=8,kt=256;let Tt=0,w=class extends Be{constructor(){super(...arguments),this._tileFetchQueue=new ft({concurrency:32,process:(i,t)=>this._fetchRawTile(i.pyramidLevel,i.row,i.col,{...i.options,signal:t})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(i){return i?.ioConfig&&(i={...i,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:K.create(),...i.ioConfig}}),i}get _isGlobalWrappableSource(){const{rasterInfo:i}=this,t=X(i.spatialReference);return t!=null&&i.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){const{transform:i}=this.rasterInfo;return i==null||i.type==="gcs-shift"}set rasterJobHandler(i){this._set("rasterJobHandler",i),V(this)&&this.primaryRasters?.rasters?.forEach(t=>t.rasterJobHandler=i)}get rasterId(){return this.url||"rasterId-"+Tt++}set url(i){this._set("url",be(i,re.getLogger(this)))}async open(i){return this._openPromise??(this._openPromise=oe().then(()=>this._open(i))),this._openPromise}async fetchTile(i,t,r,e={}){const n=e.tileInfo||this.rasterInfo.storageInfo.tileInfo,o=this.getTileExtentFromTileInfo(i,t,r,n);return e={noClip:!0,...e},this.fetchPixels(o,n.size[0],n.size[1],e)}async identify(i,t={}){i=se(B,i).clone().normalize();const{multidimensionalDefinition:r,timeExtent:e}=t,{rasterInfo:n}=this,{hasMultidimensionalTranspose:o,multidimensionalInfo:s}=n;let{transposedVariableName:a}=t;const l=s!=null&&o&&(e!=null||ve(r));l&&!a&&(a=r!=null&&r.length>0?r[0].variableName??void 0:s.variables[0].name,t={...t,transposedVariableName:a}),t=this._getRequestOptionsWithSliceId(t);const{spatialReference:c,extent:u}=n,{datumTransformation:m}=t;let h=ye(i,c,m);if(!u.intersects(h))return{location:h,value:null};if(n.transform!=null){const T=n.transform.inverseTransform(h);if(!n.nativeExtent.intersects(T))return{location:T,value:null};h=T}let y=0;const p=a!=null&&s!=null&&n.hasMultidimensionalTranspose;if(V(this)){const T=this.primaryRasters.rasters[0];if(p)return T.identify(h,t);const{pixelSize:O}=n,v=3,C=O.x*v/2,W=O.y*v/2,L=new U({xmin:h.x-C,xmax:h.x+C,ymin:h.y-W,ymax:h.y+W,spatialReference:c}),A={interpolation:"nearest",multidimensionalDefinition:r,sliceId:t.sliceId},{pixelBlock:k}=await T.fetchPixels(L,v,v,A),{pixelBlock:S}=await this.fetchPixels(L,v,v,A);if(k==null)return{location:h,value:null};const P=Math.floor(v*v*.5),z=!k.mask||k.mask[P]?k.pixels.map(F=>F[P]):null;let H;return S!=null&&(H=!S.mask||S.mask[P]?S.pixels.map(F=>F[P]):void 0),{location:h,value:z,processedValue:H,pyramidLevel:0}}if(!p){if(t.srcResolution)y=xe(t.srcResolution,n,this.ioConfig.sampling).pyramidLevel;else if(y=await this.computeBestPyramidLevelForLocation(i,t),y==null)return{location:h,value:null}}const x=this.identifyPixelLocation(h,y,null,p);if(x===null)return{location:h,value:null};const{row:d,col:f,rowOffset:b,colOffset:R,blockWidth:_}=x,D=await this._tileFetchQueue.push({pyramidLevel:y,row:d,col:f,options:t},{signal:t.signal});if(!D?.pixels?.length)return{location:h,value:null};const J=b*_+R;return this._processIdentifyResult(D,{srcLocation:h,position:J,pyramidLevel:y,useTransposedTile:!!p,requestSomeSlices:l,identifyOptions:t})}async fetchPixels(i,t,r,e={}){i=dt(i),e=this._getRequestOptionsWithSliceId(e);const{_hasNoneOrGCSShiftTransform:n}=this;if(e.requestRawData&&n)return this._fetchPixels(i,t,r,e);const o=X(i.spatialReference),s=ne(i);if(o==null||s===0||s===1&&this._isGlobalWrappableSource&&n)return this._fetchPixels(i,t,r,e);if(s>=3)return{extent:i,pixelBlock:null};const a=[],{xmin:l,xmax:c}=i,u=Math.round(o/(c-l)*t),m=u-Math.round((o/2-l)/(c-l)*t);let h=0;const y=[];for(let f=0;f<=s;f++){const b=new U({xmin:f===0?l:-o/2,xmax:f===s?c-o*f:o/2,ymin:i.ymin,ymax:i.ymax,spatialReference:i.spatialReference}),R=f===0?u-m:f===s?t-h:u;h+=R,y.push(R);const _=e.disableWrapAround&&f>0?null:this._fetchPixels(b,R,r,e);a.push(_)}const p=(await Promise.all(a)).map(f=>f?.pixelBlock);let x=null;const d={width:t,height:r};return this.rasterJobHandler?x=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:d,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:y},e)).pixelBlock:x=ie(p,d,{blockWidths:y}),{extent:i,srcExtent:Z(i,this.rasterInfo.spatialReference,e.datumTransformation),pixelBlock:x}}async fetchRawPixels(i,t,r,e={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const n=await this._fetchRawTiles(i,t,r,e),{nativeExtent:o,nativePixelSize:s,storageInfo:a}=this.rasterInfo,l=2**i,c=s.x*l,u=s.y*l,m=new U({xmin:o.xmin+c*t.x,xmax:o.xmin+c*(t.x+r.width-1),ymin:o.ymax-u*(t.y+r.height-1),ymax:o.ymax-u*t.y,spatialReference:o.spatialReference});if(!n)return{extent:m,srcExtent:m,pixelBlock:null};const{pixelBlocks:h,mosaicSize:y}=n;if(h.length===1&&h[0]!=null&&h[0].width===r.width&&h[0].height===r.height)return{extent:m,srcExtent:m,pixelBlock:n.pixelBlocks[0]};const p=i>0?a.pyramidBlockWidth:a.blockWidth,x=i>0?a.pyramidBlockHeight:a.blockHeight,d={x:t.x%p,y:t.y%x};let f;return this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:y,destDimension:r,clipOffset:d,clipSize:r,coefs:null,sampleSpacing:null,interpolation:e.interpolation,alignmentInfo:null,blockWidths:null},e)).pixelBlock:f=ie(h,y,{clipOffset:d,clipSize:r}),{extent:m,srcExtent:m,pixelBlock:f}}fetchRawTile(i,t,r,e){throw new M("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(i){return Z(this.rasterInfo.extent,i)}decodePixelBlock(i,t){return!this.rasterJobHandler||t.useCanvas?nt(i,t):this.rasterJobHandler.decode({data:i,options:t})}async request(i,t,r=0){const{customFetchParameters:e}=this.ioConfig,{range:n,query:o,headers:s}=t;r=r??t.retryCount??this.ioConfig.retryCount;const a=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await we(i,{...t,query:{...o,...e},headers:{...s,...a}})}catch(l){if(r>0)return r--,this.request(i,t,r);throw l}}getSliceIndex(i){const{multidimensionalInfo:t}=this.rasterInfo;return t==null||i==null||i.length===0?null:Ne(i,t)}getTileExtentFromTileInfo(i,t,r,e){const n=e.lodAt(i);return this.getTileExtent({x:n.resolution,y:n.resolution},t,r,e.origin,e.spatialReference,e.size)}updateTileInfo(){const{storageInfo:i,spatialReference:t,extent:r,pixelSize:e}=this.rasterInfo,{pyramidResolutions:n}=i;if(!i.tileInfo){const o=[],s=i.maximumPyramidLevel||0;let a=(e.x+e.y)/2,l=1/.0254*96*a;for(let u=0;u<=s&&(o.unshift(new mt({level:s-u,resolution:a,scale:l})),u!==s);u++)if(n){const m=(n[u].x+n[u].y)/2;l*=m/a,a=m}else a*=2,l*=2;const c=new B({x:r.xmin,y:r.ymax,spatialReference:t});i.tileInfo=new K({origin:c,size:[i.blockWidth,i.blockHeight],spatialReference:t,lods:o}),i.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(i,t=512,r=512,e){const{width:n,height:o,nativeExtent:s,pixelSize:a,spatialReference:l}=i,c=new B({x:s.xmin,y:s.ymax,spatialReference:l});e==null&&(e=Math.max(0,Math.round(Math.log(Math.max(n,o))/Math.LN2-8)));const u=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[a],e);i.storageInfo=new rt({blockWidth:t,blockHeight:r,pyramidBlockWidth:t,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:e,blockBoundary:u})}async computeBestPyramidLevelForLocation(i,t={}){return 0}computeBlockBoundary(i,t,r,e,n,o=0,s=2){if(n.length===1&&o>0){n=[...n];let{x:u,y:m}=n[0];for(let h=0;h<o;h++)u*=s,m*=s,n.push({x:u,y:m})}const a=[],{x:l,y:c}=e;for(let u=0;u<n.length;u++){const{x:m,y:h}=n[u];a.push({minCol:Math.floor((i.xmin-l+.1*m)/t/m),maxCol:Math.floor((i.xmax-l-.1*m)/t/m),minRow:Math.floor((c-i.ymax+.1*h)/r/h),maxRow:Math.floor((c-i.ymin-.1*h)/r/h)})}return a}getPyramidPixelSize(i){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:e}=this.rasterInfo.storageInfo;if(i===0)return t;if(r!=null&&r.length)return r[i-1];const n=e**i;return{x:t.x*n,y:t.y*n}}identifyPixelLocation(i,t,r,e){const{spatialReference:n,nativeExtent:o,storageInfo:s}=this.rasterInfo,{maximumPyramidLevel:a,origin:l,transposeInfo:c}=s,u=e&&c!=null?c.tileSize[0]:s.blockWidth,m=e&&c!=null?c.tileSize[1]:s.blockHeight,h=ye(i,n,r);if(!o.intersects(h)||t<0||t>a)return null;const y=this.getPyramidPixelSize(t),{x:p,y:x}=y,d=(l.y-h.y)/x/m,f=(h.x-l.x)/p/u,b=Math.min(m-1,Math.floor((d-Math.floor(d))*m)),R=Math.min(u-1,Math.floor((f-Math.floor(f))*u));return{pyramidLevel:t,row:Math.floor(d),col:Math.floor(f),rowOffset:b,colOffset:R,blockWidth:u,srcLocation:h}}getTileExtent(i,t,r,e,n,o){const[s,a]=o,l=e.x+r*s*i.x,c=l+s*i.x,u=e.y-t*a*i.y,m=u-a*i.y;return new U({xmin:l,xmax:c,ymin:m,ymax:u,spatialReference:n})}getBlockWidthHeight(i){return{blockWidth:i>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:i>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(i,t,r){const e=this.rasterInfo.storageInfo.blockBoundary[i];return!e||e.maxRow<t||e.maxCol<r||e.minRow>t||e.minCol>r}updateImageSpaceRasterInfo(i){const{pixelSize:t}=i,{width:r,height:e}=i,n=_e.WebMercator;i.spatialReference=n,i.extent=i.nativeExtent=new U({xmin:-.5,ymax:.5,xmax:r-.5,ymin:.5-e,spatialReference:n}),i.isPseudoSpatialReference=!0,i.transform=null,i.pixelSize=new B({x:1,y:1,spatialReference:n});const{extent:o,storageInfo:s}=i;if(s){s.origin=new B({x:o.xmin,y:o.ymax,spatialReference:n});const{pyramidResolutions:a,tileInfo:l}=s;if(a&&a.forEach(c=>{c.x/=t.x,c.y/=t.y}),l){l.origin=s.origin;const c=(i.nativePixelSize.x+i.nativePixelSize.y)/2;l.lods.forEach((u,m)=>{u.resolution=c*2**m,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(i,t,r,e={}){let n=ne(i);if(n>=2)return{extent:i,pixelBlock:null};const o=this._getSourceDataInfo(i,t,r,e),{pyramidLevel:s,srcResolution:a,srcExtent:l,srcWidth:c,srcHeight:u,ul:m}=o;if(c===0||u===0)return{extent:i,srcExtent:l,pixelBlock:null};const{rasterInfo:h}=this,y=h.transform,p=y?.type==="gcs-shift",x=X(i.spatialReference)!=null;!p&&x||(n=ne(o.srcExtent,p));const d=await this._fetchRawTiles(s,m,{width:c,height:u,wrapCount:n},e);if(!d)return{extent:i,srcExtent:l,pixelBlock:null};const f=h.storageInfo,b=s>0?f.pyramidBlockWidth:f.blockWidth,R=s>0?f.pyramidBlockHeight:f.blockHeight;let{x:_,y:D}=h.pixelSize;if(s>0){const{pyramidResolutions:$,pyramidScalingFactor:Fe}=f;if($!=null&&$[s-1])({x:_,y:D}=$[s-1]);else{const ue=Fe**s;_*=ue,D*=ue}}const J=h.spatialReference,T=new B({x:_,y:D,spatialReference:J}),O=b===c&&R===u&&m.x%b===0&&m.y%R===0,v=new B({x:(i.xmax-i.xmin)/t,y:(i.ymax-i.ymin)/r,spatialReference:i.spatialReference}),C=!i.spatialReference.equals(J),W=J.isGeographic?1e-9:1e-4,{datumTransformation:L}=e;if(!C&&O&&d.pixelBlocks.length===1&&b===t&&R===r&&Pt(a,v,W))return{extent:i,srcExtent:l,srcTilePixelSize:T,pixelBlock:d.pixelBlocks[0]};const A=x&&X(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,k=e.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");k&&!this.rasterJobHandler&&await oe();const S=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:i,srcBufferExtent:d.extent,pixelSize:v.toJSON(),datumTransformation:L,rasterTransform:y,hasWrapAround:n>0||A,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:k},e):pt({projectedExtent:i,srcBufferExtent:d.extent,pixelSize:v,datumTransformation:L,rasterTransform:y,hasWrapAround:n>0||A,isAdaptive:!1,includeGCSGrid:k});let P;const z=!e.requestRawData,H={rows:S.spacing[0],cols:S.spacing[1]},F=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(s,d.extent.xmin):void 0,{pixelBlocks:N,mosaicSize:q,isPartiallyFilled:Q}=d;let G=null;if(this.rasterJobHandler)({pixelBlock:P,localNorthDirections:G}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:N,srcMosaicSize:q,destDimension:z?{width:t,height:r}:null,coefs:z?S.coefficients:null,sampleSpacing:z?H:null,projectDirections:k,gcsGrid:k?S.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:e.interpolation,alignmentInfo:F,blockWidths:null},e));else{const $=ie(N,q,{alignmentInfo:F});P=z?ke($,{width:t,height:r},S.coefficients,H,e.interpolation):$,k&&S.gcsGrid&&(G=st({width:t,height:r},S.gcsGrid),P=ot(P,this.rasterInfo.dataType,G))}return e.requestRawData||k?{extent:i,srcExtent:l,srcTilePixelSize:T,pixelBlock:P,transformGrid:S,localNorthDirections:G,isPartiallyFilled:Q}:{extent:i,srcExtent:l,srcTilePixelSize:T,pixelBlock:P}}async _fetchRawTiles(i,t,r,e){const{origin:n,blockBoundary:o}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:a}=this.getBlockWidthHeight(i);let{x:l,y:c}=t,{width:u,height:m,wrapCount:h}=r;const y=this._getRasterTileAlignmentInfo(i,0);e.buffer&&(l-=e.buffer.cols,c-=e.buffer.rows,u+=2*e.buffer.cols,m+=2*e.buffer.rows);let p=0,x=0,d=0;h&&y!=null&&({worldColumnCountFromOrigin:x,originColumnOffset:d,rightPadding:p}=y,x*y.blockWidth-p>=l+u&&(p=0));const f=Math.floor(l/s),b=Math.floor(c/a),R=Math.floor((l+u+p-1)/s),_=Math.floor((c+m+p-1)/a),D=o[i];if(!D)return null;const{minRow:J,minCol:T,maxCol:O,maxRow:v}=D;if(h===0&&(_<J||R<T||b>v||f>O))return null;const C=new Array;let W=!1;const L=this.ioConfig.allowPartialFill==null?e.allowPartialFill:this.ioConfig.allowPartialFill;for(let F=b;F<=_;F++)for(let N=f;N<=R;N++){let q=N;if(!e.disableWrapAround&&h&&y!=null&&x<=N&&(q=N-x-d),F>=J&&q>=T&&v>=F&&O>=q){const Q=this._tileFetchQueue.push({pyramidLevel:i,row:F,col:q,options:e},{signal:e.signal});L?C.push(new Promise(G=>{Q.then($=>G($)).catch(()=>{W=!0,G(null)})})):C.push(Q)}else C.push(Promise.resolve(null))}if(C.length===0)return null;const A=await Promise.all(C),k={height:(_-b+1)*a,width:(R-f+1)*s},{spatialReference:S}=this.rasterInfo,P=this.getPyramidPixelSize(i),{x:z,y:H}=P;return{extent:new U({xmin:n.x+f*s*z,xmax:n.x+(R+1)*s*z,ymin:n.y-(_+1)*a*H,ymax:n.y-b*a*H,spatialReference:S}),pixelBlocks:A,mosaicSize:k,isPartiallyFilled:W}}_fetchRawTile(i,t,r,e){const{storageInfo:n}=this.rasterInfo,o=n.transposeInfo!=null&&!!e.transposedVariableName;if(!o){const m=n.blockBoundary[i];if(!m)return Promise.resolve(null);const{minRow:h,minCol:y,maxCol:p,maxRow:x}=m;if(t<h||r<y||t>x||r>p)return Promise.resolve(null)}const s=o?e.transposeVariableName:e.sliceId,a=this.rasterInfo.storageInfo.isBsqTile?e.bandIds:null,l=bt(this.rasterId,s,a),c=`${i}/${t}/${r}`;let u=_t(l,e.registryId,c);if(u==null){const m=new AbortController;u=this.fetchRawTile(i,t,r,{...e,signal:m.signal}),vt(l,e.registryId,c,u,m),u.catch(()=>St(l,e.registryId,c))}return e.signal&&Ce(e,()=>{wt(l,e.registryId,c)}),u}_computeMagDirValues(i){const{bandCount:t,dataType:r}=this.rasterInfo;if(!(t===2&&r==="vector-magdir"||r==="vector-uv")||i?.length!==2||!i[0]?.length)return null;const e=i[0].length;if(r==="vector-magdir"){const l=i[1].map(c=>(c+360)%360);return[i[0],l]}const[n,o]=i,s=[],a=[];for(let l=0;l<e;l++){const[c,u]=at([n[l],o[l]]);s.push(c),a.push(u)}return[s,a]}_getRasterTileAlignmentInfo(i,t){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=yt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:t,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[i]}}_getSourceDataInfo(i,t,r,e={}){const n={datumTransformation:e.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};e.srcResolution&&(n.srcResolution=e.srcResolution,this._updateSourceDataInfo(i,n));const o=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:a,pyramidLevel:l}=n,c=s/t,u=a/r,m=l<o&&c*u>=16,h=l===o&&this._requireTooManySrcTiles(s,a,t,r);if(m||h||s===0||a===0){const y=new B({x:(i.xmax-i.xmin)/t,y:(i.ymax-i.ymin)/r,spatialReference:i.spatialReference});let p=xt(y,this.rasterInfo.spatialReference,i,n.datumTransformation);const x=!p||e.srcResolution&&p.x+p.y<e.srcResolution.x+e.srcResolution.y;if(m&&e.srcResolution&&x){const d=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(o-l+3>=d){const f=2**d;p={x:e.srcResolution.x*f,y:e.srcResolution.y*f}}}p&&(n.srcResolution=p,this._updateSourceDataInfo(i,n))}return this._requireTooManySrcTiles(n.srcWidth,n.srcHeight,t,r)&&(n.srcWidth=0,n.srcHeight=0),n}_requireTooManySrcTiles(i,t,r,e){const{tileInfo:n}=this.rasterInfo.storageInfo,o=Math.ceil(i/n.size[0])*Math.ceil(t/n.size[1]),s=i/r,a=t/e,l=Math.max(1,(r+e)/1024);return o>=kt*l||s>ge||a>ge}_updateSourceDataInfo(i,t){t.srcWidth=0,t.srcHeight=0;const{rasterInfo:r}=this,e=r.spatialReference,{srcResolution:n,datumTransformation:o}=t,{pyramidLevel:s,pyramidResolution:a,excessiveReading:l}=xe(n,r,this.ioConfig.sampling);if(l)return;let c=t.srcExtent||Z(i,e,o);if(c==null)return;const u=r.transform;u&&(c=u.inverseTransform(c)),t.srcExtent=c;const{x:m,y:h}=r.storageInfo.origin,y=Math.floor((c.xmin-m)/a.x+.1),p=Math.floor((h-c.ymax)/a.y+.1),x=Math.floor((c.xmax-m)/a.x-.1),d=Math.floor((h-c.ymin)/a.y-.1),f=c.width<.1*a.x?0:x-y+1,b=c.height<.1*a.y?0:d-p+1;t.pyramidLevel=s,t.pyramidResolution=a,t.srcWidth=f,t.srcHeight=b,t.ul={x:y,y:p}}_getRequestOptionsWithSliceId(i){return this.rasterInfo.multidimensionalInfo!=null&&i.sliceId==null&&(i={...i,sliceId:this.getSliceIndex(i.multidimensionalDefinition)}),i}_processIdentifyResult(i,t){const{srcLocation:r,position:e,pyramidLevel:n,useTransposedTile:o}=t,s=i.pixels[0].length/i.width/i.height;if(!(!i.mask||i.mask[e]))return{location:r,value:null};const{multidimensionalInfo:a}=this.rasterInfo;if(a==null||!o){const d=i.pixels.map(R=>R[e]),f={location:r,value:d,pyramidLevel:n},b=this._computeMagDirValues(d.map(R=>[R]));return b?.length&&(f.magdirValue=b.map(R=>R[0])),f}let l=i.pixels.map(d=>d.slice(e*s,e*s+s)),c=this._computeMagDirValues(l);const{requestSomeSlices:u,identifyOptions:m}=t;let h=Ee(a,m.transposedVariableName);if(u){const d=Oe(h,m.multidimensionalDefinition,m.timeExtent);l=l.map(f=>d.map(b=>f[b])),c=c?.map(f=>d.map(b=>f[b])),h=d.map(f=>h[f])}const y=i.noDataValues||this.rasterInfo.noDataValue,p={pixels:l,pixelType:i.pixelType};let x;return y!=null&&(lt(p,y),x=p.mask),{location:r,value:null,dataSeries:h.map((d,f)=>{const b={value:x?.[f]===0?null:l.map(R=>R[f]),multidimensionalDefinition:d.multidimensionalDefinition.map(R=>new Se({...R,isSlice:!0}))};return c?.length&&(b.magdirValue=[c[0][f],c[1][f]]),b}),pyramidLevel:n}}};function Pt(i,t,r){return Math.abs(i.x-t.x)<r&&Math.abs(i.y-t.y)<r}g([I()],w.prototype,"_rasterTileAlignmentInfo",void 0),g([I()],w.prototype,"_tileFetchQueue",void 0),g([I({readOnly:!0})],w.prototype,"_isGlobalWrappableSource",null),g([I({readOnly:!0})],w.prototype,"_hasNoneOrGCSShiftTransform",null),g([I()],w.prototype,"_openPromise",void 0),g([I()],w.prototype,"rasterJobHandler",null),g([I({readOnly:!0})],w.prototype,"rasterId",null),g([I(Ie)],w.prototype,"url",null),g([I({type:String,json:{write:!0}})],w.prototype,"datasetName",void 0),g([I({type:String,json:{write:!0}})],w.prototype,"datasetFormat",void 0),g([I()],w.prototype,"hasUniqueSourceStorageInfo",void 0),g([I()],w.prototype,"rasterInfo",void 0),g([I()],w.prototype,"ioConfig",void 0),g([I()],w.prototype,"sourceJSON",void 0),w=g([ce("esri.layers.support.rasterDatasets.BaseRaster")],w);const Ft=40;let j=class extends w{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(i,t,r,e={}){const{rasters:n,rasterIds:o}=this.primaryRasters;let s=!1;const{interpolation:a}=e,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!e.requestRawData&&l&&(s=n.length===1&&!e.skipRasterFunction,e={...e,interpolation:"bilinear",requestRawData:s});const c=n.map(R=>R.fetchPixels(i,t,r,e)),u=await Promise.all(c),m=u.map(R=>R.pixelBlock),h=s||e.requestRawData?u.map(R=>R.srcTilePixelSize):null;if(e.skipRasterFunction||m.every(R=>R==null))return u[0];const y=u.find(R=>R.pixelBlock!=null)?.extent??i;let p=this.rasterJobHandler?await this.rasterJobHandler.process({extent:y,primaryPixelBlocks:m,primaryPixelSizes:h,primaryRasterIds:o}):this.rasterFunction.process({extent:y,primaryPixelBlocks:m,primaryPixelSizes:h,primaryRasterIds:o});const{transformGrid:x}=u[0];if(!s||p==null||x==null){const R=e.noClip?null:this.getClippingGeometry(y.spatialReference);return e.noClip||e.requestRawData||p==null||!R||(p=await ae(p,y,R)),{...u[0],pixelBlock:p}}const d={rows:x.spacing[0],cols:x.spacing[1]};let f;this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[p],srcMosaicSize:{width:p.width,height:p.height},destDimension:{width:t,height:r},coefs:x.coefficients,sampleSpacing:d,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:a,alignmentInfo:void 0,blockWidths:null},e)).pixelBlock:f=ke(p,{width:t,height:r},x.coefficients,d,a);const b=e.noClip?null:this.getClippingGeometry(i.spatialReference);return e.noClip||e.requestRawData||f==null||b==null||(f=await ae(f,i,b)),{extent:i,srcExtent:u[0].srcExtent,pixelBlock:f}}getClippingGeometry(i){const t=this._clippingGeometry.get("0");if(!i||!t)return t;const r=Ct(i);let e=this._clippingGeometry.get(r);return e!=null||(e=i.equals(t.spatialReference)?t:le(t,i),this._clippingGeometry.set(r,e)),e}async _open(i){const{rasterFunction:t}=this;t.isRoot=!0,this.primaryRasters?.rasters?.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(c=>c.rasterJobHandler=this.rasterJobHandler));const{rasters:r,rasterIds:e}=this.primaryRasters,n=r.map(c=>c.rasterInfo?void 0:c.open(i));await Promise.all(n);const o=r.map(({rasterInfo:c})=>c),s=t.bind({rasterInfos:o,rasterIds:e});if(t.rawSourceRasterInfos=o,!s.success||o.length===0)throw new M("raster-function:open",`cannot bind the function: ${s.error??""}`);const a=t.functionName==="Table"?t:t.functionArguments?.raster;a?.functionName==="Table"&&(t.rasterInfo.attributeTable=De.fromJSON(a.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const l=o[0];this.hasUniqueSourceStorageInfo=o.length===1||o.slice(1).every(c=>Bt(c,l)),this.set("sourceJSON",r[0].sourceJSON),this.set("rasterInfo",t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const i=this.rasterFunction.getClippingGeometries()[0];let t=i?.clippingGeometry;if(t&&i.clippingType==="inside"){const{extent:r}=this.rasterInfo,e=await Y(()=>import("./densifyOperator-0bfde292.js"),["assets/densifyOperator-0bfde292.js","assets/index-8ee34b61.js","assets/index-a5714ce2.css","assets/Point2D-e62ad2de.js","assets/ProjectionTransformation-16676837.js","assets/Envelope2D-4833fda6.js","assets/Transformation2D-ab2ac5ee.js","assets/SimpleGeometryCursor-e3941f41.js","assets/OperatorDefinitions-181ceaf8.js","assets/jsonConverter-13a35099.js","assets/densifyOperator-810ba2b3.js","assets/apiConverter-660b6342.js"]),n=await Y(()=>import("./differenceOperator-0397848f.js"),["assets/differenceOperator-0397848f.js","assets/Point2D-e62ad2de.js","assets/ProjectionTransformation-16676837.js","assets/Envelope2D-4833fda6.js","assets/Transformation2D-ab2ac5ee.js","assets/SimpleGeometryCursor-e3941f41.js","assets/index-8ee34b61.js","assets/index-a5714ce2.css","assets/OperatorDefinitions-181ceaf8.js","assets/jsonConverter-13a35099.js","assets/differenceOperator-13c602ab.js","assets/apiConverter-660b6342.js"]);let o=e.execute(ze.fromExtent(r),2*(r.width+r.height)/Ft);o=le(o,t.spatialReference),t=n.execute(o,t)}this._clippingGeometry.clear(),t&&this._clippingGeometry.set("0",t)}};function Bt(i,t){const{storageInfo:r,pixelSize:e,spatialReference:n,extent:o}=i,{storageInfo:s,pixelSize:a,spatialReference:l,extent:c}=t;return e.x===a.x&&e.y===a.y&&n.equals(l)&&o.equals(c)&&r.blockHeight===s.blockHeight&&r.blockWidth===s.blockWidth&&r.maximumPyramidLevel===s.maximumPyramidLevel}function Ct(i){return String(i.wkid??i.wkt??i.wkt2)}g([I({type:String,json:{write:!0}})],j.prototype,"datasetFormat",void 0),g([I()],j.prototype,"tileType",void 0),g([I()],j.prototype,"rasterFunction",void 0),g([I()],j.prototype,"primaryRasters",void 0),j=g([ce("esri.layers.support.rasterDatasets.FunctionRaster")],j);const Re=1e3,Ot=i=>{let t=class extends i{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=V(e[0]?.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){e?.functionName?.toLowerCase()==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",be(e,re.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:n}=this;return e?n?.find(({name:s})=>s===e)?.renderer.clone():this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,n,o){const s=n?.layerDefinition?.drawingInfo?.renderer;return qe(s,o)||void 0}async computeStatisticsHistograms(e,n){await this.load(n),e=se(Ge,e).clone();const{serviceRasterInfo:o}=this;if(o==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:s}=e;if(s==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let a=s;const{spatialReference:l}=o;if(!s.spatialReference.equals(l)){await oe();const d=s.type==="extent"?Z(s,l):le(s,l);if(d==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");a=d}const c=e.pixelSize??new B({x:o.pixelSize.x,y:o.pixelSize.y,spatialReference:l}),{extent:u,width:m,height:h}=gt(o,a,c),y=await this.fetchPixels(u,m,h,{...n,interpolation:"nearest"});if(y.pixelBlock==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const p=await ae(y.pixelBlock,u,a),x=this._rasterJobHandler;return x?x.computeStatisticsHistograms({pixelBlock:p},n):ut(p)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return e;const o=je({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:o,timeExtent:void 0}}async updateRasterFunction(){return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:n,renderer:o}=this;if(!e||!n||!o)return;const{rasterInfo:s}=this.raster,a=me(s,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),l=a?.name,c=fe(s,l);return this._updateSymbolizer(n,o,l,c)}async applyRenderer(e,n,o){const s=e?.pixelBlock;if(!(s!=null&&s.pixels&&s.pixels.length>0))return null;await this.updateRenderer();const a=this.bandIds??[],{pixelBlock:l}=await this._symbolize({pixelData:e,simpleStretchParams:n,bandIds:a,symbolizer:this.symbolizer},o);return l}getTileUrl(e,n,o){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${n}/${o}`:""}getCompatibleTileInfo(e,n,o=!1){if(!this.loaded||n==null)return null;if(o&&e.equals(this.spatialReference))return this.tileInfo;const s=He(e);return K.create({size:256,spatialReference:e,origin:s?{x:s.origin[0],y:s.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,n,o,s={}){if(r(this),s.requestAsImageElement){const l=this.getTileUrl(e,n,o);return we(l,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:s.signal}).then(c=>c.data)}const{serviceRasterInfo:a}=this;if(a.multidimensionalInfo!=null&&(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition==null){const l=s.tileInfo||a.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,n,o,l),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),this.renderer?.type==="raster-shaded-relief"&&(s={...s,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,n,o,s)}async fetchPixels(e,n,o,s={}){return this.serviceRasterInfo.multidimensionalInfo!=null&&(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition==null?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),o=Math.round(o),this.raster.fetchPixels(e,n,o,s))}async getSamples(e,n){if(await this.load(),(e=se(Ve,e).clone()).interpolation&&e.interpolation!=="nearest")throw new M("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const o=e.mosaicRule?.multidimensionalDefinition,s={...n,multidimensionalDefinition:o},a=(await this._getSampleLocations(e)).map(c=>this.identify(c,s).then(u=>(u.location=c,u))),l=(await Promise.all(a)).flatMap((c,u)=>this._convertRasterIdentifyResultToSample(c,u));return new Ue({samples:l})}async identify(e,n={}){await this.load();const{raster:o,serviceRasterInfo:s}=this;if(s?.multidimensionalInfo!=null&&!(s.hasMultidimensionalTranspose&&!(!ve(n.multidimensionalDefinition)&&!n.transposedVariableName))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};const a=this.multidimensionalSubset?.areaOfInterest;if(a&&!a.contains(e))throw new M("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");const l=this.serviceRasterInfo?.storageInfo.isBsqTile&&this.bandIds?.length?this.bandIds:void 0;return o.identify(e,{...n,bandIds:l})}hasStandardTime(){const e=this.serviceRasterInfo?.multidimensionalInfo;if(e==null||this.serviceRasterInfo?.dataType!=="standard-time")return!1;const n=this.multidimensionalDefinition,o=n?.[0]?.variableName;return e.variables.some(s=>s.name===o&&(!n?.[0].dimensionName||s.dimensions.some(a=>a.name==="StdTime")))}getStandardTimeValue(e){return new Date(Qe(e)).toISOString()}getMultidimensionalSubsetVariables(e){const n=e??this.serviceRasterInfo?.multidimensionalInfo;return Xe(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Ze(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&V(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;r(this);const{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,V(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(e){const{geometry:n}=e;if(n.type==="point")return[n];const{spatialReference:o,type:s}=n;if(s==="multipoint")return n.points.map(d=>new B({x:d[0],y:d[1],spatialReference:o}));if(s==="polyline"){let d=n;if(e.sampleCount||e.sampleDistance){const f=await Y(()=>import("./densifyOperator-0bfde292.js"),["assets/densifyOperator-0bfde292.js","assets/index-8ee34b61.js","assets/index-a5714ce2.css","assets/Point2D-e62ad2de.js","assets/ProjectionTransformation-16676837.js","assets/Envelope2D-4833fda6.js","assets/Transformation2D-ab2ac5ee.js","assets/SimpleGeometryCursor-e3941f41.js","assets/OperatorDefinitions-181ceaf8.js","assets/jsonConverter-13a35099.js","assets/densifyOperator-810ba2b3.js","assets/apiConverter-660b6342.js"]),b=(await Y(()=>import("./lengthOperator-f932f99f.js"),["assets/lengthOperator-f932f99f.js","assets/index-8ee34b61.js","assets/index-a5714ce2.css","assets/Point2D-e62ad2de.js","assets/Envelope2D-4833fda6.js","assets/ProjectionTransformation-16676837.js","assets/Transformation2D-ab2ac5ee.js","assets/SimpleGeometryCursor-e3941f41.js","assets/OperatorDefinitions-181ceaf8.js","assets/jsonConverter-13a35099.js","assets/lengthOperator-2b75ed17.js","assets/apiConverter-660b6342.js"])).execute(n,{unit:"meters"}),R=Math.min(e.sampleCount||100,Re);let _=e.sampleDistance;_||(_=b/(R+(d.paths[0].length===2?1:0))),d=f.execute(n,_,{unit:"meters"})}return d.paths.flatMap(f=>f.map(b=>new B({x:b[0],y:b[1],spatialReference:o})))}const a=Math.min(e.sampleCount||100,Re),l=n.type==="extent",c=l?n:n.extent,u=Math.sqrt(c.width*c.height/a),m=c.height/u,h=c.width/u,{xmin:y,ymax:p}=c,x=[];for(let d=0;d<m;d++)for(let f=0;f<h;f++){const b=new B({x:y+(f+.5)*u,y:p-(d+.5)*u,spatialReference:o});(l||n.contains(b))&&x.push(b)}return x}_configDefaultInterpolation(){if(this.interpolation==null){r(this);const{raster:e}=this,n=Ye(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",n)}}_configDefaultRenderer(e="no"){r(this);const{rasterInfo:n}=this.raster,o=me(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),s=o?.name,a=Ke({variableName:s,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=a?.bandIds??et(n)),!this.renderer||e==="override"){const m=tt(this.raster),h=a?.renderer??de(n,{bandIds:this.bandIds,variableName:s,rasterFunctionColorRamp:m}),y=n.statistics,p=y&&y.length>0?y[0]:null,x=p?.max??0,d=p?.min??0;this.raster.datasetFormat==="WCSServer"&&h.type==="raster-stretch"&&(x>1e24||d<-1e24)&&(h.dynamicRangeAdjustment=!0,h.customStatistics=null,h.stretchType==="none"&&(h.stretchType="min-max")),this.renderer=h}const l=it({...this.renderer.toJSON(),variableName:s}),c=fe(n,s);this.symbolizer?(this.symbolizer.rendererJSON=l,this.symbolizer.rasterInfo=c):this.symbolizer=new ht({rendererJSON:l,rasterInfo:c});const u=this.symbolizer.bind();if(u.success){if(e==="auto"){const{colormap:m}=this.raster.rasterInfo,h=this.renderer;if(m!=null&&h.type==="raster-colormap"){const y=de(this.raster.rasterInfo);JSON.stringify(y)!==JSON.stringify(h)&&this._configDefaultRenderer("override")}else if(h.type==="raster-stretch"){const y=this.bandIds?.length,p=h.customStatistics?.length;!h.dynamicRangeAdjustment&&p&&y&&p!==y&&this._configDefaultRenderer("override")}}}else re.getLogger(this).warn("imagery-tile-mixin",u.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&V(this.raster)){const u=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&u&&this._set("rasterFunction",he.fromJSON(u)))}let e,n=this.raster,o=!1;V(n)?(e=n.primaryRasters.rasters,n=e[0],o=!0):e=[n];const{rasterFunction:s}=this;if(s){const u={raster:n};e.length>1&&e.forEach(y=>u[y.url]=y);const m=Rt(s.functionDefinition?.toJSON()??s.toJSON(),u),h=new j({rasterFunction:m});h.rasterJobHandler=this._rasterJobHandler,await h.open(),this.raster=h}else this.raster=n,await n.open();if(this._cachedRendererJson=void 0,!o&&!s)return;const{bandIds:a}=this,{bandCount:l}=this.raster.rasterInfo,c=a?.length?a.some(u=>u>=l):l>=3;a&&(c||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(e,n){const{rasterInfo:o}=this.raster,s=o.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),a=(o.pixelSize.x+o.pixelSize.y)/2*s;if(!e.dataSeries?.length)return[new pe({location:e.location,pixelValue:e.value,locationId:n,resolution:a})];const l=[];return e.dataSeries.forEach(({value:c,multidimensionalDefinition:u},m)=>{const h={Variables:u[0].variableName,Dimensions:u.flatMap(({dimensionName:p})=>p).join(",")};for(const{dimensionName:p,values:x}of u){h[p]=Array.isArray(x[0])?x[0][0]:x[0];const d=x[x.length-1];h[`${p}_Max`]=Array.isArray(d)?d[d.length-1]:d}const y=new pe({location:e.location,pixelValue:c,rasterId:m,locationId:n,resolution:a,attributes:h});l.push(y)}),l}};function r(e){if(!e.raster||!e.serviceRasterInfo)throw new M("imagery-tile","no raster")}return g([I({clonable:!1})],t.prototype,"_cachedRasterFunctionJson",void 0),g([I({clonable:!1})],t.prototype,"_compatibleFullExtent",void 0),g([I({clonable:!1})],t.prototype,"_isConstructedFromFunctionRaster",void 0),g([I({clonable:!1})],t.prototype,"_rasterFunctionUpdatePromise",void 0),g([I({type:[$e],json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.bandIds?.join(",")!=="0,1,2"}}}}})],t.prototype,"bandIds",void 0),g([I({json:{origins:{service:{read:{source:"copyrightText"}}}}})],t.prototype,"copyright",void 0),g([I({json:{read:!1}})],t.prototype,"fullExtent",null),g([I({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Me(ct)],t.prototype,"interpolation",void 0),g([I()],t.prototype,"ioConfig",void 0),g([I({type:[Se],json:{write:!0}})],t.prototype,"multidimensionalDefinition",null),g([I({type:We,json:{write:!0}})],t.prototype,"multidimensionalSubset",void 0),g([I()],t.prototype,"raster",void 0),g([I({type:he})],t.prototype,"rasterFunction",null),g([I()],t.prototype,"serviceRasterInfo",void 0),g([I()],t.prototype,"sourceJSON",void 0),g([I({readOnly:!0,type:_e,json:{read:!1}})],t.prototype,"spatialReference",void 0),g([I({type:K})],t.prototype,"tileInfo",void 0),g([I(Ie)],t.prototype,"url",null),g([I()],t.prototype,"renderer",null),g([I({types:Le,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e=this.renderer?.type==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:Ae,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"&&e.type!=="flow"})}}}}})],t.prototype,"internalRenderer",null),g([Je("internalRenderer")],t.prototype,"readRenderer",null),g([I({clonable:!1})],t.prototype,"symbolizer",void 0),t=g([ce("esri.layers.mixins.ImageryTileMixin")],t),t};function ee(i,t){if(!i||!t)return[];let r=t;t.includes("/")?(r=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const e=[];if(t){const o=ee(i,r);for(let s=0;s<o.length;s++)ee(o[s],t).forEach(a=>e.push(a));return e}const n=i.getElementsByTagNameNS("*",r);if(!n||n.length===0)return[];for(let o=0;o<n.length;o++)e.push(n[o]||n.item(o));return e}function Te(i,t){if(!i||!t)return null;let r=t;t.includes("/")?(r=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const e=ee(i,r);return e.length>0?t?Te(e[0],t):e[0]:null}function Pe(i,t=null){const r=t?Te(i,t):i;let e;return r?(e=r.textContent||r.nodeValue,e?e.trim():null):null}function Dt(i,t){const r=ee(i,t),e=[];let n;for(let o=0;o<r.length;o++)n=r[o].textContent||r[o].nodeValue,n&&(n=n.trim(),n!==""&&e.push(n));return e}function Wt(i,t=null){return Pe(i,t)?.split(" ").map(e=>Number(e))??[]}function Lt(i,t){return Dt(i,t).map(r=>Number(r))}function At(i,t){const r=Pe(i,t);return Number(r)}function qt(i,t){const r=i?.nodeName?.toLowerCase(),e=t.toLowerCase();return r.slice(r.lastIndexOf(":")+1)===e}function Gt(i){return i.nodeName.slice(i.nodeName.lastIndexOf(":")+1)}export{w as $,Ot as X,Gt as c,Te as e,qt as i,Dt as l,j as m,ee as n,At as o,Wt as r,Pe as t,Lt as u};
