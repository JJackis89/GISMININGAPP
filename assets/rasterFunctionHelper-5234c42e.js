import{U as gs}from"./colorUtils-8a0a0c74.js";import{r as h,m as d,a as N,l as Hs,dP as Js,a9 as rt,bf as nt,aD as J,bh as vn,az as An,_ as de,M as K,z as Bt,ec as jt,aI as Pn,L as Tn,P as Ks,c1 as $n,p as Gt,k$ as et,l0 as tt,l1 as ys,l2 as Rn,av as Nn,l3 as Fn,f as kn,kb as In,Z as oe,kc as Xs,d as Ae,d4 as lt,kk as pe}from"./index-f00bd99f.js";import{m as _n,c as $,$ as Sn,a0 as Ys,a1 as W,X as ft,a2 as Mn,a3 as Cn,a4 as Ct,a5 as Bn,a6 as Zs,w as Se,a7 as Qs,a8 as tn,a9 as en,aa as Te,ab as jn,ac as Gn,ad as ls,ae as ie,af as zn,ag as sn,ah as ge,ai as nn,aj as rn,i as $e,ak as on,al as En,am as Yt,an as On,ao as Dn,ap as Vn,aq as Un,ar as Ln,as as Wn,at as qn,au as Hn,av as Re,aw as Jn,ax as Kn,ay as Xn}from"./dataUtils-6e3ebbe4.js";let he=class extends Hs{constructor(){super(...arguments),this.raster=void 0}};h([d({json:{write:!0}})],he.prototype,"raster",void 0),he=h([N("esri.layers.support.rasterFunctions.BaseFunctionArguments")],he);const O=he;var Me;let Ot=Me=class extends O{constructor(){super(...arguments),this.raster2=void 0}get rasters(){return[this.raster,this.raster2]}clone(){return new Me({raster:this.raster,raster2:this.raster2,operation:this.operation})}};h([d({json:{write:!0}})],Ot.prototype,"operation",void 0),h([d({json:{write:!0}})],Ot.prototype,"raster2",void 0),h([d({readOnly:!0})],Ot.prototype,"rasters",null),Ot=Me=h([N("esri.layers.support.rasterFunctions.ArithmeticFunctionArguments")],Ot);const Yn=Ot,Zn=new Set(["slope","aspect","curvature","hillshade","shadedrelief","statistics"]);let E=class extends Hs{constructor(){super(...arguments),this.functionArguments=null,this.readingBufferSize=0,this.id=-1,this.isNoopProcess=!1,this.rawInputBandIds=[],this.rawSourceRasterInfos=null,this.isInputBandIdsSwizzled=!1,this.swizzledBandSelection=[],this.isBranch=!1,this.isRoot=!1,this._bindingResult=null}get supportsGPU(){return this._bindingResult.supportsGPU}get flatWebGLFunctionChain(){const t=this.getWebGLProcessorDefinition();if(!t)return null;const e=[t],{parameters:s}=t;let o=s.rasters||s.raster&&[s.raster];for(;o?.length;){e.unshift(...o);const u=[];for(let l=0;l<o.length;l++){const{parameters:c}=o[l],p=c.rasters||c.raster&&[c.raster];p?.length&&u.push(...p)}o=u}for(let u=e.length-1;u>=0;u--)e[u].isNoopProcess&&e.splice(u,1);let n=!1;for(let u=0;u<e.length;u++){const l=e[u];l.id=e.length-u-1;const{rasters:c}=l.parameters;n=n||c!=null&&c.length>1}const a=e.some(({name:u})=>Zn.has(u.toLowerCase())),{rawSourceRasterInfos:i}=this;return{functions:e,hasBranches:n,hasFocalFunction:a,isSourceSingleBand:i?.[0]?.bandCount===1}}bind(t,e=!1,s=-1){this.id=s+1;const o=this._getRasterValues();let n=!0;for(let a=0;a<o.length;a++){const i=o[a];if(i!=null&&this._isRasterFunctionValue(i)){const u=i.bind(t,e,this.id+a);if(!u.success)return this._bindingResult=u,u;n=n&&u.supportsGPU}}return!this.rasterInfo||e?(this.sourceRasterInfos=this._getSourceRasterInfos(t),this._bindingResult=this._bindSourceRasters(),n&&(n=this._bindingResult.supportsGPU),this._bindingResult.success&&(this._patchRasterInfo(),n&&this.isRoot)&&(this.processInputBandIds(),this.swizzleInputBandIds(this.rawInputBandIds)||(n=this.rawInputBandIds.length<=3)),this._bindingResult.supportsGPU=n,this._bindingResult):(this._bindingResult={success:!0,supportsGPU:!0},this._bindingResult)}process(t){const e=this._getRasterValues(),s=e.length===0?t.pixelBlocks??t.primaryPixelBlocks:e.map(o=>this._readRasterValue(o,t));return this._processPixels({...t,pixelBlocks:s})}processInputBandIds(){const t=this._getRasterValues().filter(this._isRasterFunctionValue);if(t.length>1){const n=t.map(a=>a.processInputBandIds());return this.rawInputBandIds=[...new Set(n.flat())],this.rawInputBandIds}const e=t[0];if(e)return this.rawInputBandIds=e.processInputBandIds(),this.rawInputBandIds;const{bandCount:s}=this.sourceRasterInfos[0],o=Array.from({length:s},(n,a)=>a);return this.rawInputBandIds=this._getInputBandIds(o),this.rawInputBandIds}swizzleInputBandIds(t){const e=this._getRasterValues().filter(this._isRasterFunctionValue);let s=!0;for(const o of e)s=o.swizzleInputBandIds(t)&&s;return!!s&&this._swizzleBandIds(t)}getPrimaryRasters(){const t=[],e=[];return this._getPrimaryRasters(this,t,e),{rasters:t,rasterIds:e}}getWebGLProcessorDefinition(){const t=this._getWebGLParameters(),{raster:e,rasters:s}=this.functionArguments;return s&&Array.isArray(s)&&s.length?(t.rasters=s.map(o=>this._isRasterFunctionValue(o)?o.getWebGLProcessorDefinition():typeof o=="number"?{name:"Constant",parameters:{value:o},pixelType:"f32",id:-1,isNoopProcess:!1}:{name:"Identity",parameters:{value:o},pixelType:"f32",id:-1,isNoopProcess:!1}),t.rasters.some(o=>o!=null)||(t.rasters=null)):this._isRasterFunctionValue(e)&&(t.raster=e.getWebGLProcessorDefinition()),{name:this.functionName,parameters:t,pixelType:this.outputPixelType,id:this.id,isNoopProcess:this.isNoopProcess}}getClippingGeometries(){const t=[];this.functionName==="Clip"&&t.push(this.functionArguments);const{raster:e,rasters:s}=this.functionArguments;if(s&&Array.isArray(s)&&s.length)s.forEach(o=>{if(this._isRasterFunctionValue(o)){const n=o.getClippingGeometries();t.push(...n)}});else if(this._isRasterFunctionValue(e)){const o=e.getClippingGeometries();t.push(...o)}return t}_getOutputPixelType(t){return this.outputPixelType==="unknown"?t:this.outputPixelType??t}_getWebGLParameters(){return{}}_getInputBandIds(t){return t}_swizzleBandIds(t){return!0}_isInputRasterPrimaryOrConstant(){return!this._getRasterValues().some(t=>t&&typeof t=="object"&&"rasterFunction"in t&&t.rasterFunction)}_removeStatsHistColormapVAT(t){t.statistics=null,t.histograms=null,t.colormap=null,t.attributeTable=null,t.multidimensionalInfo?.variables.forEach(e=>{e.statistics=void 0,e.histograms=void 0})}_getRasterValues(){const{rasterArgumentNames:t}=this;return t[0]==="rasters"?this.functionArguments.rasters??[]:t.flatMap(e=>this.functionArguments[e])}_getSourceRasterInfos(t){const e=this._getRasterValues(),{rasterInfos:s,rasterIds:o}=t;if(e.length===0)return s;const n=e.map(i=>i&&typeof i=="object"&&"bind"in i&&i.rasterInfo?i.rasterInfo:typeof i=="string"&&o.includes(i)?s[o.indexOf(i)]:typeof i!="number"?s[0]:void 0),a=n.find(i=>i)??s[0];return n.forEach((i,u)=>{i===void 0&&(n[u]=a)}),n}_getPrimaryRasterId(t){return t?.rasterId}_getPrimaryRasters(t,e=[],s=[]){for(let o=0;o<t.sourceRasters.length;o++){const n=t.sourceRasters[o];if(typeof n!="number")if("bind"in n)this._getPrimaryRasters(n,e,s);else{const a=n,i=this._getPrimaryRasterId(a);if(i==null)continue;s.includes(i)||(this.mainPrimaryRasterId===i?(e.unshift(a),s.unshift(i)):(e.push(a),s.push(i)))}}}_isRasterFunctionValue(t){return t!=null&&typeof t=="object"&&"getWebGLProcessorDefinition"in t}_readRasterValue(t,e){const{primaryPixelBlocks:s}=e;if(t==null||t==="$$"){const o=s[0];return o==null?null:o.clone()}if(typeof t=="string"){const o=e.primaryRasterIds.indexOf(t);return o===-1?null:s[o]}if(typeof t=="number"){const o=s[0];if(o==null)return null;const{width:n,height:a,pixelType:i}=o,u=new Float32Array(n*a);u.fill(t);const l=this.sourceRasterInfos[0].bandCount,c=new Array(l).fill(u);return new $({width:n,height:a,pixelType:i,pixels:c})}return t.process(e)}_patchRasterInfo(){const{rasterInfo:t}=this;if(!t?.keyProperties)return;const{bandCount:e,keyProperties:s,statistics:o,histograms:n}=t,a=s.BandProperties;a&&a.length!==e&&(t.keyProperties={...s,BandProperties:void 0}),o&&o.length!==e&&(t.statistics=o.length>e?o.slice(0,e):null),n&&n.length!==e&&(t.histograms=n.length>e?n.slice(0,e):null),s.BAND_COUNT&&Number(s.BAND_COUNT)!==e&&(t.keyProperties={...s,BAND_COUNT:typeof s.BAND_COUNT=="string"?String(e):e})}};h([d({json:{write:!0}})],E.prototype,"functionName",void 0),h([d({json:{write:!0}})],E.prototype,"functionArguments",void 0),h([d()],E.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}}),Js(r=>r?.toLowerCase())],E.prototype,"outputPixelType",void 0),h([d({json:{write:!0}})],E.prototype,"mainPrimaryRasterId",void 0),h([d()],E.prototype,"sourceRasters",void 0),h([d({type:[_n],json:{write:!0}})],E.prototype,"sourceRasterInfos",void 0),h([d({json:{write:!0}})],E.prototype,"rasterInfo",void 0),h([d({json:{write:!0}})],E.prototype,"readingBufferSize",void 0),h([d({json:{write:!0}})],E.prototype,"id",void 0),h([d()],E.prototype,"isNoopProcess",void 0),h([d()],E.prototype,"supportsGPU",null),h([d()],E.prototype,"rawInputBandIds",void 0),h([d()],E.prototype,"rawSourceRasterInfos",void 0),h([d()],E.prototype,"isInputBandIdsSwizzled",void 0),h([d()],E.prototype,"swizzledBandSelection",void 0),h([d()],E.prototype,"isBranch",void 0),h([d()],E.prototype,"isRoot",void 0),h([d({readOnly:!0})],E.prototype,"flatWebGLFunctionChain",null),h([d()],E.prototype,"_bindingResult",void 0),E=h([N("esri.layers.support.rasterFunctions.BaseRasterFunction")],E);const z=E,M={userDefined:-1,lineDetectionHorizontal:0,lineDetectionVertical:1,lineDetectionLeftDiagonal:2,lineDetectionRightDiagonal:3,gradientNorth:4,gradientWest:5,gradientEast:6,gradientSouth:7,gradientNorthEast:8,gradientNorthWest:9,smoothArithmeticMean:10,smoothing3x3:11,smoothing5x5:12,sharpening3x3:13,sharpening5x5:14,laplacian3x3:15,laplacian5x5:16,sobelHorizontal:17,sobelVertical:18,sharpen:19,sharpen2:20,pointSpread:21,none:255},Qn={plus:1,minus:2,times:3,sqrt:4,power:5,abs:10,divide:23,exp:25,exp10:26,exp2:27,int:30,float:32,ln:35,log10:36,log2:37,mod:44,negate:45,roundDown:48,roundUp:49,square:53,floatDivide:64,floorDivide:65},q={bitwiseAnd:11,bitwiseLeftShift:12,bitwiseNot:13,bitwiseOr:14,bitwiseRightShift:15,bitwiseXOr:16,booleanAnd:17,booleanNot:18,booleanOr:19,booleanXOr:20,equalTo:24,greaterThan:28,greaterThanEqual:29,lessThan:33,lessThanEqual:34,isNull:31,notEqual:46},Z={acos:6,asin:7,atan:8,atanh:9,cos:21,cosh:22,sin:51,sinh:52,tan:56,tanh:57,acosh:59,asinh:60,atan2:61},tr={majority:38,max:39,mean:40,med:41,min:42,minority:43,range:47,stddev:54,sum:55,variety:58,majorityIgnoreNoData:66,maxIgnoreNoData:67,meanIgnoreNoData:68,medIgnoreNoData:69,minIgnoreNoData:70,minorityIgnoreNoData:71,rangeIgnoreNoData:72,stddevIgnoreNoData:73,sumIgnoreNoData:74,varietyIgnoreNoData:75},an={setNull:50,conditional:78},xs={...Qn,...q,...Z,...tr,...an},un=new Map([[Z.acos,{domain:[0,Math.PI],isInteger:!1}],[Z.asin,{domain:[-Math.PI/2,Math.PI/2],isInteger:!1}],[Z.atan,{domain:[-Math.PI/2,Math.PI/2],isInteger:!1}],[Z.cos,{domain:[-1,1],isInteger:!1}],[Z.sin,{domain:[-1,1],isInteger:!1}],[q.booleanAnd,{domain:[0,1],isInteger:!0}],[q.booleanNot,{domain:[0,1],isInteger:!0}],[q.booleanOr,{domain:[0,1],isInteger:!0}],[q.booleanXOr,{domain:[0,1],isInteger:!0}],[q.equalTo,{domain:[0,1],isInteger:!0}],[q.notEqual,{domain:[0,1],isInteger:!0}],[q.greaterThan,{domain:[0,1],isInteger:!0}],[q.greaterThanEqual,{domain:[0,1],isInteger:!0}],[q.lessThan,{domain:[0,1],isInteger:!0}],[q.lessThanEqual,{domain:[0,1],isInteger:!0}],[q.isNull,{domain:[0,1],isInteger:!0}]]);function ws(r){return un.get(r)}const bs=[0,2,2,2,1,2,1,1,1,1,1,2,2,1,2,2,2,2,1,2,2,1,1,2,2,1,1,1,2,2,1,1,1,2,2,1,1,1,999,999,999,999,999,999,2,1,2,999,1,1,2,1,1,1,999,999,1,1,999,1,1,2,999,999,2,2,999,999,999,999,999,999,999,999,999,999,3,999,3];function er(r,t=!1){const e=r.map(i=>i.mask),s=e.filter(i=>i!=null),o=r[0].pixels[0].length;if(s.length===0||t&&s.length!==e.length)return new Uint8Array(o).fill(255);const n=s[0],a=new Uint8Array(n);if(s.length===1)return a;if(!t){for(let i=1;i<s.length;i++){const u=s[i];for(let l=0;l<a.length;l++)a[l]&&(a[l]=u[l]?255:0)}return a}for(let i=1;i<s.length;i++){const u=s[i];for(let l=0;l<a.length;l++)a[l]===0&&(a[l]=u[l]?255:0)}return a}function sr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]+o[i]);return a}function nr(r,t,e){const[s]=r,o=s.length,n=$.createEmptyBand("f32",o);return n.set(s),n}function rr(r,t,e){const[s]=r,o=s.length,n=$.createEmptyBand(e,o);for(let a=0;a<o;a++)t&&!t[a]||(n[a]=s[a]*s[a]);return n}function or(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]-o[i]);return a}function ir(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]*o[i]);return a}function ar(r,t,e){const[s]=r,o=s.length,n=$.createEmptyBand(e,o);for(let a=0;a<o;a++)t&&!t[a]||(n[a]=Math.sign(s[a])*Math.floor(Math.abs(s[a])));return n}function ln(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]/o[i]);return a}function ur(r,t,e){return ln(r,t,"f32")}function lr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=Math.floor(s[i]/o[i]));return a}function cr(r,t,e,s){const o=r[0],n=o.length,a=$.createEmptyBand(e,n);if(s===Z.atanh){for(let u=0;u<n;u++)if(t[u]){const l=o[u];Math.abs(l)>=1?t[u]=0:a[u]=Math.atanh(l)}return a}const i=s===Z.asin?Math.asin:Math.acos;for(let u=0;u<n;u++)if(t[u]){const l=o[u];Math.abs(l)>1?t[u]=0:a[u]=i(l)}return a}function pr(r,t,e,s){const[o]=r,n=o.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s(o[i]));return a}function hr(r,t,e,s){const[o,n]=r,a=o.length,i=$.createEmptyBand(e,a);for(let u=0;u<a;u++)t&&!t[u]||(i[u]=s(o[u],n[u]));return i}function mr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]&o[i]);return a}function fr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]<<o[i]);return a}function dr(r,t,e){const[s]=r,o=s.length,n=$.createEmptyBand(e,o);for(let a=0;a<o;a++)t&&!t[a]||(n[a]=~s[a]);return n}function gr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]|o[i]);return a}function yr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]>>o[i]);return a}function xr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]^o[i]);return a}function wr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]&&o[i]?1:0);return a}function br(r,t,e){const[s]=r,o=s.length,n=$.createEmptyBand(e,o);for(let a=0;a<o;a++)t&&!t[a]||(n[a]=s[a]?0:1);return n}function vr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]||o[i]?1:0);return a}function Ar(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=(s[i]?1:0)^(o[i]?1:0));return a}function Pr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]===o[i]?1:0);return a}function cs(r,t,e,s){const[o]=r,n=o.length,a=$.createEmptyBand(e,n),i=s===Math.E;for(let u=0;u<n;u++)t&&!t[u]||(a[u]=i?Math.exp(o[u]):s**o[u]);return a}function Tr(r,t,e){return cs(r,t,e,10)}function $r(r,t,e){return cs(r,t,e,2)}function Rr(r,t,e){return cs(r,t,e,Math.E)}function ps(r,t,e,s){const[o]=r,n=o.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(o[i]<=0?t[i]=0:a[i]=s(o[i]));return a}function Nr(r,t,e){return ps(r,t,e,Math.log10)}function Fr(r,t,e){return ps(r,t,e,Math.log2)}function kr(r,t,e){return ps(r,t,e,Math.log)}function Ir(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]>o[i]?1:0);return a}function _r(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]>=o[i]?1:0);return a}function Sr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]<o[i]?1:0);return a}function Mr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]<=o[i]?1:0);return a}function Cr(r,t,e){const[s]=r,o=s.length,n=$.createEmptyBand(e,o);if(!t)return n;for(let a=0;a<o;a++)n[a]=t[a]?0:1;return n}function Br(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]%o[i]);return a}function jr(r,t,e){const[s]=r,o=s.length,n=$.createEmptyBand(e,o);for(let a=0;a<o;a++)t&&!t[a]||(n[a]=-s[a]);return n}function Gr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]===o[i]?0:1);return a}function zr(r,t,e){const[s,o]=r,n=s.length,a=$.createEmptyBand(e,n),i=new Uint8Array(n);for(let u=0;u<n;u++)t!=null&&!t[u]||s[u]!==0||(a[u]=o[u],i[u]=255);return{band:a,mask:i}}function vs(r,t,e){const[s,o,n]=r,a=s.length,i=$.createEmptyBand(e,a);for(let u=0;u<a;u++)t&&!t[u]||(i[u]=s[u]?o[u]:n[u]);return i}function As(r,t,e){const s=r.length;if(s<2)return r[0];const[o]=r,n=o.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)if(!t||t[i]){let u=o[i];for(let l=1;l<s;l++){const c=r[l][i];u<c&&(u=c)}a[i]=u}return a}function Ps(r,t,e){const s=r.length;if(s<2)return r[0];const[o]=r,n=o.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)if(!t||t[i]){let u=o[i];for(let l=1;l<s;l++){const c=r[l][i];u>c&&(u=c)}a[i]=u}return a}function Ts(r,t,e){const s=r.length;if(s<2)return r[0];const[o]=r,n=o.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)if(!t||t[i]){let u=o[i],l=u;for(let c=1;c<s;c++){const p=r[c][i];l<p?l=p:u>p&&(u=p)}a[i]=l-u}return a}function $s(r,t,e){const s=r.length;if(s<2)return r[0];const[o]=r,n=o.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)if(!t||t[i]){let u=0;for(let l=0;l<s;l++)u+=r[l][i];a[i]=u/s}return a}function Rs(r,t,e){const s=r.length;if(s<2)return r[0];const[o]=r,n=o.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)if(!t||t[i])for(let u=0;u<s;u++){const l=r[u];a[i]+=l[i]}return a}function Ns(r,t,e){const s=r.length;if(s<2)return r[0];const[o]=r,n=o.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)if(!t||t[i]){const u=new Float32Array(s);let l=0;for(let p=0;p<s;p++){const m=r[p];l+=m[i],u[p]=m[i]}l/=s;let c=0;for(let p=0;p<s;p++)c+=(u[p]-l)**2;a[i]=Math.sqrt(c/s)}return a}function Fs(r,t,e){const s=r.length;if(s<2)return r[0];const o=Math.floor(s/2),[n]=r,a=n.length,i=$.createEmptyBand(e,a),u=new Float32Array(s),l=s%2==1;for(let c=0;c<a;c++)if(!t||t[c]){for(let p=0;p<s;p++)u[p]=r[p][c];u.sort(),i[c]=l?u[o]:(u[o]+u[o-1])/2}return i}function cn(r,t,e){const[s,o]=r;if(o==null)return s;const n=s.length,a=$.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]<o[i]?s[i]:o[i]);return a}function ks(r,t,e){const s=r.length;if(s<=2)return cn(r,t,e);const o=r[0].length,n=$.createEmptyBand(e,o),a=new Map;for(let i=0;i<o;i++)if(!t||t[i]){a.clear();for(let p=0;p<s;p++){const m=r[p][i];a.set(m,a.has(m)?a.get(m)+1:1)}let u=0,l=0;const c=[];for(const p of a.keys())u=a.get(p),u>l?(l=u,c.length=0,c.push(p)):u===l&&c.push(p);c.length>1&&c.sort((p,m)=>p-m),n[i]=c[0]}return n}function Is(r,t,e){const s=r.length;if(s<=2)return cn(r,t,e);const o=r[0].length,n=$.createEmptyBand(e,o),a=new Map;for(let i=0;i<o;i++)if(!t||t[i]){a.clear();for(let p=0;p<s;p++){const m=r[p][i];a.set(m,a.has(m)?a.get(m)+1:1)}let u=0,l=r.length;const c=[];for(const p of a.keys())u=a.get(p),u<l?(l=u,c.length=0,c.push(p)):u===l&&c.push(p);c.length>1&&c.sort((p,m)=>p-m),n[i]=c[0]}return n}function _s(r,t,e){const s=r.length;if(s<2)return r[0];const[o]=r,n=o.length,a=$.createEmptyBand(e,n),i=new Set;for(let u=0;u<n;u++)if(!t||t[u]){let l;i.clear();for(let c=0;c<s;c++)l=r[c][u],i.add(l);a[u]=i.size}return a}const D=new Map,ye=new Map,_=new Map,G=new Map;function Er(){D.size||(D.set(4,Math.sqrt),D.set(6,Math.acos),D.set(7,Math.asin),D.set(8,Math.atan),D.set(9,Math.atanh),D.set(10,Math.abs),D.set(21,Math.cos),D.set(22,Math.cosh),D.set(48,Math.floor),D.set(49,Math.ceil),D.set(51,Math.sin),D.set(52,Math.sinh),D.set(56,Math.tan),D.set(57,Math.tanh),D.set(59,Math.acosh),D.set(60,Math.asinh),D.set(65,Math.floor),ye.set(5,Math.pow),ye.set(61,Math.atan2),_.set(1,sr),_.set(2,or),_.set(3,ir),_.set(11,mr),_.set(12,fr),_.set(13,dr),_.set(14,gr),_.set(15,yr),_.set(16,xr),_.set(17,wr),_.set(18,br),_.set(19,vr),_.set(20,Ar),_.set(23,ln),_.set(24,Pr),_.set(25,Rr),_.set(26,Tr),_.set(27,$r),_.set(28,Ir),_.set(29,_r),_.set(30,ar),_.set(31,Cr),_.set(32,nr),_.set(33,Sr),_.set(34,Mr),_.set(35,kr),_.set(36,Nr),_.set(37,Fr),_.set(44,Br),_.set(45,jr),_.set(46,Gr),_.set(53,rr),_.set(64,ur),_.set(65,lr),_.set(76,vs),_.set(78,vs),G.set(38,ks),G.set(39,As),G.set(40,$s),G.set(41,Fs),G.set(42,Ps),G.set(43,Is),G.set(47,Ts),G.set(54,Ns),G.set(55,Rs),G.set(58,_s),G.set(66,ks),G.set(67,As),G.set(68,$s),G.set(69,Fs),G.set(70,Ps),G.set(71,Is),G.set(72,Ts),G.set(73,Ns),G.set(74,Rs),G.set(75,_s))}function pn(r,t,e={}){Er();let s=er(r,t>=66&&t<=75);const{outputPixelType:o="f32"}=e,n=!G.has(t)||e.processAsMultiband,a=n?r[0].pixels.length:1,i=[];for(let l=0;l<a;l++){const c=G.has(t)&&!n?r.flatMap(f=>f.pixels):r.map(f=>f.pixels[l]);let p,m=!0;if(t===an.setNull){const f=zr(c,s,o);p=f.band,s=f.mask,m=!1}else _.has(t)?p=_.get(t)(c,s,"f64"):D.has(t)?p=t===Z.asin||t===Z.acos||t===Z.atanh?cr(c,s,"f64",t):pr(c,s,"f64",D.get(t)):ye.has(t)?p=hr(c,s,"f64",ye.get(t)):G.has(t)?p=G.get(t)(c,s,"f64"):(p=c[0],m=!1);if(m&&t!==q.isNull&&!un.has(t)){const f=$.createEmptyBand(o,p.length);s||(s=new Uint8Array(p.length).fill(255)),Sn(p,s),Ys(p,s,o,f),p=f}i.push(p)}const u=r[0];return new $({width:u.width,height:u.height,pixelType:o,mask:t===q.isNull?null:s,pixels:i})}function Or(r,t,e){return pn(r,t=[null,1,2,3,23,5,44][t]??1,{outputPixelType:e})}let Dt=class extends z{constructor(){super(...arguments),this.functionName="Arithmetic",this.functionArguments=null,this.rasterArgumentNames=["raster","raster2"]}_bindSourceRasters(){const{operation:t}=this.functionArguments;if(t<1||t>6)return{success:!1,supportsGPU:!1,error:"unsupported operation"};const e=this.sourceRasterInfos[0].clone();return this.outputPixelType=this._getOutputPixelType(e.pixelType),e.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(e),this.rasterInfo=e,{success:!0,supportsGPU:e.bandCount<=3}}_processPixels(t){const{pixelBlocks:e}=t;return e?.[0]==null||e?.[1]==null?null:Or(e,this.functionArguments.operation,this.outputPixelType)}_getWebGLParameters(){const{operation:t}=this.functionArguments,e=["","plus","minus","times","divide","power","mod"][t],s=this.outputPixelType??"f32";let[o,n]=ft(s);const a=W(s);return a&&(o-=1e-4,n+=1e-4),{imageCount:2,operationName:e,domainRange:[o,n],isOutputRounded:a}}};h([d({json:{write:!0,name:"rasterFunction"}})],Dt.prototype,"functionName",void 0),h([d({type:Yn,json:{write:!0,name:"rasterFunctionArguments"}})],Dt.prototype,"functionArguments",void 0),h([d()],Dt.prototype,"rasterArgumentNames",void 0),Dt=h([N("esri.layers.support.rasterFunctions.ArithmeticFunction")],Dt);const Dr=Dt;var Ce;let Be=Ce=class extends O{clone(){return new Ce({raster:this.raster})}};Be=Ce=h([N("esri.layers.support.rasterFunctions.AspectFunctionArguments")],Be);const Vr=Be;let dt=class extends z{constructor(){super(...arguments),this.functionName="Aspect",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){const t=this.sourceRasterInfos[0];this.isGCS=t.spatialReference?.isGeographic??!1,this.outputPixelType=this._getOutputPixelType("f32");const e=t.clone();return e.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(e),e.statistics=[{min:-1,max:360,avg:180,stddev:30}],e.bandCount=1,this.rasterInfo=e,{success:!0,supportsGPU:!0}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return null;const{extent:s,primaryPixelSizes:o}=t,n=o?.[0],a=n??(s?{x:s.width/e.width,y:s.height/e.height}:{x:1,y:1});return Mn(e,{resolution:a})}};h([d({json:{write:!0,name:"rasterFunction"}})],dt.prototype,"functionName",void 0),h([d({type:Vr,json:{write:!0,name:"rasterFunctionArguments"}})],dt.prototype,"functionArguments",void 0),h([d()],dt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],dt.prototype,"isGCS",void 0),dt=h([N("esri.layers.support.rasterFunctions.AspectFunction")],dt);const Ur=dt,Lr=new Set(["+","-","*","/","(",")"]);function Wr(r,t){(r=r.replaceAll(" ","")).startsWith("-")&&(r="0"+r),r.startsWith("+")&&(r=r.slice(1));const e=r.split(""),s=[],o=[];let n="";for(let a=0;a<e.length;a++){const i=e[a];Lr.has(i)?(n.length&&o.push(Ss(n,t)),s.push(i),n=""):n=n.concat(i)}return n.length&&o.push(Ss(n,t)),{ops:s,nums:o}}function Ss(r,t){return r.toLowerCase().startsWith("b")?t[parseInt(r.slice(1),10)-1]:parseFloat(r)}function qr(r,t,e,s){if(typeof e=="number"&&typeof s=="number")return e+s;let o,n,a;typeof e=="number"?(a=s,o=a.length,n=new Float32Array(o),n.fill(e)):(o=e.length,n=e,s.constructor===Number?(a=new Float32Array(o),a.fill(s)):a=s);const i=new Float32Array(o);switch(t){case"+":for(let u=0;u<o;u++)(r==null||r[u])&&(i[u]=n[u]+a[u]);break;case"-":for(let u=0;u<o;u++)(r==null||r[u])&&(i[u]=n[u]-a[u]);break;case"*":for(let u=0;u<o;u++)(r==null||r[u])&&(i[u]=n[u]*a[u]);break;case"/":for(let u=0;u<o;u++)(r==null||r[u])&&a[u]&&(i[u]=n[u]/a[u]);break;case"(":case")":throw new Error("encountered error with custom band index equation")}return i}function Hr(r,t){r.splice(t,1);let e=0,s=0;do{e=0,s=0;for(let o=0;o<r.length;o++)if(r[o]==="(")e=o;else if(r[o]===")"){s=o;break}s===e+1&&r.splice(e,2)}while(s===e+1);return r}function Jr(r){if(r.length===1)return{opIndex:0,numIndex:0};let t=0,e=0;for(let a=0;a<r.length;a++)if(r[a]==="(")t=a;else if(r[a]===")"){e=a;break}const s=e===0?r:r.slice(t+1,e);let o=-1;for(let a=0;a<s.length;a++)if(s[a]==="*"||s[a]==="/"){o=a;break}if(o>-1)e>0&&(o+=t+1);else{for(let a=0;a<s.length;a++)if(s[a]==="+"||s[a]==="-"){o=a;break}e>0&&(o+=t+1)}let n=0;for(let a=0;a<o;a++)r[a]==="("&&n++;return{opIndex:o,numIndex:o-n}}function Kr(r,t,e){let s,{ops:o,nums:n}=Wr(e,t);if(o.length===0){const a=n.length===1?n[0]:t[0];if(a instanceof Float32Array)return[a];const i=new Float32Array(t[0].length);return typeof a=="number"?i.fill(a):i.set(a),[i]}for(;o.length>0;){const{numIndex:a,opIndex:i}=Jr(o);if(s=qr(r,o[i],n[a],n[a+1]),o.length===1)break;o=Hr(o,i),n.splice(a,2,s)}return[s]}const Xr=new rt({0:"custom",1:"ndvi",2:"savi",3:"tsavi",4:"msavi",5:"gemi",6:"pvi",7:"gvitm",8:"sultan",9:"vari",10:"gndvi",11:"sr",12:"ndvi-re",13:"sr-re",14:"mtvi2",15:"rtvi-core",16:"ci-re",17:"ci-g",18:"ndwi",19:"evi",20:"iron-oxide",21:"ferrous-minerals",22:"clay-minerals",23:"wndwi",24:"bai",25:"nbr",26:"ndbi",27:"ndmi",28:"ndsi",29:"mndwi"},{useNumericKeys:!0});function Yr(r,t){if(!Cn(r))return r;const{equation:e,method:s}=t,o=t.bandIndexes.map(m=>m-1),{pixels:n,mask:a}=r;let i;switch(s){case"gndvi":case"nbr":case"ndbi":case"ndvi":case"ndvi-re":case"ndsi":case"ndmi":case"mndwi":i=Ms(a,n[o[0]],n[o[1]]);break;case"ndwi":i=Ms(a,n[o[1]],n[o[0]]);break;case"sr":case"sr-re":case"iron-oxide":case"ferrous-minerals":case"clay-minerals":i=Qr(a,n[o[0]],n[o[1]]);break;case"ci-g":case"ci-re":i=to(a,n[o[0]],n[o[1]]);break;case"savi":i=eo(a,n[o[0]],n[o[1]],o[2]+1);break;case"tsavi":i=so(a,n[o[0]],n[o[1]],o[2]+1,o[3]+1,o[4]+1);break;case"msavi":i=no(a,n[o[0]],n[o[1]]);break;case"gemi":i=ro(a,n[o[0]],n[o[1]]);break;case"pvi":i=oo(a,n[o[0]],n[o[1]],o[2]+1,o[3]+1);break;case"gvitm":i=io(a,[n[o[0]],n[o[1]],n[o[2]],n[o[3]],n[o[4]],n[o[5]]]);break;case"sultan":i=ao(a,[n[o[0]],n[o[1]],n[o[2]],n[o[3]],n[o[4]]]);break;case"vari":i=uo(a,[n[o[0]],n[o[1]],n[o[2]]]);break;case"mtvi2":i=lo(a,[n[o[0]],n[o[1]],n[o[2]]]);break;case"rtvi-core":i=co(a,[n[o[0]],n[o[1]],n[o[2]]]);break;case"evi":i=po(a,[n[o[0]],n[o[1]],n[o[2]]]);break;case"wndwi":i=ho(a,[n[o[0]],n[o[1]],n[o[2]]],o[3]?o[3]+1:.5);break;case"bai":i=mo(a,n[o[0]],n[o[1]]);break;case"custom":i=Kr(a,n,e);break;default:return r}const{outputPixelType:u="f32"}=t,l=u!=null&&W(u);let c;a?(c=new Uint8Array(r.width*r.height),c.set(a)):l&&(c=new Uint8Array(r.width*r.height).fill(255)),l&&(i=i.map(m=>{const f=$.createEmptyBand(u,m.length);return Ys(m,c,u,f),f}));const p=new $({width:r.width,height:r.height,pixelType:u,pixels:i,mask:c});return p.updateStatistics(),p}function Zr(r,t,e,s){const{mask:o,pixels:n,width:a,height:i}=r,u=n[e],l=n[t],c=l.length,p=s?new Uint8Array(c):new Float32Array(c),m=s?100:1,f=s?100.5:0;for(let x=0;x<c;x++)if(o==null||o[x]){const y=u[x],v=l[x],w=y+v;w&&(p[x]=(y-v)/w*m+f)}const g=new $({width:a,height:i,mask:o,pixelType:s?"u8":"f32",pixels:[p]});return g.updateStatistics(),g}function U(r){const t=new Float32Array(9);return t[3*r[0]]=1,t[3*r[1]+1]=1,t[3*r[2]+2]=1,t}function Ms(r,t,e){const s=e.length,o=new Float32Array(s);for(let n=0;n<s;n++)if(r==null||r[n]){const a=t[n],i=e[n],u=a+i;u&&(o[n]=(a-i)/u)}return[o]}function Qr(r,t,e){const s=e.length,o=new Float32Array(s);for(let n=0;n<s;n++)if(r==null||r[n]){const a=t[n],i=e[n];i&&(o[n]=a/i)}return[o]}function to(r,t,e){const s=t.length,o=new Float32Array(s);for(let n=0;n<s;n++)if(r==null||r[n]){const a=t[n],i=e[n];i&&(o[n]=a/i-1)}return[o]}function eo(r,t,e,s){const o=e.length,n=new Float32Array(o);for(let a=0;a<o;a++)if(r==null||r[a]){const i=e[a],u=t[a],l=u+i+s;l&&(n[a]=(u-i)/l*(1+s))}return[n]}function so(r,t,e,s,o,n){const a=e.length,i=new Float32Array(a),u=-o*s+n*(1+s*s);for(let l=0;l<a;l++)if(r==null||r[l]){const c=e[l],p=t[l],m=o*p+c+u;m&&(i[l]=s*(p-s*c-o)/m)}return[i]}function no(r,t,e){const s=e.length,o=new Float32Array(s);for(let n=0;n<s;n++)if(r==null||r[n]){const a=e[n],i=t[n],u=2*i+1;o[n]=.5*(u-Math.sqrt(u*u-8*(i-a)))}return[o]}function ro(r,t,e){const s=e.length,o=new Float32Array(s);for(let n=0;n<s;n++)if(r==null||r[n]){const a=e[n],i=t[n];if(a!==1&&i+a+.5!==0){const u=(2*(i*i-a*a)+1.5*i+.5*a)/(i+a+.5);o[n]=u*(1-.25*u)-(a-.125)/(1-a)}}return[o]}function oo(r,t,e,s,o){const n=e.length,a=new Float32Array(n),i=1/Math.sqrt(1+s*s);for(let u=0;u<n;u++)if(r==null||r[u]){const l=e[u],c=t[u];a[u]=(c-s*l-o)*i}return[a]}function io(r,t){const[e,s,o,n,a,i]=t,u=e.length,l=new Float32Array(u);for(let c=0;c<u;c++)(r==null||r[c])&&(l[c]=-.2848*e[c]-.2435*s[c]-.5436*o[c]+.7243*n[c]+.084*a[c]-.18*i[c]);return[l]}function ao(r,t){const[e,s,o,n,a]=t,i=e.length,u=new Float32Array(i),l=new Float32Array(i),c=new Float32Array(i);for(let p=0;p<i;p++)(r==null||r[p])&&(u[p]=a[p]?n[p]/a[p]*100:0,l[p]=e[p]?n[p]/e[p]*100:0,c[p]=o[p]?s[p]/o[p]*(n[p]/o[p])*100:0);return[u,l,c]}function uo(r,t){const[e,s,o]=t,n=e.length,a=new Float32Array(n);for(let i=0;i<n;i++)if(r==null||r[i])for(i=0;i<n;i++){const u=e[i],l=s[i],c=l+u-o[i];c&&(a[i]=(l-u)/c)}return[a]}function lo(r,t){const[e,s,o]=t,n=e.length,a=new Float32Array(n);for(let i=0;i<n;i++)if(r==null||r[i])for(i=0;i<n;i++){const u=e[i],l=s[i],c=o[i],p=Math.sqrt((2*u+1)**2-(6*u-5*Math.sqrt(l))-.5);if(p){const m=1.5*(1.2*(u-c)-2.5*(l-c));a[i]=m/p}}return[a]}function co(r,t){const[e,s,o]=t,n=e.length,a=new Float32Array(n);for(let i=0;i<n;i++)if(r==null||r[i])for(i=0;i<n;i++){const u=e[i],l=s[i],c=o[i];a[i]=100*(u-l)-10*(u-c)}return[a]}function po(r,t){const[e,s,o]=t,n=e.length,a=new Float32Array(n);for(let i=0;i<n;i++)if(r==null||r[i])for(i=0;i<n;i++){const u=e[i],l=s[i],c=u+6*l-7.5*o[i]+1;c&&(a[i]=2.5*(u-l)/c)}return[a]}function ho(r,t,e=.5){const[s,o,n]=t,a=o.length,i=new Float32Array(a);for(let u=0;u<a;u++)if(r==null||r[u])for(u=0;u<a;u++){const l=s[u],c=o[u],p=n[u],m=l+e*c+(1-e)*p;m&&(i[u]=(l-e*c-(1-e)*p)/m)}return[i]}function mo(r,t,e){const s=e.length,o=new Float32Array(s);for(let n=0;n<s;n++)if(r==null||r[n])for(n=0;n<s;n++){const a=(.1-t[n])**2+(.06-e[n])**2;a&&(o[n]=1/a)}return[o]}var je;let ee=je=class extends O{constructor(){super(...arguments),this.method="custom"}clone(){return new je({method:this.method,bandIndexes:this.bandIndexes,raster:J(this.raster)})}};h([d({json:{type:String,write:!0}})],ee.prototype,"bandIndexes",void 0),h([nt(Xr)],ee.prototype,"method",void 0),ee=je=h([N("esri.layers.support.rasterFunctions.BandArithmeticFunctionArguments")],ee);const fo=ee,go=new Set(["vari","mtvi2","rtvi-core","evi"]);let Vt=class extends z{constructor(){super(...arguments),this.functionName="BandArithmetic",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0];if(t.bandCount<2)return{success:!1,supportsGPU:!1,error:"band-arithmetic-function: source raster has insufficient amount of raster bands"};const e=t.clone();return e.pixelType=this.outputPixelType,e.bandCount=this.functionArguments.method==="sultan"?3:1,this._removeStatsHistColormapVAT(e),e.keyProperties={...e.keyProperties,BandProperties:void 0},this.rasterInfo=e,{success:!0,supportsGPU:!["custom","gvitm","sultan"].includes(this.functionArguments.method)}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return e;const{method:s,bandIndexes:o}=this.functionArguments,n=o.split(" ").map(a=>parseFloat(a));return Yr(e,{method:s,bandIndexes:n,equation:o,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const t=this.functionArguments.bandIndexes.split(" ").map(i=>parseFloat(i)-1);t.length===2&&t.push(0);const e=this.isInputBandIdsSwizzled?[0,1,2]:t;let s,o;const n=new Float32Array(3),{method:a}=this.functionArguments;switch(a){case"gndvi":case"nbr":case"ndbi":case"ndvi":case"ndvi-re":case"ndsi":case"ndmi":case"mndwi":s=U([e[0],e[1],0]),o="ndxi";break;case"ndwi":s=U([e[1],e[0],0]),o="ndxi";break;case"sr":case"sr-re":case"iron-oxide":case"ferrous-minerals":case"clay-minerals":s=U([e[0],e[1],0]),o="sr";break;case"ci-g":case"ci-re":s=U([e[0],e[1],0]),o="ci";break;case"savi":s=U([e[0],e[1],0]),o="savi",n[0]=t[2]+1;break;case"tsavi":s=U([e[0],e[1],0]),o="tsavi",n[0]=t[2]+1,n[1]=t[3]+1,n[2]=t[4]+1;break;case"msavi":s=U([e[0],e[1],0]),o="msavi";break;case"gemi":s=U([e[0],e[1],0]),o="gemi";break;case"pvi":s=U([e[0],e[1],0]),o="tsavi",n[0]=t[2]+1,n[1]=t[3]+1;break;case"vari":s=U([e[0],e[1],e[2]]),o="vari";break;case"mtvi2":s=U([e[0],e[1],e[2]]),o="mtvi";break;case"rtvi-core":s=U([e[0],e[1],e[2]]),o="rtvicore";break;case"evi":s=U([e[0],e[1],e[2]]),o="evi";break;case"wndwi":s=U([e[0],e[1],0]),o="wndwi",n[0]=t[3]?t[3]+1:.5;break;case"bai":s=U([e[1],e[0],0]),o="bai";break;default:s=U([0,1,2]),o="custom"}return{bandIndexMat3:s,indexType:o,adjustments:n,isOutputRounded:W(this.outputPixelType)}}_getInputBandIds(t){if(this.functionArguments.method==="custom")return t;const e=this.functionArguments.bandIndexes.split(" ").map(i=>parseFloat(i)-1),s=t.length,o=e.map(i=>i>=s?s-1:i),n=go.has(this.functionArguments.method)?3:2,a=o.slice(0,n).map(i=>t[i]);return a.length===2&&a.push(0),a}_swizzleBandIds(t){const e=this.functionArguments.bandIndexes.split(" ").map(n=>parseFloat(n)-1);e.length===2&&e.push(0);const{method:s}=this.functionArguments,o=(["vari","mtvi2","rtvi-core","evi"].includes(s)?e.slice(0,3):s==="bai"||s==="ndwi"?[e[1],e[0]]:e.slice(0,2)).map(n=>t.indexOf(n));return o[2]??(o[2]=o[1]),this.isInputBandIdsSwizzled=!0,this.swizzledBandSelection=o,!1}};h([d({json:{write:!0,name:"rasterFunction"}})],Vt.prototype,"functionName",void 0),h([d({type:fo,json:{write:!0,name:"rasterFunctionArguments"}})],Vt.prototype,"functionArguments",void 0),h([d()],Vt.prototype,"rasterArgumentNames",void 0),Vt=h([N("esri.layers.support.rasterFunctions.BandArithmeticFunction")],Vt);const yo=Vt;var Ge;const Cs=new rt({1:"outside",2:"inside"},{useNumericKeys:!0});let se=Ge=class extends O{constructor(){super(...arguments),this.clippingType="outside"}clone(){return new Ge({clippingGeometry:this.clippingGeometry.clone(),clippingType:this.clippingType})}};h([d({types:vn,json:{read:An,write:!0}})],se.prototype,"clippingGeometry",void 0),h([d({json:{read:Cs.read,write:Cs.write}})],se.prototype,"clippingType",void 0),se=Ge=h([N("esri.layers.support.rasterFunctions.ClipFunctionArguments")],se);const xo=se;function wo(r,t){if(r.spatialReference.equals(t))return r;const e=jt(r.spatialReference),s=jt(t);if(e===s)return r;const o=e/s;return{x:r.x*o,y:r.y*o}}async function xa(r,t,e){if(e.type==="extent")return Po(r,t,e);const{width:s,height:o}=r,n=new Uint8Array(s*o);return(await de(()=>import("./intersectsOperator-bb4a8889.js"),["assets/intersectsOperator-bb4a8889.js","assets/ProjectionTransformation-a3dffea2.js","assets/Envelope2D-4833fda6.js","assets/Point2D-e62ad2de.js","assets/Transformation2D-ab2ac5ee.js","assets/SimpleGeometryCursor-e3941f41.js","assets/index-f00bd99f.js","assets/index-a5714ce2.css","assets/OperatorDefinitions-181ceaf8.js","assets/jsonConverter-77f04cbc.js","assets/intersectsOperator-a4ca2daa.js","assets/OperatorIntersects-e04f66fb.js","assets/apiConverter-8290ff52.js"])).execute(t,e)?e.type==="polyline"?To(r,t,e):(await de(()=>import("./containsOperator-337a3ac9.js"),["assets/containsOperator-337a3ac9.js","assets/ProjectionTransformation-a3dffea2.js","assets/Envelope2D-4833fda6.js","assets/Point2D-e62ad2de.js","assets/Transformation2D-ab2ac5ee.js","assets/SimpleGeometryCursor-e3941f41.js","assets/index-f00bd99f.js","assets/index-a5714ce2.css","assets/OperatorDefinitions-181ceaf8.js","assets/jsonConverter-77f04cbc.js","assets/containsOperator-d4bc73e1.js","assets/apiConverter-8290ff52.js"])).execute(e,t)?r:bo(r,t,e):new $({pixelType:r.pixelType,width:s,height:o,mask:n,maskIsAlpha:!1,pixels:[...r.pixels]})}function bo(r,t,e){if(!r)return r;const{width:s,height:o}=r,n=vo({geometry:e,size:[s,o],srcExtent:t,srcMask:r.mask});return new $({pixelType:r.pixelType,width:s,height:o,mask:n,maskIsAlpha:!1,pixels:[...r.pixels]})}function vo(r){const{geometry:t,size:e,srcExtent:s,srcMask:o}=r,[n,a]=e;let i;const u=s.width/n,l=s.height/a,{xmin:c,ymax:p}=s;if(t.type==="extent"){const m=(t.xmin-c)/u,f=(t.xmax-c)/u,g=(p-t.ymax)/l,x=(p-t.ymin)/l;i=[[[m,g],[m,x],[f,x],[f,g],[m,g]]]}else i=t.rings.map(m=>m.map(([f,g])=>[(f-c)/u,(p-g)/l]));return Ao(i,e,o)}function Ao(r,t,e){const[s,o]=t,n=new OffscreenCanvas(s,o).getContext("2d");n.fillStyle="#f00",n.beginPath(),r.forEach(c=>{n.moveTo(c[0][0],c[0][1]);for(let p=0;p<c.length;p++)n.lineTo(c[p][0],c[p][1]);n.closePath()}),n.fill();const a=n.getImageData(0,0,s,o).data,i=s*o,u=new Uint8Array(i);let l=!1;for(let c=0;c<i;c++)e&&!e[c]||(a[4*c+3]>127?u[c]=255:l=!0);return l||e?u:void 0}function Po(r,t,e){const{width:s,height:o}=r,n=new Uint8Array(s*o),a=t.width/s,i=t.height/o;if(e.width/a<.5||e.height/i<.5)return new $({pixelType:r.pixelType,width:s,height:o,mask:n,pixels:[...r.pixels]});const{xmin:u,xmax:l,ymin:c,ymax:p}=t,{xmin:m,xmax:f,ymin:g,ymax:x}=e,y=Math.max(u,m),v=Math.min(l,f),w=Math.max(c,g),A=Math.min(p,x),b=.5*a,P=.5*i;if(v-y<b||A-w<P||v<u+b||y>l-b||w>p-P||A<c+P)return new $({pixelType:r.pixelType,width:s,height:o,mask:n,pixels:[...r.pixels]});const T=Math.max(0,(y-u)/a),R=Math.min(s,Math.max(0,(v-u)/a)),F=Math.max(0,(p-A)/i),k=Math.min(o,Math.max(0,(p-w)/i)),I=Math.round(T),S=Math.round(R)-1,B=Math.round(F),X=Math.round(k)-1;if(I===S&&T%1>.5&&R%1<.5||B===X&&F%1>.5&&k%1<.5)return new $({pixelType:r.pixelType,width:s,height:o,mask:n,pixels:[...r.pixels]});if(I===0&&B===0&&S===s&&X===o)return r;const ue=r.mask;for(let Zt=B;Zt<=X;Zt++)for(let Et=I;Et<=S;Et++){const le=Zt*s+Et;n[le]=ue?ue[le]:255}return new $({pixelType:r.pixelType,width:s,height:o,mask:n,pixels:[...r.pixels]})}function To(r,t,e){const{width:s,height:o}=r,n=new Uint8Array(s*o),a=t.width/s,i=t.height/o,{xmin:u,ymax:l}=t,{paths:c}=e,p=r.mask;for(let m=0;m<c.length;m++){const f=c[m];for(let g=0;g<f.length-1;g++){const[x,y]=f[g],[v,w]=f[g+1];let A=Math.floor((l-y)/i),b=Math.floor((l-w)/i);if(b<A){const T=A;A=b,b=T}A=Math.max(0,A),b=Math.min(o-1,b);const P=(v-x)/(w-y);for(let T=A;T<=b;T++){const R=T===A?Math.max(y,w):(o+1-T)*i,F=T===b?Math.min(y,w):R-i;let k=Math.floor(w===y?(x-u)/a:(P*(R-y)+x-u)/a),I=Math.floor(w===y?(v-u)/a:(P*(F-y)+x-u)/a);if(I<k){const B=k;k=I,I=B}const S=T*s;k=Math.max(0,k),I=Math.min(s-1,I);for(let B=S+k;B<=S+I;B++)n[B]=p?p[B]:255}}}return new $({pixelType:r.pixelType,width:s,height:o,mask:n,pixels:[...r.pixels]})}function $o(r,t){const{extent:e}=Ro(r,t,new K({x:r.pixelSize.x,y:r.pixelSize.y,spatialReference:r.spatialReference})),{extent:s}=r.extent;if(e.xmax=Math.min(e.xmax,s.xmax),e.ymax=Math.min(e.ymax,s.ymax),e.xmin<e.xmax&&e.ymin<e.ymax){const{x:o,y:n}=r.pixelSize,a=Math.round(e.width/o),i=Math.round(e.height/n);r.extent=e,r.width=a,r.height=i}}function Ro(r,t,e,s=!0){const{spatialReference:o}=r,{x:n,y:a}=wo(e,o);let i,u,l;const c=t.type==="extent"?t:t.extent;let{xmin:p,xmax:m,ymax:f,ymin:g}=c;const{xmin:x,ymax:y}=r.extent;return s?(p=x+(p>x?n*Math.round((p-x)/n):0),f=y-(f<y?a*Math.round((y-f)/a):0),m=x+(m>x?n*Math.round((m-x)/n):0),g=y-(g<y?a*Math.round((y-g)/a):0),i=new Bt({xmin:p,ymax:f,xmax:m,ymin:g,spatialReference:o}),u=Math.round(i.width/n),l=Math.round(i.height/a)):(u=Math.floor((m-p)/n+.8),l=Math.floor((f-g)/a+.8),p=x+(p>x?n*Math.floor((p-x)/n+.1):0),f=y-(f<y?a*Math.floor((y-f)/a+.1):0),m=p+u*n,g=f-l*a,i=new Bt({xmin:p,ymax:f,xmax:m,ymin:g,spatialReference:o})),{extent:i,width:u,height:l}}var ze;function ae(){if(!hn)throw new Gt("rasterprojectionhelper-project","projection operator is not loaded")}(function(r){r[r.None=0]="None",r[r.North=1]="North",r[r.South=2]="South",r[r.Both=3]="Both"})(ze||(ze={}));const Bs=(r,t,e,s=0)=>{if(e[0]===1)return[0,0];let o=1,n=-1,a=1,i=-1;for(let y=0;y<r.length;y+=2)isNaN(r[y])||(o=o>r[y]?r[y]:o,n=n>r[y]?n:r[y],a=a>r[y+1]?r[y+1]:a,i=i>r[y+1]?i:r[y+1]);const{cols:u,rows:l}=t,c=(n-o)/u/e[0],p=(i-a)/l/e[1],m=2*s;let f=0,g=!1,x=[0,0];for(let y=0;y<u-3;y++){for(let v=0;v<l-3;v++){const w=y*l*2+2*v,A=(r[w]+r[w+4]+r[w+4*l]+r[w+4*l+4])/4,b=(r[w+1]+r[w+5]+r[w+4*l+1]+r[w+4*l+5])/4,P=Math.abs((A-r[w+2*l+2])/c),T=Math.abs((b-r[w+2*l+3])/p);if(P+T>f&&(f=P+T,x=[P,T]),m&&f>m){g=!0;break}}if(g)break}return x},No={3395:20037508342789244e-9,3410:17334193943686873e-9,3857:20037508342788905e-9,3975:17367530445161372e-9,4087:20037508342789244e-9,4088:20015108787169147e-9,6933:17367530445161372e-9,32662:20037508342789244e-9,53001:2001508679602057e-8,53002:1000754339801029e-8,53003:2001508679602057e-8,53004:2001508679602057e-8,53016:14152803599503474e-9,53017:17333573624304302e-9,53034:2001508679602057e-8,53079:20015114352186374e-9,53080:20015114352186374e-9,54001:20037508342789244e-9,54002:10018754171394624e-9,54003:20037508342789244e-9,54004:20037508342789244e-9,54016:14168658027268292e-9,54017:1736753044516137e-8,54034:20037508342789244e-9,54079:20037508342789244e-9,54080:20037508342789244e-9,54100:20037508342789244e-9,54101:20037508342789244e-9},xe=32,we=4,Ne=we,Fe=new Map,ke=new Map,be=500;let ce,st,Ie,hn=!1;async function wa(){return ce||(ce=Pn(),st=await de(()=>import("./projectOperator-dc8e69c1.js"),["assets/projectOperator-dc8e69c1.js","assets/index-f00bd99f.js","assets/index-a5714ce2.css","assets/SimpleGeometryCursor-e3941f41.js"]),Ie=await de(()=>import("./geographicTransformationUtils-f657d1f1.js"),["assets/geographicTransformationUtils-f657d1f1.js","assets/index-f00bd99f.js","assets/index-a5714ce2.css","assets/GeographicTransformation-7f05612b.js"]),st.isLoaded()||await st.load(),Ie.isLoaded()||await Ie.load(),hn=!0,ce.resolve()),ce.promise}function ba(r,t,e,s){const o=r.spatialReference;if(!o||!t||o.equals(t))return r;ae();const n=e.center,a=new Bt({xmin:n.x-r.x/2,xmax:n.x+r.x/2,ymin:n.y-r.y/2,ymax:n.y+r.y/2,spatialReference:o}),i=st.execute(a,t,{geographicTransformation:s}),u=ut(t);return i==null||u!=null&&i.width>=u?Fo(r,o,t):{x:i.width,y:i.height}}function Fo(r,t,e){const s=jt(t)/jt(e);return{x:r.x*s,y:r.y*s}}function H(r,t=.01){return jt(r)?t/jt(r):0}function js(r,t,e,s=!0){const o=r.spatialReference;if(o.equals(t))return r;ae();const n=st.execute(r,t,{geographicTransformation:e});return s&&n&&mn([r],[n],o,t),n}function mn(r,t,e,s){const o=ve(e,!0),n=ve(s,!0),a=H(e,be),i=H(s,be);if(a&&o!=null&&n!=null)for(let u=0;u<r.length;u++){const l=t[u];if(!l)continue;const{x:c}=r[u],{x:p}=l;p>=n[1]-i&&Math.abs(c-o[0])<a?l.x-=n[1]-n[0]:p<=n[0]+i&&Math.abs(c-o[1])<a&&(l.x+=n[1]-n[0])}}function ko(r){const{inSR:t,outSR:e,preferPE:s}=r;if(t.equals(e)){const{points:o}=hs(r,null);return o}return t.isWebMercator&&e.isWGS84||t.isWGS84&&e.isWebMercator?_o(r):s&&(t.isGeographic||zt(t)!=null)?Gs(r):Io(r)}function Io(r){const{points:t}=hs(r,null),{inSR:e,outSR:s,datumTransformation:o}=r,n=t.map(i=>new K(i[0],i[1],e)),a=st.executeMany(n,s,{geographicTransformation:o});return o&&mn(n,a,e,s),a.map(i=>i?[i.x,i.y]:[NaN,NaN])}function Gs(r){const{inSR:t,outSR:e,datumTransformation:s}=r,o=zt(t),{points:n,mask:a}=hs(r,o);if(!t.isGeographic){const u=t.wkid?et.coordsys(t.wkid):et.fromString(t.isGeographic?tt.PE_TYPE_GEOGCS:tt.PE_TYPE_PROJCS,t.wkt2||t.wkt);ys.projToGeog(u,n.length,n)}if(s!=null&&s.steps.length){let u;if(e.isGeographic&&(u=n.map(([c])=>c>179.9955?1:c<-179.9955?-1:0)),s.steps.forEach(c=>{const p=c.wkid?et.geogtran(c.wkid):et.fromString(tt.PE_TYPE_GEOGTRAN,c.wkt);Rn.geogToGeog(p,n.length,n,null,c.isInverse?tt.PE_TRANSFORM_2_TO_1:tt.PE_TRANSFORM_1_TO_2)}),u)for(let c=0;c<n.length;c++){const p=u[c],m=n[c][0],f=m>179.9955?1:m<-179.9955?-1:0;p&&f&&p!==f&&(n[c][0]=p>0?m+360:m-360)}}if(!e.isGeographic){const u=zt(e,!0),l=u!=null&&u.isEnvelope?[u.bbox[1],u.bbox[3]]:[-90,90];So(n,l);const c=e.wkid?et.coordsys(e.wkid):et.fromString(e.isGeographic?tt.PE_TYPE_GEOGCS:tt.PE_TYPE_PROJCS,e.wkt2||e.wkt);ys.geogToProj(c,n.length,n)}let i=n;if(a&&n.length!==a.length){i=[];for(let u=0,l=0;u<a.length;u++)a[u]?i.push(n[l++]):i.push([NaN,NaN])}return i}function _o(r){const{cols:t,rows:e,xres:s,yres:o,usePixelCenter:n,inSR:a,outSR:i}=r;let{xmin:u,ymax:l}=r;n&&(u+=s/2,l-=o/2);const c=[],p=[],m=Math.max(t,e);for(let g=0;g<m;g++){const x=u+s*Math.min(t,g),y=l-o*Math.min(e,g),v=Nn(new K({x,y,spatialReference:a}),a,i);g<=t&&c.push(v.x),g<=e&&p.push(v.y)}const f=[];for(let g=0;g<t;g++)for(let x=0;x<e;x++)f.push([c[g],p[x]]);return f}function zt(r,t=!1){let e=r.wkid||r.wkt2||r.wkt;if(!e||r.isGeographic)return null;if(e=String(e),Fe.has(e)){const a=Fe.get(e);return t?a?.gcs:a?.pcs}const s=r.wkid?et.coordsys(r.wkid):et.fromString(r.isGeographic?tt.PE_TYPE_GEOGCS:tt.PE_TYPE_PROJCS,r.wkt2||r.wkt),o=zs(s,H(r,1e-4)),n=zs(s,0,!0);return Fe.set(e,{pcs:o,gcs:n}),t?n:o}function zs(r,t=0,e=!1){const s=Fn.generate(r),o=e?r.horizonGcsGenerate():r.horizonPcsGenerate();if(!s||!o?.length)return null;let n=!1,a=o.find(y=>y.getInclusive()===1&&y.getKind()===1);if(!a){if(a=o.find(y=>y.getInclusive()===1&&y.getKind()===0),!a)return null;n=!0}const i=e?0:(s.getNorthPoleLocation()===2?1:0)|(s.getSouthPoleLocation()===2?2:0),u=s.isPannableRectangle(),l=a.getCoord();if(n)return{isEnvelope:n,isPannable:u,vertices:l,coef:null,bbox:[l[0][0]-t,l[0][1]-t,l[1][0]+t,l[1][1]+t],poleLocation:i};let c=0;const p=[];let[m,f]=l[0],[g,x]=l[0];for(let y=0,v=l.length;y<v;y++){c++,c===v&&(c=0);const[w,A]=l[y],[b,P]=l[c];if(P===A)p.push([w,b,A,P,2]);else{const T=(b-w)/(P-A||1e-4),R=w-T*A;A<P?p.push([T,R,A,P,0]):p.push([T,R,P,A,1])}m=m<w?m:w,f=f<A?f:A,g=g>w?g:w,x=x>A?x:A}return{isEnvelope:!1,isPannable:u,vertices:l,coef:p,bbox:[m,f,g,x],poleLocation:i}}function hs(r,t){const e=[],{cols:s,rows:o,xres:n,yres:a,usePixelCenter:i}=r;let{xmin:u,ymax:l}=r;if(i&&(u+=n/2,l-=a/2),t==null){for(let f=0;f<s;f++)for(let g=0;g<o;g++)e.push([u+n*f,l-a*g]);return{points:e}}const c=new Uint8Array(s*o);if(t.isEnvelope){const{bbox:[f,g,x,y]}=t;for(let v=0,w=0;v<s;v++){const A=u+n*v,b=t.isPannable||A>=f&&A<=x;for(let P=0;P<o;P++,w++){const T=l-a*P;b&&T>=g&&T<=y&&(e.push([A,T]),c[w]=1)}}return{points:e,mask:c}}const p=t.coef,m=[];for(let f=0;f<o;f++){const g=l-a*f,x=[],y=[];for(let w=0;w<p.length;w++){const[A,b,P,T,R]=p[w];if(g===P&&P===T)x.push(A),x.push(b),y.push(2),y.push(2);else if(g>=P&&g<=T){const F=A*g+b;x.push(F),y.push(R)}}let v=x;if(x.length>2){let w=y[0]===2?0:y[0],A=x[0];v=[];for(let b=1;b<y.length;b++)y[b]===2&&b!==y.length-1||(y[b]!==w&&(v.push(w===0?Math.min(A,x[b-1]):Math.max(A,x[b-1])),w=y[b],A=x[b]),b===y.length-1&&v.push(y[b]===0?Math.min(A,x[b]):Math.max(A,x[b])));v.sort((b,P)=>b-P)}else x[0]>x[1]&&(v=[x[1],x[0]]);m.push(v)}for(let f=0,g=0;f<s;f++){const x=u+n*f;for(let y=0;y<o;y++,g++){const v=l-a*y,w=m[y];if(w.length===2)x>=w[0]&&x<=w[1]&&(e.push([x,v]),c[g]=1);else if(w.length>2){let A=!1;for(let b=0;b<w.length;b+=2)if(x>=w[b]&&x<=w[b+1]){A=!0;break}A&&(e.push([x,v]),c[g]=1)}}}return{points:e,mask:c}}function So(r,t){const[e,s]=t;for(let o=0;o<r.length;o++){const n=r[o][1];(n<e||n>s)&&(r[o]=[NaN,NaN])}}function Mo(r,t){const e=ut(r[0].spatialReference);if(r.length<2||e==null||(t=t??H(r[0].spatialReference),(r=r.filter(i=>i.width>t)).length===1))return r[0];let{xmin:s,xmax:o,ymin:n,ymax:a}=r[0];for(let i=1;i<r.length;i++){const u=r[i];o=u.xmax+e*i,n=Math.min(n,u.ymin),a=Math.max(a,u.ymax)}return new Bt({xmin:s,xmax:o,ymin:n,ymax:a,spatialReference:r[0].spatialReference})}function fn(r,t,e=null,s=!0){const o=r.spatialReference;if(o.equals(t)||!t)return r;const n=jo(r),a=ut(o,!0),i=ut(t);if(n===0||a==null||i==null){const c=Es(r,t,e,s);if(c&&a==null&&i!=null&&Math.abs(c.width-i)<H(t)&&st.isLoaded()){const p=zt(o);if(p!=null&&p.poleLocation===ze.None&&r.width<(p.bbox[2]-p.bbox[0])/2)return Bo(r,t)||c}return c}const u=r.clone().normalize();if(u.length===1&&r.xmax<a&&r.xmax-a/2>H(o)){const{xmin:c,xmax:p}=r;for(let m=0;m<=n;m++){const f=m===0?c:-a/2,g=m===n?p-a*m:a/2;u[m]=new Bt({xmin:f,xmax:g,ymin:r.ymin,ymax:r.ymax,spatialReference:o})}}const l=u.map(c=>Es(c,t,e,s)).filter(Tn);return l.length===0?null:Mo(l)}function Co(r,t,e){if(r.type==="extent"){const{xmin:s,ymin:o,xmax:n,ymax:a,spatialReference:i}=r;r=new Ks({rings:[[[s,a],[n,a],[n,o],[s,o],[s,a]]],spatialReference:i})}return r.spatialReference.equals(t)?r:(ae(),st.execute(r,t,{geographicTransformation:e}))}function Bo(r,t){const e=ut(t);if(e==null)return null;let{xmin:s,ymin:o,xmax:n,ymax:a}=r;const i=r.spatialReference,u=new Ks({spatialReference:i,rings:[[[s,o],[n,o],[n,a],[s,a],[s,o]]]}),l=st.execute(u,t);if(l.rings.length!==2||!l.rings[0].length||!l.rings[1].length)return null;const{rings:c}=l,p=H(i),m=new Bt({spatialReference:t});for(let f=0;f<2;f++){s=n=c[f][0][0],o=a=c[f][0][1];for(let g=0;g<c[f].length;g++)s=s>c[f][g][0]?c[f][g][0]:s,n=n<c[f][g][0]?c[f][g][0]:n,o=o>c[f][g][1]?c[f][g][1]:o,a=a<c[f][g][1]?c[f][g][1]:a;if(f===0)m.ymin=o,m.ymax=a,m.xmin=s,m.xmax=n;else if(m.ymin=Math.min(m.ymin,o),m.ymax=Math.max(m.ymax,a),Math.abs(n-e/2)<p)m.xmin=s,m.xmax=m.xmax+e;else{if(!(Math.abs(s+e/2)<p))return null;m.xmax=n+e}}return m}function Es(r,t,e,s=!0,o=!0){const n=r.spatialReference;if(n.equals(t)||!t)return r;ae();const a=st.execute(r,t,{geographicTransformation:e});if(o&&t.isWebMercator&&a&&(a.ymax=Math.min(20037508342787e-6,a.ymax),a.ymin=Math.max(-20037508342787e-6,a.ymin),a.ymin>=a.ymax))return null;if(!s||!a)return a;const i=ve(n,!0),u=ve(t,!0);if(i==null||u==null)return a;const l=H(n,.001),c=H(n,be),p=H(t,.001);if(Math.abs(a.xmin-u[0])<p&&Math.abs(a.xmax-u[1])<p){const m=Math.abs(r.xmin-i[0]),f=Math.abs(i[1]-r.xmax);if(m<l&&f>c){a.xmin=u[0];const g=[];g.push(new K(r.xmax,r.ymin,n)),g.push(new K(r.xmax,(r.ymin+r.ymax)/2,n)),g.push(new K(r.xmax,r.ymax,n));const x=g.map(y=>js(y,t,e)).filter(y=>!isNaN(y?.x)).map(y=>y.x);a.xmax=Math.max.apply(null,x)}if(f<l&&m>c){a.xmax=u[1];const g=[];g.push(new K(r.xmin,r.ymin,n)),g.push(new K(r.xmin,(r.ymin+r.ymax)/2,n)),g.push(new K(r.xmin,r.ymax,n));const x=g.map(y=>js(y,t,e)).filter(y=>!isNaN(y?.x)).map(y=>y.x);a.xmin=Math.min.apply(null,x)}}else{const m=H(t,.001);Math.abs(a.xmin-u[0])<m&&(a.xmin=u[0]),Math.abs(a.xmax-u[1])<m&&(a.xmax=u[1])}return a}function ut(r,t=!1){if(!r)return null;const e=t?20037508342787e-6:20037508342788905e-9;return r.isWebMercator?2*e:r.wkid&&r.isGeographic?360:2*No[r.wkid]||null}function ve(r,t=!1){if(r.isGeographic)return[-180,180];const e=ut(r,t);return e!=null?[-e/2,e/2]:null}function Os(r,t,e,s){let o=(r-t)/e;return o-Math.floor(o)!==0?o=Math.floor(o):s&&(o-=1),o}function jo(r,t=!1){const e=ut(r.spatialReference);if(e==null)return 0;const s=t?0:-(e/2),o=H(r.spatialReference),n=!t&&Math.abs(r.xmax-e/2)<o?e/2:r.xmax,a=!t&&Math.abs(r.xmin+e/2)<o?-e/2:r.xmin;return Os(n,s,e,!0)-Os(a,s,e,!1)}function va(r){const t=r.storageInfo.origin.x,e=ut(r.spatialReference,!0);if(e==null)return{originX:t,halfWorldWidth:null,pyramidsInfo:null};const s=e/2,{nativePixelSize:o,storageInfo:n,extent:a}=r,{maximumPyramidLevel:i,blockWidth:u,pyramidScalingFactor:l}=n;let c=o.x;const p=[],m=r.transform!=null&&r.transform.type==="gcs-shift",f=t+(m?0:s),g=m?e-t:s-t;for(let x=0;x<=i;x++){const y=(a.xmax-t)/c/u,v=y-Math.floor(y)===0?y:Math.ceil(y),w=g/c/u,A=w-Math.floor(w)===0?w:Math.ceil(w),b=Math.floor(f/c/u),P=Math.round(f/c)%u,T=(u-Math.round(g/c)%u)%u;p.push({resolutionX:c,blockWidth:u,datasetColumnCount:v,worldColumnCountFromOrigin:A,leftMargin:P,rightPadding:T,originColumnOffset:b}),c*=l}return{originX:t,halfWorldWidth:s,pyramidsInfo:p,hasGCSSShiftTransform:m}}function Go(r){if(!r||r.isGeographic)return r;const t=String(r.wkid||r.wkt2||r.wkt);let e;return ke.has(t)?e=ke.get(t):(e=(r.wkid?et.coordsys(r.wkid):et.fromString(tt.PE_TYPE_PROJCS,r.wkt2||r.wkt)).getGeogcs().getCode(),ke.set(t,e)),new kn({wkid:e})}function Aa(r){const t=r.isAdaptive&&r.spacing==null;let e=r.spacing||[xe,xe],s=_e(r),o={cols:s.size[0]+1,rows:s.size[1]+1};const n=s.outofBoundPointCount>0&&s.outofBoundPointCount<s.offsets.length/2;let a=s.outofBoundPointCount===s.offsets.length/2||t&&n?[0,0]:Bs(s.offsets,o,e,Ne);const i=(a[0]+a[1])/2,u=r.projectedExtent.spatialReference,l=r.srcBufferExtent.spatialReference;if(t&&(n||i>Ne)&&(u.isGeographic||zt(u),e=[we,we],s=_e({...r,spacing:e}),o={cols:s.size[0]+1,rows:s.size[1]+1},a=Bs(s.offsets,o,e,Ne)),s.error=a,e[0]>1&&(s.coefficients=Ds(s.offsets,o,n)),r.includeGCSGrid&&!u.isGeographic&&!u.isWebMercator)if(l.isGeographic)s.gcsGrid={offsets:s.offsets,coefficients:s.coefficients,spacing:e};else{const c=zt(u);if(c!=null&&!c.isEnvelope){const p=Go(u),m=fn(r.projectedExtent,p),{offsets:f}=_e({...r,srcBufferExtent:m,spacing:e}),g=Ds(f,o,n);s.gcsGrid={offsets:f,coefficients:g,spacing:e}}}return s}function _e(r){const{projectedExtent:t,srcBufferExtent:e,pixelSize:s,datumTransformation:o,rasterTransform:n}=r,a=t.spatialReference,i=e.spatialReference;ae();const{xmin:u,ymin:l,xmax:c,ymax:p}=t,m=ut(i),f=m!=null&&(r.hasWrapAround||n?.type==="gcs-shift"),g=r.spacing||[xe,xe],x=g[0]*s.x,y=g[1]*s.y,v=g[0]===1,w=Math.ceil((c-u)/x-.1/g[0])+(v?0:1),A=Math.ceil((p-l)/y-.1/g[1])+(v?0:1),b=ko({cols:w,rows:A,xmin:u,ymax:p,xres:x,yres:y,inSR:a,outSR:i,datumTransformation:o,preferPE:g[0]<=we,usePixelCenter:v}),P=[];let T,R=0;const F=v?-1:NaN,{xmin:k,xmax:I,ymax:S,width:B,height:X}=e,ue=H(i,be),Zt=m!=null&&k>0&&I>m/2,Et=zt(a),le=Et!=null&&Et.poleLocation>0;for(let Qt=0;Qt<w;Qt++){const Pe=[];for(let te=0;te<A;te++){let V=b[Qt*A+te];if(f&&V[0]>I&&V[0]>m/2-ue?V[0]-=m:f&&Qt===0&&V[0]<0&&Zt&&!n&&(V[0]+=m),!V||isNaN(V[0])||isNaN(V[1]))P.push(F),P.push(F),Pe.push(null),R++;else{if(n){const ds=n.inverseTransform(new K({x:V[0],y:V[1],spatialReference:i}));V=[ds.x,ds.y]}Pe.push(V),Qt>0&&f&&T[te]&&V[0]<T[te][0]&&(V[0]+=m,le&&V[0]>I&&V[0]>m&&(V[0]-=m)),P.push((V[0]-k)/B),P.push((S-V[1])/X)}}T=Pe}return{offsets:P,error:null,coefficients:null,outofBoundPointCount:R,spacing:g,size:v?[w,A]:[w-1,A-1]}}function Ds(r,t,e){const{cols:s,rows:o}=t,n=new Float32Array((s-1)*(o-1)*2*6),a=new Float32Array([-0,-1,1,-1,1,-0,1,-0,-0]),i=new Float32Array([-1,1,0,0,-1,1,1,0,0]);for(let u=0;u<s-1;u++){for(let l=0;l<o-1;l++){let c=u*o*2+2*l;const p=r[c],m=r[c+1],f=r[c+2],g=r[c+3];c+=2*o;const x=r[c],y=r[c+1],v=r[c+2],w=r[c+3];let A=0,b=12*(l*(s-1)+u);for(let P=0;P<3;P++)n[b++]=a[A++]*p+a[A++]*f+a[A++]*v;A=0;for(let P=0;P<3;P++)n[b++]=a[A++]*m+a[A++]*g+a[A++]*w;A=0;for(let P=0;P<3;P++)n[b++]=i[A++]*p+i[A++]*x+i[A++]*v;A=0;for(let P=0;P<3;P++)n[b++]=i[A++]*m+i[A++]*y+i[A++]*w}if(e)for(let l=0;l<n.length;l++)isNaN(n[l])&&(n[l]=-1)}return n}function Pa(r){const{spatialReference:t}=r,e=$n(t);if(!e)return r;const[s,o]=e.valid,n=o-s;let a=0;if(r.xmin<s){const i=s-r.xmin;a=Math.ceil(i/n)}else if(r.xmin>o){const i=r.xmin-o;a=-Math.ceil(i/n)}return new Bt({spatialReference:r.spatialReference,xmin:r.xmin+a*n,ymin:r.ymin,xmax:r.xmax+a*n,ymax:r.ymax})}function Ta(r,t,e){const{storageInfo:s,pixelSize:o}=t;let n=0,a=!1;const{pyramidResolutions:i}=s,u=s.tileInfo.format?.toLowerCase()==="mixed"?Math.max(1,Math.min(3,s.tileInfo.dpi/96)):1,l=(r.x+r.y)/2/u;if(i!=null&&i.length){const g=i[i.length-1],x=(g.x+g.y)/2,y=(o.x+o.y)/2;if(l<=y)n=0;else if(l>=x)n=i.length,a=l/x>8;else{let w,A=y;for(let b=1;b<=i.length;b++){if(w=(i[b-1].x+i[b-1].y)/2,l<=w){l===w?n=b:e==="down"?(n=b-1,a=l/A>8):n=e==="up"||l-A>w-l||l/A>2?b:b-1;break}A=w}}const v=n===0?o:i[n-1];return a&&Math.min(v.x,v.y)*jt(t.spatialReference)>19567&&(a=!1),{pyramidLevel:n,pyramidResolution:new K({x:v.x,y:v.y,spatialReference:t.spatialReference}),excessiveReading:a}}const c=Math.log(r.x/o.x)/Math.LN2,p=Math.log(r.y/o.y)/Math.LN2,m=t.storageInfo.maximumPyramidLevel||0;n=e==="down"?Math.floor(Math.min(c,p)):e==="up"?Math.ceil(Math.max(c,p)):Math.round((c+p)/2),n<0?n=0:n>m&&(a=n>m+3,n=m);const f=2**n;return{pyramidLevel:n,pyramidResolution:new K({x:f*t.nativePixelSize.x,y:f*t.nativePixelSize.y,spatialReference:t.spatialReference}),excessiveReading:a}}let gt=class extends z{constructor(){super(...arguments),this.functionName="Clip",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone();this.outputPixelType=this._getOutputPixelType(t.pixelType),t.pixelType=this.outputPixelType,this.rasterInfo=t;const{functionArguments:e}=this,{clippingGeometry:s,clippingType:o}=e;if(!s)return{success:!1,supportsGPU:!1,error:"missing clipping geometry"};if(o==="outside")try{const{spatialReference:n}=t,a=s.type==="extent"?fn(s,n):Co(s,n).extent;a&&$o(t,a)}catch{}return{success:!0,supportsGPU:!0}}_processPixels(t){return t.pixelBlocks?.[0]}_getWebGLParameters(){const{clippingGeometry:t,clippingType:e}=this.functionArguments;return{clippingGeometry:t.toJSON(),clippingType:e}}};h([d({json:{write:!0,name:"rasterFunction"}})],gt.prototype,"functionName",void 0),h([d({type:xo,json:{write:!0,name:"rasterFunctionArguments"}})],gt.prototype,"functionArguments",void 0),h([d()],gt.prototype,"rasterArgumentNames",void 0),h([d()],gt.prototype,"isNoopProcess",void 0),gt=h([N("esri.layers.support.rasterFunctions.ClipFunction")],gt);const zo=gt;var Ee;let Q=Ee=class extends O{castColormapName(r){if(!r)return null;const t=r.toLowerCase();return Bn.includes(t)?t:null}readColorRamp(r){return Xs(r)}readColorRampName(r,t){if(!r)return null;const e=Ct.jsonValues.find(s=>s.toLowerCase()===r.toLowerCase());return e?Ct.fromJSON(e):null}clone(){return new Ee({colormap:J(this.colormap),colormapName:this.colormapName,colorRamp:this.colorRamp?.clone(),colorRampName:this.colorRampName})}};h([d({type:[[Number]],json:{write:!0}})],Q.prototype,"colormap",void 0),h([d({type:String,json:{write:!0}})],Q.prototype,"colormapName",void 0),h([Js("colormapName")],Q.prototype,"castColormapName",null),h([d({types:In,json:{write:!0}})],Q.prototype,"colorRamp",void 0),h([oe("colorRamp")],Q.prototype,"readColorRamp",null),h([d({type:Ct.apiValues,json:{type:Ct.jsonValues,write:Ct.write}})],Q.prototype,"colorRampName",void 0),h([oe("colorRampName")],Q.prototype,"readColorRampName",null),Q=Ee=h([N("esri.layers.support.rasterFunctions.ColormapFunctionArguments")],Q);const Eo=Q,Oo=[[36,0,255],[36,0,255],[36,0,255],[36,0,255],[112,75,3],[113,76,3],[114,77,3],[115,77,3],[116,78,3],[117,79,3],[118,79,3],[119,80,3],[121,81,4],[122,82,4],[123,82,4],[124,83,4],[125,84,4],[126,84,4],[127,85,4],[128,86,4],[129,86,4],[130,87,4],[131,88,4],[132,89,4],[133,89,4],[134,90,4],[135,91,4],[136,91,4],[137,92,4],[138,93,4],[139,94,4],[140,94,4],[142,95,5],[143,96,5],[144,96,5],[145,97,5],[146,98,5],[147,99,5],[148,99,5],[149,100,5],[150,101,5],[151,101,5],[152,102,5],[153,103,5],[154,104,5],[155,104,5],[156,105,5],[157,106,5],[158,106,5],[159,107,5],[160,108,5],[161,108,5],[162,109,5],[164,110,6],[165,111,6],[166,111,6],[167,112,6],[168,113,6],[169,113,6],[170,114,6],[171,115,6],[172,116,6],[173,116,6],[174,117,6],[245,0,0],[245,5,0],[245,10,0],[246,15,0],[246,20,0],[246,25,0],[246,30,0],[247,35,0],[247,40,0],[247,45,0],[247,50,0],[247,55,0],[248,60,0],[248,65,0],[248,70,0],[248,75,0],[249,81,0],[249,86,0],[249,91,0],[249,96,0],[250,101,0],[250,106,0],[250,111,0],[250,116,0],[250,121,0],[251,126,0],[251,131,0],[251,136,0],[251,141,0],[252,146,0],[252,151,0],[252,156,0],[252,156,0],[251,159,0],[250,162,0],[249,165,0],[248,168,0],[247,171,0],[246,174,0],[245,177,0],[245,179,0],[244,182,0],[243,185,0],[242,188,0],[241,191,0],[240,194,0],[239,197,0],[238,200,0],[237,203,0],[236,206,0],[235,209,0],[234,212,0],[233,215,0],[232,218,0],[231,221,0],[230,224,0],[230,226,0],[229,229,0],[228,232,0],[227,235,0],[226,238,0],[225,241,0],[224,244,0],[223,247,0],[165,247,0],[163,244,0],[161,240,0],[158,237,0],[156,233,1],[154,230,1],[152,227,1],[149,223,1],[147,220,1],[145,216,1],[143,213,1],[140,210,2],[138,206,2],[136,203,2],[134,200,2],[132,196,2],[129,193,2],[127,189,2],[125,186,3],[123,183,3],[120,179,3],[118,176,3],[116,172,3],[114,169,3],[111,166,3],[109,162,4],[107,159,4],[105,155,4],[103,152,4],[100,149,4],[98,145,4],[96,142,4],[94,138,5],[91,135,5],[89,132,5],[87,128,5],[85,125,5],[82,121,5],[80,118,5],[78,115,6],[76,111,6],[73,108,6],[71,105,6],[69,101,6],[67,98,6],[65,94,6],[62,91,7],[60,88,7],[58,84,7],[56,81,7],[53,77,7],[51,74,7],[49,71,7],[47,67,8],[44,64,8],[42,60,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8]],Do=[[36,0,255],[36,0,255],[36,0,255],[36,0,255],[245,20,0],[245,24,0],[245,29,0],[245,31,0],[247,33,0],[247,33,0],[247,37,0],[247,41,0],[247,41,0],[247,41,0],[247,45,0],[247,45,0],[247,47,0],[247,49,0],[247,49,0],[247,54,0],[247,54,0],[247,56,0],[247,58,0],[247,58,0],[250,62,0],[250,62,0],[250,62,0],[250,67,0],[250,67,0],[250,67,0],[250,69,0],[250,71,0],[250,71,0],[250,75,0],[250,75,0],[250,78,0],[250,79,0],[250,79,0],[250,79,0],[250,81,0],[250,83,0],[250,83,0],[250,87,0],[250,87,0],[250,90,0],[250,92,0],[252,93,0],[252,93,0],[252,97,0],[252,97,0],[252,97,0],[252,97,0],[252,101,0],[252,101,0],[252,101,0],[252,101,0],[252,105,0],[252,105,0],[252,107,0],[252,109,0],[252,109,0],[252,113,13],[255,118,20],[255,119,23],[255,121,25],[255,126,33],[255,132,38],[255,133,40],[255,135,43],[255,141,48],[255,144,54],[255,150,59],[255,152,61],[255,153,64],[255,159,69],[255,163,77],[255,165,79],[255,168,82],[255,174,87],[255,176,92],[255,181,97],[255,183,99],[255,186,102],[255,191,107],[255,197,115],[255,201,120],[255,203,123],[255,205,125],[255,209,130],[255,214,138],[255,216,141],[255,218,143],[255,224,150],[255,228,156],[255,234,163],[255,236,165],[255,238,168],[255,243,173],[255,248,181],[255,252,186],[253,252,186],[250,252,187],[244,250,180],[238,247,176],[234,246,173],[231,245,169],[223,240,163],[217,237,157],[211,235,150],[205,233,146],[200,230,142],[195,227,136],[189,224,132],[184,222,126],[180,220,123],[174,217,119],[169,214,114],[163,212,108],[160,210,105],[154,207,101],[148,204,96],[143,201,93],[138,199,88],[134,197,84],[130,194,81],[126,191,77],[117,189,70],[115,186,68],[112,184,64],[106,181,60],[100,179,55],[94,176,49],[92,174,47],[90,173,45],[81,168,37],[75,166,33],[71,163,28],[66,160,24],[62,158,21],[56,156,14],[51,153,0],[51,153,0],[51,153,0],[50,150,0],[50,150,0],[50,150,0],[50,150,0],[49,148,0],[49,148,0],[49,148,0],[48,145,0],[48,145,0],[48,145,0],[48,145,0],[48,143,0],[48,143,0],[48,143,0],[48,143,0],[47,140,0],[47,140,0],[47,140,0],[47,140,0],[46,138,0],[46,138,0],[46,138,0],[46,138,0],[45,135,0],[45,135,0],[45,135,0],[45,135,0],[44,133,0],[44,133,0],[44,133,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[42,128,0],[42,128,0],[42,128,0],[42,125,0],[42,125,0],[42,125,0],[42,125,0],[41,122,0],[41,122,0],[41,122,0],[41,122,0],[40,120,0],[40,120,0],[40,120,0],[40,120,0],[40,120,0],[39,117,0],[39,117,0],[39,117,0],[39,117,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0]];function ms(r,t){const e=[],s=[];for(let n=0;n<r.length-1;n++)e.push({type:"algorithmic",algorithm:"esriHSVAlgorithm",fromColor:r[n].slice(1),toColor:r[n+1].slice(1)}),s.push(r[n+1][0]-r[n][0]);const o=r[r.length-1][0];return Zs({type:"multipart",colorRamps:e},{numColors:o,weights:t=t??s})}function Vo(){return ms([[0,0,191,191],[51,0,0,255],[102,255,0,255],[153,255,0,127],[204,191,63,127],[256,20,20,20]])}function Uo(){const r=ms([[0,255,255,255],[70,0,255,0],[80,205,173,193],[100,150,150,150],[110,120,51,100],[130,120,100,200],[140,28,3,144],[160,6,0,55],[180,10,25,30],[201,6,7,27]]);for(let t=r.length;t<256;t++)r.push([6,27,7]);return r}function Lo(){return Zs({type:"algorithmic",algorithm:"esriHSVAlgorithm",fromColor:[0,0,0],toColor:[255,255,255]})}function Wo(){const r=[];for(let t=0;t<256;t++){const e=[];for(let s=0;s<3;s++)e.push(Math.round(255*Math.random()));r.push(e)}return r}function qo(){return ms([[0,38,41,54],[69,79,82,90],[131,156,156,156],[256,253,253,241]],[.268,.238,.495])}function Ho(r){let t;switch(r){case"elevation":t=Vo();break;case"gray":t=Lo();break;case"hillshade":t=qo();break;case"ndvi":t=Oo;break;case"ndvi2":t=Uo();break;case"ndvi3":t=Do;break;case"random":t=Wo()}return t?(t=t.map((e,s)=>[s,...e]),t):null}let ot=class extends z{constructor(){super(...arguments),this.functionName="Colormap",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const t=this.sourceRasterInfos[0];if(t.bandCount>1)return{success:!1,supportsGPU:!1,error:"colormap-function: source data must be single band"};let{colormap:e,colormapName:s,colorRamp:o,colorRampName:n}=this.functionArguments;if(!e?.length)if(o)this.colorRamp=o,e=Se(o,{interpolateAlpha:!0});else if(n){const u=Qs(n);u&&(e=Se(u),this.colorRamp=Xs(u))}else s&&(e=Ho(s));if(!e?.length)return{success:!1,supportsGPU:!1,error:"colormap-function: missing colormap argument"};const a=this._getOutputPixelType(t.pixelType);this.outputPixelType=a.startsWith("f")?"s32":a;const i=t.clone();return i.pixelType=this.outputPixelType,i.colormap=e,i.bandCount=1,this.rasterInfo=i,{success:!0,supportsGPU:!0}}_processPixels(t){let e=t.pixelBlocks?.[0];return!e||W(e.pixelType)||(e=e.clone(),e.clamp(this.outputPixelType)),e}};h([d({json:{write:!0,name:"rasterFunction"}})],ot.prototype,"functionName",void 0),h([d({type:Eo,json:{write:!0,name:"rasterFunctionArguments"}})],ot.prototype,"functionArguments",void 0),h([d()],ot.prototype,"rasterArgumentNames",void 0),h([d()],ot.prototype,"isNoopProcess",void 0),h([d({json:{write:!0}})],ot.prototype,"indexedColormap",void 0),h([d()],ot.prototype,"colorRamp",void 0),ot=h([N("esri.layers.support.rasterFunctions.ColormapFunction")],ot);const Jo=ot;var Oe;let De=Oe=class extends O{clone(){return new Oe({raster:this.raster})}};De=Oe=h([N("esri.layers.support.rasterFunctions.ColormapToRGBFunctionArguments")],De);const Ko=De;let yt=class extends z{constructor(){super(...arguments),this.functionName="ColormapToRGB",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const t=this.sourceRasterInfos[0];if(t.bandCount>1||!t.colormap?.length)return{success:!1,supportsGPU:!1,error:"colormap-to-rgb-function: source data must be single band with a colormap"};const e=t.clone();e.pixelType=this.outputPixelType=this._getOutputPixelType("u8"),this._removeStatsHistColormapVAT(e),e.bandCount=3,e.statistics=[{min:0,max:255,avg:100,stddev:20},{min:0,max:255,avg:100,stddev:20},{min:0,max:255,avg:100,stddev:20}],this.rasterInfo=e;const s=[...t.colormap].sort((a,i)=>a[0]-i[0]),{indexedColormap:o,offset:n}=tn({colormap:s});return o?(this.lookup={indexedColormap:o,offset:n},{success:!0,supportsGPU:en(o)}):{success:!1,supportsGPU:!1,error:"colormap-to-rgb-function: the colormap is not supported"}}_processPixels(t){let e=t.pixelBlocks?.[0];if(!e||!this.lookup)return e;e=e.clone();const s=e.pixels[0],o=e.mask??new Uint8Array(s.length).fill(255),n=new Uint8Array(s.length),a=new Uint8Array(s.length),i=new Uint8Array(s.length),{indexedColormap:u,offset:l}=this.lookup,c=u.length;for(let p=0;p<s.length;p++)if(o[p]){let m=4*(s[p]-l);m<0||m>c-4?o[p]=0:(n[p]=u[m++],a[p]=u[m++],i[p]=u[m++])}return e.pixels=[n,a,i],e.statistics=[new Te(0,255),new Te(0,255),new Te(0,255)],e.pixelType=this.outputPixelType,e}_getWebGLParameters(){return this.lookup}};h([d({json:{write:!0,name:"rasterFunction"}})],yt.prototype,"functionName",void 0),h([d({type:Ko,json:{write:!0,name:"rasterFunctionArguments"}})],yt.prototype,"functionArguments",void 0),h([d()],yt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],yt.prototype,"lookup",void 0),yt=h([N("esri.layers.support.rasterFunctions.ColormapToRGBFunction")],yt);const Xo=yt;var Ve;let ne=Ve=class extends O{constructor(){super(...arguments),this.rasters=[]}writeRasters(r,t){t.rasters=r.map(e=>typeof e=="number"||typeof e=="string"?e:e.toJSON())}clone(){return new Ve({rasters:J(this.rasters)})}};h([d({json:{write:!0}})],ne.prototype,"rasters",void 0),h([Ae("rasters")],ne.prototype,"writeRasters",null),ne=Ve=h([N("esri.layers.support.rasterFunctions.CompositeBandFunctionArguments")],ne);const Yo=ne;let Ut=class extends z{constructor(){super(...arguments),this.functionName="CompositeBand",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,e=t[0];this.outputPixelType=this._getOutputPixelType(e.pixelType);const s=e.clone();if(s.attributeTable=null,s.colormap=null,s.pixelType=this.outputPixelType,s.bandCount=t.map(({bandCount:n})=>n).reduce((n,a)=>n+a),t.every(({statistics:n})=>n!=null&&n.length)){const n=[];t.forEach(({statistics:a})=>a!=null&&n.push(...a)),s.statistics=n}if(t.every(({histograms:n})=>n!=null&&n.length)){const n=[];t.forEach(({histograms:a})=>a!=null&&n.push(...a)),s.histograms=n}s.multidimensionalInfo&&s.multidimensionalInfo.variables.forEach(n=>{const a=t.map(l=>l.multidimensionalInfo?.variables.find(({name:c})=>c===n.name)),i=a.map(l=>l?.statistics?.length?l.statistics:null),u=a.map(l=>l?.histograms?.length?l.histograms:null);n.statistics=i.every(l=>l!=null)?i.flat():null,n.histograms=u.every(l=>l!=null)?u.flat():null}),s.bandCount>1&&(s.colormap=null,s.attributeTable=null);const o=t.every(n=>n.keyProperties.BandProperties?.length)?t.flatMap(n=>n.keyProperties.BandProperties):void 0;return s.keyProperties={...s.keyProperties,BandProperties:o},this.rasterInfo=s,{success:!0,supportsGPU:s.bandCount<=3}}_processPixels(t){const{pixelBlocks:e}=t;return e?e?.[0]==null?null:jn(e):null}_getWebGLParameters(){return{bandCount:this.rasterInfo.bandCount}}};h([d({json:{write:!0,name:"rasterFunction"}})],Ut.prototype,"functionName",void 0),h([d({type:Yo,json:{write:!0,name:"rasterFunctionArguments"}})],Ut.prototype,"functionArguments",void 0),h([d()],Ut.prototype,"rasterArgumentNames",void 0),Ut=h([N("esri.layers.support.rasterFunctions.CompositeBandFunction")],Ut);const Zo=Ut,Qo=new rt({0:"difference",1:"relative-difference",2:"categorical",3:"euclidean-distance",4:"angle-difference",5:"band-with-most-change"},{useNumericKeys:!0}),ti=new rt({0:"all",1:"changed",2:"unchanged"},{useNumericKeys:!0});function ei(r,t,e,s){const[o,n]=r,a=W(e)&&!W(o.pixelType)&&!W(n.pixelType),i=[o.mask,n.mask].filter(g=>g),u=$.combineBandMasks(i),l=r.map(g=>g.pixels[0]),{width:c,height:p}=o,m=$.createEmptyBand(e,c*p);switch(t){case"difference":case"relative-difference":si({bands:l,mask:u,outBand:m,isRoundingNeeded:a,isRelative:t==="relative-difference"});break;case"categorical":ni({bands:l,mask:u,outBand:m,...s});break;case"euclidean-distance":ri({pixels:r.map(g=>g.pixels),mask:u,outBand:m});break;case"angle-difference":oi({pixels:r.map(g=>g.pixels),mask:u,outBand:m});break;case"band-with-most-change":ii({pixels:r.map(g=>g.pixels),mask:u,outBand:m})}const f=new $({width:c,height:p,pixels:[m],pixelType:e,mask:u});return f.updateStatistics(),f}function si(r){const{bands:[t,e],mask:s,isRelative:o,isRoundingNeeded:n,outBand:a}=r,i=t.length;for(let u=0;u<i;u++)if(!s||s[u]){let l=t[u]-e[u];if(o){const c=Math.max(Math.abs(t[u])-Math.abs(e[u]));l=c>0?l/c:0}a[u]=n?Math.round(l):l}}function ni(r){const{bands:[t,e],categoryIndexLookups:[s,o],classNames:[n,a],mask:i,keepMethod:u,outBand:l}=r,c=t.length,p=n.length,m=a.length,f=p*m,g=f+1,x=f+2;for(let y=0;y<c;y++)if(!i||i[y]){const v=t[y],w=e[y],A=s[v],b=o[w],P=n[A],T=a[b];l[y]=A==null||b==null?f:u==="changed"&&P===T?g:u==="unchanged"&&P!==T?x:A*m+b}}function ri(r){const{pixels:[t,e],mask:s,outBand:o}=r,n=t[0].length,a=t.length;for(let i=0;i<n;i++)if(!s||s[i]){let u=0;for(let l=0;l<a;l++){const c=t[l][i]-e[l][i];u+=c*c}o[i]=Math.sqrt(u)}}function oi(r){const{pixels:[t,e],mask:s,outBand:o}=r,n=t[0].length,a=t.length;for(let i=0;i<n;i++)if(!s||s[i]){let u=0,l=0,c=0;for(let m=0;m<a;m++){const f=t[m][i],g=e[m][i];u+=f*g,l+=f*f,c+=g*g}const p=Math.sqrt(l*c);o[i]=p?Math.acos(u/p):1.5707963267948966}}function ii(r){const{pixels:[t,e],mask:s,outBand:o}=r,n=t[0].length,a=t.length;for(let i=0;i<n;i++)if(!s||s[i]){let u=0,l=0;for(let c=0;c<a;c++){const p=Math.abs(t[c][i]-e[c][i]);p>u&&(u=p,l=c)}o[i]=l}}var Ue;let xt=Ue=class extends O{constructor(){super(...arguments),this.method="difference",this.keepMethod="all",this.raster2=void 0}get rasters(){return[this.raster,this.raster2]}clone(){return new Ue({raster:this.raster,raster2:this.raster2,method:this.method,keepMethod:this.keepMethod})}};h([nt(Qo)],xt.prototype,"method",void 0),h([nt(ti)],xt.prototype,"keepMethod",void 0),h([d({json:{write:!0}})],xt.prototype,"raster2",void 0),h([d({readOnly:!0})],xt.prototype,"rasters",null),xt=Ue=h([N("esri.layers.support.rasterFunctions.ComputeChangeFunctionArguments")],xt);const ai=xt;let wt=class extends z{constructor(){super(...arguments),this.functionName="ComputeChange",this.functionArguments=null,this.rasterArgumentNames=["raster","raster2"]}_bindSourceRasters(){const{method:t}=this.functionArguments,e=this.sourceRasterInfos[0].clone();if(this.outputPixelType=this._getOutputPixelType(e.pixelType),e.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(e),t==="categorical"){const s=this.sourceRasterInfos.map(a=>a.attributeTable),o=this._getFieldNames(s,"value"),n=s.map(a=>this._getClassFieldName(a));if(o[0]==null||o[1]==null||n[0]==null||n[1]==null)return{success:!1,supportsGPU:!1,error:"both inputs must have proper attribute table with value and class fields"};this._updateAttributeTable(e,o,n)}return e.bandCount=1,this.rasterInfo=e,{success:!0,supportsGPU:t==="difference"||t==="relative-difference"}}_processPixels(t){const{pixelBlocks:e}=t;if(e?.[0]==null||e?.[1]==null)return null;const{method:s}=this.functionArguments;return ei(e,s,this.outputPixelType,this._categoryConfig)}_getWebGLParameters(){const t=this.outputPixelType??"f32";let[e,s]=ft(t);const o=W(t);return o&&(e-=1e-4,s+=1e-4),{method:this.functionArguments.method,domainRange:[e,s],isOutputRounded:o}}_updateAttributeTable(t,e,s){const o=this.sourceRasterInfos.map(b=>b.attributeTable),n=o.map((b,P)=>b.features.map(T=>T.attributes[e[P]])),a=o.map((b,P)=>b.features.map(T=>T.attributes[s[P]])),i=n.map(b=>{const P=[];return b.forEach((T,R)=>P[T]=R),P}),{keepMethod:u}=this.functionArguments;this._categoryConfig={categoryIndexLookups:i,classNames:a,keepMethod:u};const l=o[0].clone();l.fields=[new lt({name:"OID",type:"oid"}),new lt({name:"Value",type:"integer"}),new lt({name:"ClassName",type:"string"}),new lt({name:"Class_From",type:"string"}),new lt({name:"Class_To",type:"string"})];const c=this._getFieldNames(o,"red"),p=this._getFieldNames(o,"green"),m=this._getFieldNames(o,"blue"),f=[],g=c.length===2&&p.length===2&&m.length===2;g&&(f.push(...o.map((b,P)=>b.features.map(T=>[T.attributes[c[P]],T.attributes[p[P]],T.attributes[m[P]]]))),l.fields.push(new lt({name:"Red",type:"integer"}),new lt({name:"Green",type:"integer"}),new lt({name:"Blue",type:"integer"})));const x=l.features[0].clone();x.geometry=null;const y=[],[v,w]=n.map(b=>b.length);let A=1;for(let b=0;b<v;b++){const P=a[0][b];for(let T=0;T<w;T++){const R=a[1][T];if(u==="changed"&&P===R||u==="unchanged"&&P!==R)continue;const F=x.clone();F.attributes={OID:A++,Value:b*w+T,ClassName:P===R?P:`${P} -> ${R}`,Class_From:P,Class_To:R},g&&(F.attributes.Red=f[0][b][0]+f[1][T][0]>>1,F.attributes.Green=f[0][b][1]+f[1][T][1]>>1,F.attributes.Blue=f[0][b][2]+f[1][T][2]>>1),y.push(F)}}if(u==="changed"){const b=x.clone();b.attributes={OID:A++,Value:v*w+1,ClassName:"No Change",Class_From:"Same",Class_To:"Same"},y.push(b)}else if(u==="unchanged"){const b=x.clone();b.attributes={OID:A++,Value:v*w+2,ClassName:"Changed",Class_From:"Any",Class_To:"Any"},y.push(b)}l.features=y,t.attributeTable=l}_getFieldNames(t,e){return t.map(({fields:s})=>s.find(o=>o.name.toLowerCase()===e)?.name).filter(s=>s)}_getClassFieldName(t){return(t.fields.find(s=>s.type==="string"&&s.name.toLowerCase().startsWith("class"))??t.fields.find(s=>s.type==="string"&&s.name.toLowerCase().includes("class")||s.name.toLowerCase().includes("type")||s.name.toLowerCase().includes("name"))??t.fields.find(s=>s.type==="string"))?.name}};h([d({json:{write:!0,name:"rasterFunction"}})],wt.prototype,"functionName",void 0),h([d({type:ai,json:{write:!0,name:"rasterFunctionArguments"}})],wt.prototype,"functionArguments",void 0),h([d()],wt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],wt.prototype,"_categoryConfig",void 0),wt=h([N("esri.layers.support.rasterFunctions.ComputeChangeFunction")],wt);const ui=wt;var Le;let re=Le=class extends O{constructor(){super(...arguments),this.contrastOffset=0,this.brightnessOffset=0}clone(){return new Le({contrastOffset:this.contrastOffset,brightnessOffset:this.brightnessOffset,raster:this.raster})}};h([d({json:{write:!0}})],re.prototype,"contrastOffset",void 0),h([d({json:{write:!0}})],re.prototype,"brightnessOffset",void 0),re=Le=h([N("esri.layers.support.rasterFunctions.ContrastBrightnessFunctionArguments")],re);const li=re;let bt=class extends z{constructor(){super(...arguments),this.functionName="ContrastBrightness",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const{sourceRasterInfos:t}=this,e=t[0];if(e.pixelType!=="u8")return{success:!1,supportsGPU:!1,error:"Only unsigned 8 bit raster is supported by ContrastBrightness function."};this.outputPixelType=this._getOutputPixelType("u8");const s=e.clone();this._removeStatsHistColormapVAT(s),this.rasterInfo=s;const{contrastOffset:o,brightnessOffset:n}=this.functionArguments;return this.lookup=Gn(o,n),{success:!0,supportsGPU:!0}}_processPixels(t){const e=t.pixelBlocks?.[0];return e==null?null:ls(e,{lut:e.pixels.map(()=>this.lookup),offset:0,outputPixelType:"u8"})}_getWebGLParameters(){const{contrastOffset:t,brightnessOffset:e}=this.functionArguments;return{contrastOffset:t,brightnessOffset:e}}};h([d({json:{write:!0,name:"rasterFunction"}})],bt.prototype,"functionName",void 0),h([d({type:li,json:{write:!0,name:"rasterFunctionArguments"}})],bt.prototype,"functionArguments",void 0),h([d()],bt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],bt.prototype,"lookup",void 0),bt=h([N("esri.layers.support.rasterFunctions.ContrastBrightnessFunction")],bt);const ci=bt;function fs(r,t,e,s,o){const n=Math.floor(s/2);for(let i=0;i<n;i++)for(let u=0;u<t;u++)r[i*t+u]=r[(o-1-i)*t+u],r[(e-1-i)*t+u]=r[(e-o+i)*t+u];const a=Math.floor(o/2);for(let i=0;i<e;i++){const u=i*t;for(let l=0;l<a;l++)r[u+l]=r[u+o-1-l],r[u+t-l-1]=r[u+t+l-o]}}const j=new Map;function pi(r){const t=Math.sqrt(r.length),e=r.slice(0,t),s=[1];for(let o=1;o<t;o++){let n=null;for(let a=0;a<t;a++){const i=r[a+o*t],u=r[a];if(n==null)if(u===0){if(i)return{separable:!1,row:null,col:null}}else n=i/u;else if(i/u!==n)return{separable:!1,row:null,col:null}}if(n==null)return{separable:!1,row:null,col:null};s.push(n)}return{separable:!0,row:e,col:s}}function Vs(r,t,e,s,o,n,a){const i=new Float32Array(t*e),u=n.length,l=a?0:s,c=a?s:0,p=a?1:t;for(let m=l;m<e-l;m++){const f=m*t;for(let g=c;g<t-c;g++){if(o&&!o[f+g])continue;let x=0;for(let y=0;y<u;y++)x+=r[f+g+(y-s)*p]*n[y];i[f+g]=x}}return i}function hi(r,t,e,s,o,n,a){const i=new Float32Array(t*e),u=Math.floor(s/2),l=Math.floor(o/2);for(let c=u;c<e-u;c++){const p=c*t;for(let m=l;m<t-l;m++){if(n&&!n[p+m])continue;let f=0;for(let g=0;g<s;g++)for(let x=0;x<o;x++)f+=r[p+m+(g-u)*t+x-l]*a[g*o+x];i[p+m]=f}}return i}function mi(r,t,e=!0){const{pixels:s,width:o,height:n,pixelType:a,mask:i}=r,u=s.length,l=[],{kernel:c,rows:p,cols:m}=t;for(let f=0;f<u;f++){const g=hi(s[f],o,n,p,m,i,c);e&&fs(g,o,n,p,m),l.push(g)}return new $({width:o,height:n,pixelType:a,pixels:l,mask:i})}function fi(r,t,e,s=!0){const{pixels:o,width:n,height:a,pixelType:i,mask:u}=r,l=o.length,c=[],p=t.length,m=e.length,f=Math.floor(p/2),g=Math.floor(m/2);for(let x=0;x<l;x++){let y=Vs(o[x],n,a,f,u,t,!0);y=Vs(y,n,a,g,u,e,!1),s&&fs(y,n,a,p,m),c.push(y)}return new $({width:n,height:a,pixelType:i,pixels:c,mask:u})}function di(r,t){const e=pi(t.kernel),s=t.mirrorEdges!==!1,o=e.separable?fi(r,e.row,e.col,s):mi(r,t,s),{outputPixelType:n}=t;return n&&o.clamp(n),o}j.set(M.none,[0,0,0,0,1,0,0,0,0]),j.set(M.lineDetectionHorizontal,[-1,-1,-1,2,2,2,-1,-1,-1]),j.set(M.lineDetectionVertical,[-1,2,-1,-1,2,-1,-1,2,-1]),j.set(M.lineDetectionLeftDiagonal,[2,-1,-1,-1,2,-1,-1,-1,2]),j.set(M.lineDetectionRightDiagonal,[-1,-1,2,-1,2,-1,2,-1,-1]),j.set(M.gradientNorth,[-1,-2,-1,0,0,0,1,2,1]),j.set(M.gradientWest,[-1,0,1,-2,0,2,-1,0,1]),j.set(M.gradientEast,[1,0,-1,2,0,-2,1,0,-1]),j.set(M.gradientSouth,[1,2,1,0,0,0,-1,-2,-1]),j.set(M.gradientNorthEast,[0,-1,-2,1,0,-1,2,1,0]),j.set(M.gradientNorthWest,[-2,-1,0,-1,0,1,0,1,2]),j.set(M.smoothArithmeticMean,[.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111]),j.set(M.smoothing3x3,[.0625,.125,.0625,.125,.25,.125,.0625,.125,.0625]),j.set(M.smoothing5x5,[1,1,1,1,1,1,4,4,4,1,1,4,12,4,1,1,4,4,4,1,1,1,1,1,1]),j.set(M.sharpening3x3,[-1,-1,-1,-1,9,-1,-1,-1,-1]),j.set(M.sharpening5x5,[-1,-3,-4,-3,-1,-3,0,6,0,-3,-4,6,21,6,-4,-3,0,6,0,-3,-1,-3,-4,-3,-1]),j.set(M.laplacian3x3,[0,-1,0,-1,4,-1,0,-1,0]),j.set(M.laplacian5x5,[0,0,-1,0,0,0,-1,-2,-1,0,-1,-2,17,-2,-1,0,-1,-2,-1,0,0,0,-1,0,0]),j.set(M.sobelHorizontal,[-1,-2,-1,0,0,0,1,2,1]),j.set(M.sobelVertical,[-1,0,1,-2,0,2,-1,0,1]),j.set(M.sharpen,[0,-.25,0,-.25,2,-.25,0,-.25,0]),j.set(M.sharpen2,[-.25,-.25,-.25,-.25,3,-.25,-.25,-.25,-.25]),j.set(M.pointSpread,[-.627,.352,-.627,.352,2.923,.352,-.627,.352,-.627]);var We;let vt=We=class extends O{constructor(){super(...arguments),this.rows=3,this.cols=3,this.kernel=[0,0,0,0,1,0,0,0,0]}set convolutionType(r){this._set("convolutionType",r);const t=j.get(r);if(!t||r===M.userDefined||r===M.none)return;const e=Math.sqrt(t.length);this._set("kernel",t),this._set("cols",e),this._set("rows",e)}clone(){return new We({cols:this.cols,rows:this.rows,kernel:[...this.kernel],convolutionType:this.convolutionType,raster:J(this.raster)})}};h([d({json:{type:Number,write:!0}})],vt.prototype,"rows",void 0),h([d({json:{type:Number,write:!0}})],vt.prototype,"cols",void 0),h([d({json:{name:"type",type:Number,write:!0}})],vt.prototype,"convolutionType",null),h([d({json:{type:[Number],write:!0}})],vt.prototype,"kernel",void 0),vt=We=h([N("esri.layers.support.rasterFunctions.ConvolutionFunctionArguments")],vt);const gi=vt,Us=25;let At=class extends z{constructor(){super(...arguments),this.functionName="Convolution",this.rasterArgumentNames=["raster"]}get _normalizedKernel(){const{kernel:t,convolutionType:e}=this.functionArguments,s=t.reduce((o,n)=>o+n);return e===-1||s===0||s===1?t:t.map(o=>o/s)}_bindSourceRasters(){const{convolutionType:t,rows:e,cols:s,kernel:o}=this.functionArguments;if(!Object.values(M).includes(t))return{success:!1,supportsGPU:!1,error:`convolution-function: the specified kernel type is not supported ${t}`};if(t!==M.none&&e*s!==o.length)return{success:!1,supportsGPU:!1,error:"convolution-function: the specified rows and cols do not match the length of the kernel"};const n=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(n.pixelType);const a=n.clone();a.pixelType=this.outputPixelType;const i=[M.none,M.sharpen,M.sharpen2,M.sharpening3x3,M.sharpening5x5];return(t===-1||this.outputPixelType!=="u8"&&!i.includes(t))&&(a.statistics=null,a.histograms=null),a.colormap=null,a.attributeTable=null,this.rasterInfo=a,{success:!0,supportsGPU:o.length<=Us}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null||this.functionArguments.convolutionType===M.none)return e;const{rows:s,cols:o}=this.functionArguments,{_normalizedKernel:n}=this;return di(e,{kernel:n,rows:s,cols:o,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const t=new Float32Array(Us),{rows:e,cols:s}=this.functionArguments,{_normalizedKernel:o}=this;for(let n=0;n<e;n++)for(let a=0;a<s;a++)t[5*n+a]=o[n*s+a];return{kernelRows:e,kernelCols:s,kernel:t,clampRange:ft(this.outputPixelType)}}};h([d({json:{write:!0,name:"rasterFunction"}})],At.prototype,"functionName",void 0),h([d({type:gi,json:{write:!0,name:"rasterFunctionArguments"}})],At.prototype,"functionArguments",void 0),h([d()],At.prototype,"rasterArgumentNames",void 0),h([d()],At.prototype,"_normalizedKernel",null),At=h([N("esri.layers.support.rasterFunctions.ConvolutionFunction")],At);const yi=At;var qe;const dn=new rt({0:"standard",1:"planform",2:"profile"},{useNumericKeys:!0});let Lt=qe=class extends O{constructor(){super(...arguments),this.curvatureType="standard",this.zFactor=1}readCurvatureType(r,t){return dn.fromJSON(t.type??t.curvatureType??0)}clone(){return new qe({curvatureType:this.curvatureType,zFactor:this.zFactor,raster:this.raster})}};h([d({json:{write:{target:"type"}}}),nt(dn)],Lt.prototype,"curvatureType",void 0),h([oe("curvatureType",["type","curvatureType"])],Lt.prototype,"readCurvatureType",null),h([d({type:Number,json:{write:!0}})],Lt.prototype,"zFactor",void 0),Lt=qe=h([N("esri.layers.support.rasterFunctions.CurvatureFunctionArguments")],Lt);const xi=Lt;let Pt=class extends z{constructor(){super(...arguments),this.functionName="Curvature",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0].clone();return t.pixelType=this.outputPixelType,t.bandCount=1,this._removeStatsHistColormapVAT(t),this.rasterInfo=t,this.isGCS=t.spatialReference?.isGeographic??!1,{success:!0,supportsGPU:!0}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return null;const{zFactor:s,curvatureType:o}=this.functionArguments,{extent:n,primaryPixelSizes:a}=t,i=a?.[0],u=i??(n?{x:n.width/e.width,y:n.height/e.height}:{x:1,y:1}),l=this.isGCS&&s>=1?s*ie:s;return zn(e,{zFactor:l,curvatureType:o,resolution:u})}_getWebGLParameters(){const{zFactor:t,curvatureType:e}=this.functionArguments;return{curvatureType:e,zFactor:this.isGCS&&t>=1?t*ie:t}}};h([d({json:{write:!0,name:"rasterFunction"}})],Pt.prototype,"functionName",void 0),h([d({type:xi,json:{write:!0,name:"rasterFunctionArguments"}})],Pt.prototype,"functionArguments",void 0),h([d()],Pt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],Pt.prototype,"isGCS",void 0),Pt=h([N("esri.layers.support.rasterFunctions.CurvatureFunction")],Pt);const wi=Pt;var He;let it=He=class extends O{constructor(){super(...arguments),this.bandIds=[],this.bandNames=[],this.bandWavelengths=[],this.missingBandAction=sn.bestMatch}clone(){return new He({bandIds:this.bandIds?.slice(),bandNames:this.bandNames?.slice(),bandWavelengths:this.bandWavelengths?.slice(),missingBandAction:this.missingBandAction,method:this.method,wavelengthMatchTolerance:this.wavelengthMatchTolerance})}};h([d({json:{write:!0}})],it.prototype,"bandIds",void 0),h([d({json:{write:!0}})],it.prototype,"bandNames",void 0),h([d({json:{write:!0}})],it.prototype,"bandWavelengths",void 0),h([nt({0:"name",1:"wavelength",2:"id"})],it.prototype,"method",void 0),h([d({json:{write:!0}})],it.prototype,"missingBandAction",void 0),h([d({json:{write:!0}})],it.prototype,"wavelengthMatchTolerance",void 0),it=He=h([N("esri.layers.support.rasterFunctions.ExtractBandFunctionArguments")],it);const bi=it;let Wt=class extends z{constructor(){super(...arguments),this.functionName="ExtractBand",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{functionArguments:t,sourceRasterInfos:e}=this,s=e[0],{method:o,bandNames:n,bandWavelengths:a,bandIds:i,missingBandAction:u}=t,l=n?.length&&(o==="name"||o!=="id"&&!i?.length),c=a?.length&&(o==="wavelength"||o!=="id"&&!i?.length),p=u===sn.fail,m=l?Ai(s,n):c?Ti(s,a,this.functionArguments,p):Pi(s,i,p);if(m==null)return{success:!1,supportsGPU:!1,error:`extract-band-function: Invalid ${l?"band names":c?"band wavelengths":"band ids"} for the imagery data source`};this.functionArguments.bandIds=m,this.functionArguments.method="id",this.outputPixelType=this._getOutputPixelType("f32");const f=s.clone();f.pixelType=this.outputPixelType,f.bandCount=m.length;const{statistics:g,histograms:x}=f;g!=null&&g.length&&(f.statistics=m.map(v=>g[v]||g[g.length-1])),x!=null&&x.length&&(f.histograms=m.map(v=>x[v]||x[x.length-1])),f.multidimensionalInfo&&f.multidimensionalInfo.variables.forEach(v=>{const{statistics:w,histograms:A}=v;w!=null&&w.length&&(v.statistics=m.map(b=>w[b]||w[w.length-1])),A!=null&&A.length&&(v.histograms=m.map(b=>A[b]||A[A.length-1]))});let y=f.keyProperties?.BandProperties;return y?.length&&(y=m.map(v=>v>=y.length?y[y.length-1]:y[v]),f.keyProperties={...f.keyProperties,BandProperties:y}),this.rasterInfo=f,{success:!0,supportsGPU:f.bandCount<=3}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return null;const s=e.pixels.length,o=this.functionArguments.bandIds.map(n=>n>=s?s-1:n);return e.extractBands(o)}_getWebGLParameters(){let t;if(this.isInputBandIdsSwizzled)t=this.swizzledBandSelection.length?this.swizzledBandSelection:[0,1,2];else{t=[...this.functionArguments.bandIds],t.length===0?t=[0,1,2]:t.length<3&&(t[1]=t[1]??t[0],t[2]=t[2]??t[1]);for(let e=0;e<3;e++)t[e]=Math.min(t[e],2)}return{bandIndexMat3:U(t)}}_getInputBandIds(t){const e=t.length;return this.functionArguments.bandIds.map(s=>s>=e?e-1:s).map(s=>t[s])}_swizzleBandIds(t){const e=this.functionArguments.bandIds.map(s=>t.indexOf(s));return this.isInputBandIdsSwizzled=!0,e[1]??(e[1]=e[0]),e[2]??(e[2]=e[1]),this.swizzledBandSelection=e,!1}};h([d({json:{write:!0,name:"rasterFunction"}})],Wt.prototype,"functionName",void 0),h([d({type:bi,json:{write:!0,name:"rasterFunctionArguments"}})],Wt.prototype,"functionArguments",void 0),h([d()],Wt.prototype,"rasterArgumentNames",void 0),Wt=h([N("esri.layers.support.rasterFunctions.ExtractBandFunction")],Wt);const vi=Wt;function Ai(r,t){const e=r.bandInfos.map(({name:o})=>o.toLowerCase()),s=[];for(let o=0;o<t.length;o++){const n=t[o].toLowerCase();let a=e.indexOf(n);if(a===-1&&n==="nearinfrared"&&(a=e.findIndex(i=>i.startsWith("nearinfrared_1")),a===-1&&(a=e.findIndex(i=>i.startsWith("nearinfrared")))),a===-1)return null;s.push(a)}return s}function Pi(r,t,e){const{bandCount:s}=r;return!t?.length||e&&t.some(o=>o<0||o>=s)?null:t}function Ti(r,t,{wavelengthMatchTolerance:e},s){const{bandInfos:o}=r,n=[];for(let i=0;i<o.length;i++){const{minWavelength:u,maxWavelength:l}=o[i];if(!u||!l)return null;n.push({minWavelength:u,maxWavelength:l})}const a=[];for(let i=0;i<t.length;i++){const u=t[i];let l=!1,c=-1,p=Number.MAX_VALUE;for(let m=0;m<n.length;m++){const f=n[m],g=u>=f.minWavelength&&u<=f.maxWavelength,x=Math.abs(u-(f.minWavelength+f.maxWavelength)/2);g?x<p&&(l=!0,c=m,p=x):!l&&x<p&&(c=m,p=x)}if(!l&&e&&p<e&&(l=!0),!l&&s)return null;a.push(c)}return a}function $i(r,t,e){const{pixels:s,width:o,height:n,mask:a,bandMasks:i}=r,u=o*n,l=i?.length?$.combineBandMasks(i):a,c=Math.min(t.length,s.length),p=e.startsWith("f"),m=!p&&e!==r.pixelType,[f,g]=ft(e),x=$.createEmptyBand(e,u);for(let v=0;v<n;v++){let w=v*o;for(let A=0;A<o;A++,w++)if(!l||l[w]){let b=0;for(let P=0;P<c;P++)b+=t[P]*s[P][w];p||(b=Math.round(b),m&&(b=b>g?g:b<f?f:b)),x[w]=b}}const y=new $({width:o,height:n,pixels:[x],pixelType:e,mask:l});return y.updateStatistics(),y}var Je;let me=Je=class extends O{clone(){return new Je({conversionParameters:[...this.conversionParameters],raster:this.raster})}};h([d({type:[Number],json:{write:!0}})],me.prototype,"conversionParameters",void 0),me=Je=h([N("esri.layers.support.rasterFunctions.GrayscaleFunctionArguments")],me);const Ri=me;let Tt=class extends z{constructor(){super(...arguments),this.functionName="Grayscale",this.functionArguments=null,this.rasterArgumentNames=["raster"]}get _normalizedWeights(){const{conversionParameters:t}=this.functionArguments,e=t.reduce((s,o)=>s+o);return t.map(s=>s/e)}_bindSourceRasters(){const{conversionParameters:t}=this.functionArguments;if(!t?.length)return{success:!1,supportsGPU:!1,error:"missing valid conversion parameters."};const e=this.sourceRasterInfos[0].clone();this.outputPixelType=this._getOutputPixelType(e.pixelType),e.pixelType=this.outputPixelType;const s=t.length===3||e.bandCount===3&&t.length>3;return e.bandCount=1,this._removeStatsHistColormapVAT(e),this.rasterInfo=e,{success:!0,supportsGPU:s}}_processPixels(t){const e=t.pixelBlocks?.[0];return e==null?null:$i(e,this._normalizedWeights,this.outputPixelType)}_getWebGLParameters(){return{weights:this._normalizedWeights}}};h([d({json:{write:!0,name:"rasterFunction"}})],Tt.prototype,"functionName",void 0),h([d({type:Ri,json:{write:!0,name:"rasterFunctionArguments"}})],Tt.prototype,"functionArguments",void 0),h([d()],Tt.prototype,"rasterArgumentNames",void 0),h([d()],Tt.prototype,"_normalizedWeights",null),Tt=h([N("esri.layers.support.rasterFunctions.GrayscaleFunction")],Tt);const Ni=Tt;var Ke;const Fi=new rt({0:"traditional",1:"multi-directional"},{useNumericKeys:!0}),ki=new rt({1:"degree",2:"percent-rise",3:"scaled"},{useNumericKeys:!0});let Y=Ke=class extends O{constructor(){super(...arguments),this.altitude=45,this.azimuth=315,this.hillshadeType="traditional",this.pixelSizePower=.664,this.pixelSizeFactor=.024,this.slopeType="degree",this.zFactor=1,this.removeEdgeEffect=!1}clone(){return new Ke({hillshadeType:this.hillshadeType,altitude:this.altitude,azimuth:this.azimuth,zFactor:this.zFactor,slopeType:this.slopeType,pixelSizeFactor:this.pixelSizeFactor,pixelSizePower:this.pixelSizePower,removeEdgeEffect:this.removeEdgeEffect,raster:this.raster})}};h([d({type:Number,json:{write:!0}})],Y.prototype,"altitude",void 0),h([d({type:Number,json:{write:!0}})],Y.prototype,"azimuth",void 0),h([d(),nt(Fi)],Y.prototype,"hillshadeType",void 0),h([d({type:Number,json:{write:!0,name:"psPower"}})],Y.prototype,"pixelSizePower",void 0),h([d({type:Number,json:{write:!0,name:"psZFactor"}})],Y.prototype,"pixelSizeFactor",void 0),h([d(),nt(ki)],Y.prototype,"slopeType",void 0),h([d({type:Number,json:{write:!0}})],Y.prototype,"zFactor",void 0),h([d({type:Boolean,json:{write:!0}})],Y.prototype,"removeEdgeEffect",void 0),Y=Ke=h([N("esri.layers.support.rasterFunctions.HillshadeFunctionArguments")],Y);const gn=Y;let $t=class extends z{constructor(){super(...arguments),this.functionName="Hillshade",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){const t=this.sourceRasterInfos[0];if(t.bandCount>1)return{success:!1,supportsGPU:!1,error:"hillshade-function: source data must be single band"};this.outputPixelType=this._getOutputPixelType("u8");const e=t.clone();return this._removeStatsHistColormapVAT(e),e.pixelType=this.outputPixelType,e.bandCount=1,e.statistics=[{min:0,max:255,avg:60,stddev:10}],this.rasterInfo=e,this.isGCS=e.spatialReference?.isGeographic??!1,{success:!0,supportsGPU:!0}}_processPixels(t){const e=t.pixelBlocks?.[0];if(!e)return null;const{extent:s,primaryPixelSizes:o}=t,n=o?.[0],a=n??(s?{x:s.width/e.width,y:s.height/e.height}:{x:1,y:1}),i=ge(this.functionArguments,a,this.isGCS),u=nn(e,i);return u.pixelType=this.outputPixelType,u}_getWebGLParameters(){const t=ge(this.functionArguments,{x:1,y:1},this.isGCS),e=rn(t),{slopeType:s,zFactor:o,pixelSizeFactor:n,pixelSizePower:a}=this.functionArguments,i=s==="scaled",u=W(this.outputPixelType);return{...e,zFactor:o,gcsFactor:this.isGCS?ie:1,pixelSizeFactor:i?n:0,pixelSizePower:i?a:0,isOutputRounded:u}}};h([d({json:{write:!0,name:"rasterFunction"}})],$t.prototype,"functionName",void 0),h([d({type:gn,json:{write:!0,name:"rasterFunctionArguments"}})],$t.prototype,"functionArguments",void 0),h([d()],$t.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],$t.prototype,"isGCS",void 0),$t=h([N("esri.layers.support.rasterFunctions.HillshadeFunction")],$t);const Ii=$t;var Xe;let Rt=Xe=class extends O{constructor(){super(...arguments),this.rasters=[],this.processAsMultiband=!0}writeRasters(r,t){t.rasters=r.map(e=>typeof e=="number"||typeof e=="string"?e:e.toJSON())}clone(){return new Xe({operation:this.operation,processAsMultiband:this.processAsMultiband,rasters:J(this.rasters)})}};h([d({json:{write:!0}})],Rt.prototype,"operation",void 0),h([d({json:{write:!0}})],Rt.prototype,"rasters",void 0),h([Ae("rasters")],Rt.prototype,"writeRasters",null),h([d({json:{write:!0}})],Rt.prototype,"processAsMultiband",void 0),Rt=Xe=h([N("esri.layers.support.rasterFunctions.LocalFunctionArguments")],Rt);const _i=Rt;let qt=class extends z{constructor(){super(...arguments),this.functionName="Local",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,e=t[0],{bandCount:s}=e,{processAsMultiband:o}=this.functionArguments;if(t.some(l=>l.bandCount!==s))return{success:!1,supportsGPU:!1,error:"local-function: input rasters do not have same band count"};const{operation:n,rasters:a}=this.functionArguments,i=bs[n];if(!(i===999||a.length===i||a.length<=1&&i===1))return{success:!1,supportsGPU:!1,error:`local-function: the length of functionArguments.rasters does not match operation's requirement: ${i}`};const u=e.clone();return u.bandCount=i!==999||o?s:1,this._removeStatsHistColormapVAT(u),this._updateStatistics(u),this._updatePixelType(u),this.rasterInfo=u,{success:!0,supportsGPU:u.bandCount===1&&i<=3}}_processPixels(t){const{pixelBlocks:e}=t;return e==null||e.some(s=>s==null)?null:pn(e,this.functionArguments.operation,{processAsMultiband:this.functionArguments.processAsMultiband,outputPixelType:this.outputPixelType??void 0})}_getWebGLParameters(){const{operation:t}=this.functionArguments,e=bs[t],s=Object.keys(xs).find(u=>xs[u]===t)?.toLowerCase()??"undefined",o=this.outputPixelType??"f32";let[n,a]=ft(o);const i=W(o);return i&&(n-=1e-4,a+=1e-4),{imageCount:e,operationName:s,domainRange:[n,a],isOutputRounded:i}}_updateStatistics(t){const e=this.sourceRasterInfos[0],{operation:s}=this.functionArguments,o=ws(s)?.domain;if(o){t.statistics=[];for(let n=0;n<t.bandCount;n++)t.statistics[n]={min:o[0],max:o[1],avg:(o[0]+o[1])/2,stddev:(o[0]+o[1])/10}}else s===45&&e.statistics?.length&&(t.statistics=e.statistics.map(n=>({min:-n.max,max:-n.min,avg:n.avg!=null?-n.avg:void 0,stddev:n.stddev!=null?-n.stddev:void 0})))}_updatePixelType(t){const{statistics:e,pixelType:s}=this.sourceRasterInfos[0],{operation:o}=this.functionArguments,{domain:n,isInteger:a}=ws(o)??{domain:null,isInteger:!1};let i="f32";if(n&&a)i=$e(n[0],n[1]);else if(o===30){const u=e?.[0];i=u?$e(u.min,u.max):W(s)?s:"s32"}else if(o===45&&W(s)){const u=e?.map(({max:m})=>-m),l=e?.map(({min:m})=>-m),c=u?.length?Math.min(...u):null,p=l?.length?Math.min(...l):null;i=c!=null&&p!=null?$e(c,p):s.startsWith("s")?s.replace("s","u"):s==="u1"||s==="u2"||s==="u4"?"s8":s==="u8"?"s16":"s32"}t.pixelType=this.outputPixelType=this._getOutputPixelType(i)}};h([d({json:{write:!0,name:"rasterFunction"}})],qt.prototype,"functionName",void 0),h([d({type:_i,json:{write:!0,name:"rasterFunctionArguments"}})],qt.prototype,"functionArguments",void 0),h([d()],qt.prototype,"rasterArgumentNames",void 0),qt=h([N("esri.layers.support.rasterFunctions.LocalFunction")],qt);const Si=qt;var Ye;let Nt=Ye=class extends O{constructor(){super(...arguments),this.includedRanges=null,this.noDataValues=null,this.noDataInterpretation=on.matchAny}get normalizedNoDataValues(){const{noDataValues:r}=this;if(!r?.length)return null;let t=!1;const e=r.map(s=>{if(typeof s=="number")return t=!0,[s];if(typeof s=="string"){const o=s.trim().split(" ").filter(n=>n.trim()!=="").map(n=>Number(n));return t=t||o.length>0,o.length===0?null:o}return null});return t?e:null}clone(){return new Ye({includedRanges:this.includedRanges?.slice()??[],noDataValues:this.noDataValues?.slice()??[],noDataInterpretation:this.noDataInterpretation})}};h([d({json:{write:!0}})],Nt.prototype,"includedRanges",void 0),h([d({json:{write:!0}})],Nt.prototype,"noDataValues",void 0),h([d()],Nt.prototype,"normalizedNoDataValues",null),h([d({json:{write:!0}})],Nt.prototype,"noDataInterpretation",void 0),Nt=Ye=h([N("esri.layers.support.rasterFunctions.MaskFunctionArguments")],Nt);const Mi=Nt;let Ft=class extends z{constructor(){super(...arguments),this.functionName="Mask",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone(),{pixelType:e}=t;this.outputPixelType=this._getOutputPixelType(e),t.pixelType=this.outputPixelType,this.rasterInfo=t;const{includedRanges:s,normalizedNoDataValues:o}=this.functionArguments;if(!s?.length&&!o?.length)return{success:!1,supportsGPU:!1,error:"missing includedRanges or noDataValues argument"};let n=[];for(let i=0;i<t.bandCount;i++){const u=En(e,s?.slice(2*i,2*i+2),o?.[i]);if(u==null){n=null;break}n.push(u)}this.lookups=n;const a=o!=null&&o.every(i=>i?.length===o[0]?.length);return{success:!0,supportsGPU:(!s||s.length<=2*Yt)&&(!o||a&&o[0].length<=Yt)}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return null;const{outputPixelType:s,lookups:o}=this,{includedRanges:n,noDataInterpretation:a,normalizedNoDataValues:i}=this.functionArguments,u=a===on.matchAll;return On(e,{includedRanges:n,noDataValues:i,outputPixelType:s,matchAll:u,lookups:o})}_getWebGLParameters(){const{includedRanges:t,normalizedNoDataValues:e}=this.functionArguments,s=new Float32Array(Yt);s.fill(pe),e?.[0]?.length&&s.set(e[0]);const o=new Float32Array(6);for(let n=0;n<o.length;n+=2)o[n]=t?.[n]??-pe,o[n+1]=t?.[n+1]??pe;return t?.length&&o.set(t),{bandCount:this.sourceRasterInfos[0].bandCount,noDataValues:s,includedRanges:o}}};h([d({json:{write:!0,name:"rasterFunction"}})],Ft.prototype,"functionName",void 0),h([d({type:Mi,json:{write:!0,name:"rasterFunctionArguments"}})],Ft.prototype,"functionArguments",void 0),h([d()],Ft.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],Ft.prototype,"lookups",void 0),Ft=h([N("esri.layers.support.rasterFunctions.MaskFunction")],Ft);const Ci=Ft;var Ze;let Ht=Ze=class extends O{constructor(){super(...arguments),this.visibleBandID=0,this.infraredBandID=1,this.scientificOutput=!1}clone(){const{visibleBandID:r,infraredBandID:t,scientificOutput:e}=this;return new Ze({visibleBandID:r,infraredBandID:t,scientificOutput:e})}};h([d({json:{write:!0}})],Ht.prototype,"visibleBandID",void 0),h([d({json:{write:!0}})],Ht.prototype,"infraredBandID",void 0),h([d({json:{write:!0}})],Ht.prototype,"scientificOutput",void 0),Ht=Ze=h([N("esri.layers.support.rasterFunctions.NDVIFunctionArguments")],Ht);const Bi=Ht;let Jt=class extends z{constructor(){super(...arguments),this.functionName="NDVI",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{scientificOutput:t,visibleBandID:e,infraredBandID:s}=this.functionArguments;this.outputPixelType=this._getOutputPixelType(t?"f32":"u8");const o=this.sourceRasterInfos[0],n=Math.max(e,s);if(o.bandCount<2||n>=o.bandCount)return{success:!1,supportsGPU:!1,error:"ndvi-function: source raster has insufficient amount of raster bands"};if(e<0||s<0)return{success:!1,supportsGPU:!1,error:"ndvi-function: invalid visible or infrared band id"};const a=o.clone();a.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(a),a.bandCount=1,a.keyProperties={...a.keyProperties,BandProperties:void 0};const[i,u,l,c]=t?[-1,1,0,.1]:[0,200,100,10];return a.statistics=[{min:i,max:u,avg:l,stddev:c}],this.rasterInfo=a,{success:!0,supportsGPU:!0}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return null;const{visibleBandID:s,infraredBandID:o,scientificOutput:n}=this.functionArguments;return Zr(e,s,o,!n)}_getWebGLParameters(){const{visibleBandID:t,infraredBandID:e,scientificOutput:s}=this.functionArguments,o=this.isInputBandIdsSwizzled?[0,1,2]:[e,t,0];return{bandIndexMat3:U(o),scaled:!s}}_getInputBandIds(t){const{visibleBandID:e,infraredBandID:s}=this.functionArguments;return[s,e,0].map(o=>t[o])}_swizzleBandIds(t){const{visibleBandID:e,infraredBandID:s}=this.functionArguments,o=[e,s].map(n=>t.indexOf(n));return o[2]=o[1],this.isInputBandIdsSwizzled=!0,this.swizzledBandSelection=o,!1}};h([d({json:{write:!0,name:"rasterFunction"}})],Jt.prototype,"functionName",void 0),h([d({type:Bi,json:{write:!0,name:"rasterFunctionArguments"}})],Jt.prototype,"functionArguments",void 0),h([d()],Jt.prototype,"rasterArgumentNames",void 0),Jt=h([N("esri.layers.support.rasterFunctions.NDVIFunction")],Jt);const ji=Jt;var Qe;let at=Qe=class extends O{constructor(){super(...arguments),this.inputRanges=null,this.outputValues=null,this.noDataRanges=null,this.allowUnmatched=!1,this.isLastInputRangeInclusive=!1}clone(){return new Qe({inputRanges:[...this.inputRanges],outputValues:[...this.outputValues],noDataRanges:[...this.noDataRanges],allowUnmatched:this.allowUnmatched,isLastInputRangeInclusive:this.isLastInputRangeInclusive})}};h([d({json:{write:!0}})],at.prototype,"inputRanges",void 0),h([d({json:{write:!0}})],at.prototype,"outputValues",void 0),h([d({json:{write:!0}})],at.prototype,"noDataRanges",void 0),h([d({json:{write:!0}})],at.prototype,"allowUnmatched",void 0),h([d({json:{write:!0}})],at.prototype,"replacementValue",void 0),h([d({json:{write:!0}})],at.prototype,"isLastInputRangeInclusive",void 0),at=Qe=h([N("esri.layers.support.rasterFunctions.RemapFunctionArguments")],at);const Gi=at;let kt=class extends z{constructor(){super(...arguments),this.functionName="Remap",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const r=this.sourceRasterInfos[0].clone(),{pixelType:t}=r;r.bandCount=1;const{statistics:e}=r;this._removeStatsHistColormapVAT(r);const{allowUnmatched:s,replacementValue:o,outputValues:n,inputRanges:a,noDataRanges:i,isLastInputRangeInclusive:u}=this.functionArguments,l=this.outputPixelType==="unknown"||this.outputPixelType==null;if(this.outputPixelType=this._getOutputPixelType(t),n?.length){const c=e?.[0];if(s&&o==null){let p=c?.min??n[0],m=c?.max??n[0];p=Math.min.apply(null,[...n,p]),m=Math.max.apply(null,[...n,m]),r.statistics=[{min:p,max:m,avg:c?.avg??0,stddev:c?.stddev??-1}]}else{let p=n[0],m=p;for(let f=0;f<n.length;f++)p=p>n[f]?n[f]:p,m=m>n[f]?m:n[f];s&&o!=null&&(p=Math.min(p,o),m=Math.max(m,o)),r.statistics=[{min:p,max:m,avg:c?.avg??0,stddev:c?.stddev??-1}]}if(l){const{min:p,max:m}=r.statistics[0],f=["u8","s8","u16","s16","u32","s32","f32"],g=f.find(x=>{const[y,v]=ft(x);return p>=y&&m<=v})??"f64";n.some(x=>Math.floor(x)!==x)?this.outputPixelType=g==="f64"?"f64":"f32":this.outputPixelType=s&&o==null&&f.indexOf(t)>f.indexOf(g)?t:g}}return r.pixelType=this.outputPixelType,this.rasterInfo=r,this.lookup=s?null:Dn({srcPixelType:t,inputRanges:a,outputValues:n,noDataRanges:i,allowUnmatched:s,isLastInputRangeInclusive:u,outputPixelType:this.outputPixelType}),{success:!0,supportsGPU:(!n||n.length<=Yt)&&(!i||i.length<=Yt)}}_processPixels(r){const t=r.pixelBlocks?.[0];if(t==null)return null;const{lookup:e,outputPixelType:s}=this;if(e){const c=ls(t,{lut:[e.lut],offset:e.offset,outputPixelType:s});return c!=null&&e.mask&&(c.mask=Vn(t.pixels[0],t.mask,e.mask,e.offset,"u8")),c}const{inputRanges:o,outputValues:n,noDataRanges:a,allowUnmatched:i,isLastInputRangeInclusive:u,replacementValue:l}=this.functionArguments;return Un(t,{inputRanges:o,outputValues:n,noDataRanges:a,outputPixelType:s,allowUnmatched:i,isLastInputRangeInclusive:u,replacementValue:l})}_getWebGLParameters(){const{allowUnmatched:r,noDataRanges:t,isLastInputRangeInclusive:e}=this.functionArguments,s=this.functionArguments.inputRanges??[],o=this.functionArguments.outputValues??[],n=Ln(s,o,e),a=new Float32Array(2*Yt);return a.fill(pe),t?.length&&a.set(t),{allowUnmatched:r,rangeMaps:n,noDataRanges:a,clampRange:ft(this.outputPixelType),replacementValue:this.functionArguments.replacementValue}}};h([d({json:{write:!0,name:"rasterFunction"}})],kt.prototype,"functionName",void 0),h([d({type:Gi,json:{write:!0,name:"rasterFunctionArguments"}})],kt.prototype,"functionArguments",void 0),h([d()],kt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],kt.prototype,"lookup",void 0),kt=h([N("esri.layers.support.rasterFunctions.RemapFunction")],kt);const zi=kt;var ts;let Kt=ts=class extends gn{readColorRamp(r){if(typeof r=="string"){const t=Ct.jsonValues.find(e=>e.toLowerCase()===r.toLowerCase());return t?Qs(Ct.fromJSON(t)):null}return"toJSON"in r?r.toJSON():r}clone(){return new ts({hillshadeType:this.hillshadeType,altitude:this.altitude,azimuth:this.azimuth,zFactor:this.zFactor,slopeType:this.slopeType,pixelSizeFactor:this.pixelSizeFactor,pixelSizePower:this.pixelSizePower,removeEdgeEffect:this.removeEdgeEffect,colorRamp:this.colorRamp,colormap:this.colormap,raster:this.raster})}};h([d({json:{write:!0}})],Kt.prototype,"colorRamp",void 0),h([oe("colorRamp")],Kt.prototype,"readColorRamp",null),h([d({type:[[Number]],json:{write:!0}})],Kt.prototype,"colormap",void 0),Kt=ts=h([N("esri.layers.support.rasterFunctions.ShadedReliefFunctionArguments")],Kt);const Ei=Kt;let ct=class extends z{constructor(){super(...arguments),this.functionName="ShadedRelief",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){const r=this.sourceRasterInfos[0];if(r.bandCount>1)return{success:!1,supportsGPU:!1,error:"shadedrelief-function: source data must be single band"};let{colorRamp:t,colormap:e}=this.functionArguments;if(!t&&!e?.length)return{success:!1,supportsGPU:!1,error:"shadedrelief-function: a color ramp argument must be specified"};this.outputPixelType=this._getOutputPixelType("u8");const s=r.clone();this._removeStatsHistColormapVAT(s),s.pixelType=this.outputPixelType,s.bandCount=3,s.statistics=[{min:0,max:255,avg:60,stddev:10},{min:0,max:255,avg:60,stddev:10},{min:0,max:255,avg:60,stddev:10}],this.rasterInfo=s,this.isGCS=s.spatialReference?.isGeographic??!1,e?.length||(e=Se(t,{interpolateAlpha:!0}));const{indexedColormap:o,offset:n}=tn({colormap:e});if(!o?.length)return{success:!1,supportsGPU:!1,error:"shadedrelief-function: a valid colorramp is required"};const a=Wn(o);return this.lookup={indexedColormap:o,offset:n,hsvMap:a},{success:!0,supportsGPU:en(o)}}_processPixels(r){const t=r.pixelBlocks?.[0];if(!t||!this.lookup)return null;let e=r.primaryPixelSizes?.[0];if(e==null){const{extent:a}=r;e=a?{x:a.width/t.width,y:a.height/t.height}:{x:1,y:1}}const s=ge(this.functionArguments,e,this.isGCS),o=nn(t,s),n=this.sourceRasterInfos[0].statistics?.[0]??{min:0,max:8e3};return qn(o,t,this.lookup.hsvMap,n),o.pixelType=this.outputPixelType,o}_getWebGLParameters(){const r=ge(this.functionArguments,{x:1,y:1},this.isGCS),t=rn(r),{slopeType:e,zFactor:s,pixelSizeFactor:o,pixelSizePower:n}=this.functionArguments,a=e==="scaled",{indexedColormap:i,offset:u}=this.lookup,l=this.sourceRasterInfos[0].statistics?.[0],c=W(this.outputPixelType);return{...t,indexedColormap:i,offset:u,zFactor:s,gcsFactor:this.isGCS?ie:1,pixelSizeFactor:a?o:0,pixelSizePower:a?n:0,minValue:l?.min??0,maxValue:l?.max??8e3,isOutputRounded:c}}};h([d({json:{write:!0,name:"rasterFunction"}})],ct.prototype,"functionName",void 0),h([d({type:Ei,json:{write:!0,name:"rasterFunctionArguments"}})],ct.prototype,"functionArguments",void 0),h([d()],ct.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],ct.prototype,"isGCS",void 0),h([d({json:{write:!0}})],ct.prototype,"lookup",void 0),ct=h([N("esri.layers.support.rasterFunctions.ShadedReliefFunction")],ct);const Oi=ct;var es;const Di=new rt({1:"degree",2:"percent-rise",3:"adjusted"},{useNumericKeys:!0});let pt=es=class extends O{constructor(){super(...arguments),this.slopeType="degree",this.zFactor=1,this.pixelSizePower=.664,this.pixelSizeFactor=.024,this.removeEdgeEffect=!1}clone(){return new es({slopeType:this.slopeType,zFactor:this.zFactor,pixelSizePower:this.pixelSizePower,pixelSizeFactor:this.pixelSizeFactor,removeEdgeEffect:this.removeEdgeEffect,raster:this.raster})}};h([nt(Di)],pt.prototype,"slopeType",void 0),h([d({type:Number,json:{write:!0}})],pt.prototype,"zFactor",void 0),h([d({type:Number,json:{name:"psPower",write:!0}})],pt.prototype,"pixelSizePower",void 0),h([d({type:Number,json:{name:"psZFactor",write:!0}})],pt.prototype,"pixelSizeFactor",void 0),h([d({type:Boolean,json:{write:!0}})],pt.prototype,"removeEdgeEffect",void 0),pt=es=h([N("esri.layers.support.rasterFunctions.SlopeFunctionArguments")],pt);const Vi=pt;let It=class extends z{constructor(){super(...arguments),this.functionName="Slope",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0].clone();return t.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(t),t.statistics=this.functionArguments.slopeType!=="percent-rise"?[{min:0,max:90,avg:1,stddev:1}]:null,t.bandCount=1,this.rasterInfo=t,this.isGCS=t.spatialReference?.isGeographic??!1,{success:!0,supportsGPU:!0}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return null;const{zFactor:s,slopeType:o,pixelSizePower:n,pixelSizeFactor:a}=this.functionArguments,{isGCS:i}=this,{extent:u,primaryPixelSizes:l}=t,c=l?.[0],p=c??(u?{x:u.width/e.width,y:u.height/e.height}:{x:1,y:1});return Hn(e,{zFactor:s,slopeType:o,pixelSizePower:n,pixelSizeFactor:a,isGCS:i,resolution:p})}_getWebGLParameters(){const{zFactor:t,slopeType:e,pixelSizeFactor:s,pixelSizePower:o}=this.functionArguments;return{zFactor:this.isGCS&&t>=1?t*ie:t,slopeType:e,pixelSizeFactor:s??0,pixelSizePower:o??0,isOutputRounded:W(this.outputPixelType)}}};h([d({json:{write:!0,name:"rasterFunction"}})],It.prototype,"functionName",void 0),h([d({type:Vi,json:{write:!0,name:"rasterFunctionArguments"}})],It.prototype,"functionArguments",void 0),h([d()],It.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],It.prototype,"isGCS",void 0),It=h([N("esri.layers.support.rasterFunctions.SlopeFunction")],It);const Ui=It,Ls=new rt({1:"min",2:"max",3:"mean",4:"stddev",5:"median",6:"majority",7:"minority"},{useNumericKeys:!0});function Li(r,t){const{fillNoDataOnly:e}=t,{band:s,width:o,height:n,mask:a,outBand:i}=r;if(e&&!a)return void i.set(s);const{statisticsType:u,kernelRows:l,kernelCols:c}=t,p=u==="stddev",m=o*n,f=new Float64Array(m),g=new Float64Array(m),x=new Uint32Array(m);for(let T=0;T<n;T++){const R=T*o;let F=0,k=0,I=0;for(let S=0;S<c;S++)a&&!a[R+S]||(F+=s[R+S],p&&(k+=s[R+S]**2),I++);f[R]=F,g[R]=k,x[R]=I;for(let S=1;S<=o-c;S++){const B=R+S-1,X=B+c;a?(a[B]&&(I--,F-=s[B],p&&(k-=s[B]**2)),a[X]&&(I++,F+=s[X],p&&(k+=s[X]**2))):(F-=s[B],F+=s[X],p&&(k-=s[B]**2,k+=s[X]**2)),f[R+S]=F,x[R+S]=I,p&&(g[R+S]=k)}}const y=new Float64Array(m),v=new Float64Array(m),w=new Uint32Array(m),A=l*o;for(let T=0;T<=o-c;T++){let R=0,F=0,k=0;for(let I=0;I<l;I++){const S=I*o+T;R+=f[S],k+=x[S],p&&(F+=g[S])}y[T]=R,v[T]=F,w[T]=k;for(let I=1;I<=n-l;I++){const S=(I-1)*o+T,B=S+A;R-=f[S],R+=f[B],k-=x[S],k+=x[B],p&&(F-=g[S],F+=g[B]),y[I*o+T]=R,v[I*o+T]=F,w[I*o+T]=k}}const b=Math.floor(l/2),P=Math.floor(c/2);for(let T=b;T<n-b;T++){const R=T*o;for(let F=P;F<o-P;F++){const k=(T-b)*o+F-P,I=w[k];if(I===0||e&&(!a||a[R+F]))continue;const S=y[k]/I,B=p?Math.sqrt((v[k]-y[k]*S)/I):S;i[R+F]=B,a&&(a[R+F]=255)}}}function Wi(r,t){const{fillNoDataOnly:e}=t,{band:s,width:o,height:n,mask:a,outBand:i}=r;if(e&&!a)return void i.set(s);const{kernelRows:u,kernelCols:l,statisticsType:c}=t,p=Math.floor(u/2),m=Math.floor(l/2),f=c==="min",g=i.slice(),x=new Uint32Array(o*n);for(let y=p;y<n-p;y++){const v=y*o;for(let w=m;w<o-m;w++){let A=f?Number.MAX_VALUE:-Number.MAX_VALUE,b=0;for(let P=0;P<u;P++)for(let T=0;T<l;T++){const R=v+w+(P-p)*o+T-m;a&&!a[R]||(A=f?Math.min(A,s[R]):Math.max(A,s[R]),b++)}a?(g[v+w]=b===0?0:A,x[v+w]=b):i[v+w]=b===0?0:A}}if(a)for(let y=p;y<n-p;y++){const v=y*o;for(let w=m;w<o-m;w++)if(x[v+w]){if(e&&a[v+w])continue;i[v+w]=g[v+w],a[v+w]=255}}}function qi(r,t){const{fillNoDataOnly:e}=t,{band:s,width:o,height:n,mask:a,outBand:i}=r;if(e&&!a)return void i.set(s);const{kernelRows:u,kernelCols:l}=t,c=Math.floor(u/2),p=Math.floor(l/2),m=i.slice(),f=new Uint32Array(o*n);for(let g=c;g<n-c;g++){const x=g*o;for(let y=p;y<o-p;y++){if(e&&a?.[x+y])continue;const v=[];for(let w=0;w<u;w++)for(let A=0;A<l;A++){const b=x+y+(w-c)*o+A-p;a&&!a[b]||v.push(s[b])}v.length&&(v.sort((w,A)=>w-A),a?(m[x+y]=v[Math.floor((v.length-1)/2)],f[x+y]=v.length):i[x+y]=v[Math.floor((v.length-1)/2)])}}if(a)for(let g=c;g<n-c;g++){const x=g*o;for(let y=p;y<o-p;y++)if(f[x+y]){if(e&&a[x+y])continue;i[x+y]=m[x+y],a[x+y]=255}}}function Hi(r,t){const{fillNoDataOnly:e}=t,{band:s,width:o,height:n,mask:a,outBand:i}=r;if(e&&!a)return void i.set(s);const{kernelRows:u,kernelCols:l}=t,c=Math.floor(u/2),p=Math.floor(l/2),m=t.statisticsType==="majority",f=u*l,g=i.slice(),x=new Uint32Array(o*n);for(let y=c;y<n-c;y++){const v=y*o;for(let w=p;w<o-p;w++){if(e&&a?.[v+w])continue;const A=new Map;for(let R=0;R<u;R++)for(let F=0;F<l;F++){const k=v+w+(R-c)*o+F-p;if(a&&!a[k])continue;const I=s[k];A.set(I,A.has(I)?A.get(I)+1:1)}if(A.size===0)continue;let b=0,P=0,T=m?0:f+1;for(const R of A.keys())P=A.get(R),m===P>T&&(T=P,b=R);a?(g[v+w]=b,x[v+w]=A.size):i[v+w]=b}}if(a)for(let y=c;y<n-c;y++){const v=y*o;for(let w=p;w<o-p;w++)if(x[v+w]){if(e&&a[v+w])continue;i[v+w]=g[v+w],a[v+w]=255}}}function Ji(r,t){const{mask:e}=r,{fillNoDataOnly:s}=t;if(s&&!e)return r;const{pixels:o,width:n,height:a,bandMasks:i,pixelType:u}=r,l=o.length,c=n*a,p=[],{kernelRows:m,kernelCols:f,statisticsType:g,mirrorEdges:x}=t;if(s&&!e)return r;const y=t.outputPixelType??u,v=[];for(let b=0;b<l;b++){const P=o[b],T=$.createEmptyBand(y,c);s&&T.set(P);const R=i?.[b]??e,F=R?.slice()??null,k={band:P,width:n,height:a,mask:F,outBand:T};switch(g){case"min":case"max":Wi(k,t);break;case"mean":case"stddev":Li(k,t);break;case"median":qi(k,t);break;case"majority":case"minority":Hi(k,t)}x&&!s&&fs(T,n,a,m,f),p.push(T),F&&v.push(F)}let w=v[0]??e;v.length!==l&&(v.length=0),l>1&&i?.length&&(w=$.combineBandMasks(i));const A=new $({pixelType:y,width:n,height:a,pixels:p,bandMasks:i&&v.length?v:null,mask:w});return A.updateStatistics(),A}var ss;let _t=ss=class extends O{constructor(){super(...arguments),this.rows=3,this.cols=3,this.fillNoDataOnly=!1,this.statisticsType="min"}clone(){return new ss({rows:this.rows,cols:this.cols,fillNoDataOnly:this.fillNoDataOnly,statisticsType:this.statisticsType,raster:J(this.raster)})}};h([d({json:{write:!0,read:{source:["kernelRows","rows"],reader:(r,t)=>Number(r??t?.kernelRows??3)}}})],_t.prototype,"rows",void 0),h([d({json:{write:!0,read:{source:["kernelCols","cols"],reader:(r,t)=>Number(r??t?.kernelCols??3)}}})],_t.prototype,"cols",void 0),h([d({json:{write:!0}})],_t.prototype,"fillNoDataOnly",void 0),h([d({json:{read:{source:["statisticsType","type"],reader:(r,t)=>Ls.fromJSON(t?.statisticsType??t?.type)??"min"},write:{target:"type"}}}),nt(Ls)],_t.prototype,"statisticsType",void 0),_t=ss=h([N("esri.layers.support.rasterFunctions.StatisticsFunctionArguments")],_t);const Ki=_t;let Xt=class extends z{constructor(){super(...arguments),this.functionName="Statistics",this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{type:t}=this.functionArguments.toJSON();if(t<1||t>7)return{success:!1,supportsGPU:!1,error:`statistics-function: the given statistics type is not supported ${t}`};const e=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(e.pixelType);const s=e.clone();s.pixelType=this.outputPixelType;const{statisticsType:o}=this.functionArguments;return o==="stddev"&&this._removeStatsHistColormapVAT(s),this.rasterInfo=s,{success:!0,supportsGPU:s.bandCount<=3&&t<5}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return e;const{statisticsType:s,rows:o,cols:n,fillNoDataOnly:a}=this.functionArguments;return Ji(e,{kernelRows:o,kernelCols:n,fillNoDataOnly:a,outputPixelType:this.outputPixelType,statisticsType:s,mirrorEdges:!0})}_getWebGLParameters(){const{rows:t,cols:e,statisticsType:s,fillNoDataOnly:o}=this.functionArguments;return{fillNoDataOnly:o,kernelRows:t,kernelCols:e,statisticsType:s,clampRange:ft(this.outputPixelType)}}};h([d({json:{write:!0,name:"rasterFunction"}})],Xt.prototype,"functionName",void 0),h([d({type:Ki,json:{write:!0,name:"rasterFunctionArguments"}})],Xt.prototype,"functionArguments",void 0),h([d()],Xt.prototype,"rasterArgumentNames",void 0),Xt=h([N("esri.layers.support.rasterFunctions.StatisticsFunction")],Xt);const Xi=Xt;var ns;let St=ns=class extends O{constructor(){super(...arguments),this.statistics=null,this.histograms=null}readStatistics(r,t){if(!r?.length)return null;const e=[];return r.forEach(s=>{const o={min:s.min,max:s.max,avg:s.avg??s.mean,stddev:s.stddev??s.standardDeviation};e.push(o)}),e}writeStatistics(r,t,e){if(!r?.length)return;const s=[];r.forEach(o=>{const n={...o,mean:o.avg,standardDeviation:o.stddev};delete n.avg,delete n.stddev,s.push(n)}),t[e]=s}clone(){return new ns({statistics:J(this.statistics),histograms:J(this.histograms)})}};h([d({json:{write:!0}})],St.prototype,"statistics",void 0),h([oe("statistics")],St.prototype,"readStatistics",null),h([Ae("statistics")],St.prototype,"writeStatistics",null),h([d({json:{write:!0}})],St.prototype,"histograms",void 0),St=ns=h([N("esri.layers.support.rasterFunctions.StatisticsHistogramFunctionArguments")],St);const Yi=St;let ht=class extends z{constructor(){super(...arguments),this.functionName="StatisticsHistogram",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const t=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType("u8");const e=t.clone(),{statistics:s,histograms:o}=this.functionArguments;return o&&(e.histograms=o),s&&(e.statistics=s),this.rasterInfo=e,{success:!0,supportsGPU:!0}}_processPixels(t){return t.pixelBlocks?.[0]}};h([d({json:{write:!0,name:"rasterFunction"}})],ht.prototype,"functionName",void 0),h([d({type:Yi,json:{write:!0,name:"rasterFunctionArguments"}})],ht.prototype,"functionArguments",void 0),h([d()],ht.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],ht.prototype,"indexedColormap",void 0),h([d()],ht.prototype,"isNoopProcess",void 0),ht=h([N("esri.layers.support.rasterFunctions.StatisticsHistogramFunction")],ht);const Zi=ht;var rs;const Qi=new rt({0:"none",3:"standard-deviation",4:"histogram-equalization",5:"min-max",6:"percent-clip",9:"sigmoid"},{useNumericKeys:!0});let L=rs=class extends O{constructor(){super(...arguments),this.computeGamma=!1,this.dynamicRangeAdjustment=!1,this.gamma=[],this.histograms=null,this.statistics=null,this.stretchType="none",this.useGamma=!1}writeStatistics(r,t,e){r?.length&&(Array.isArray(r[0])||(r=r.map(s=>[s.min,s.max,s.avg,s.stddev])),t[e]=r)}clone(){return new rs({stretchType:this.stretchType,outputMin:this.outputMin,outputMax:this.outputMax,useGamma:this.useGamma,computeGamma:this.computeGamma,statistics:J(this.statistics),gamma:J(this.gamma),sigmoidStrengthLevel:this.sigmoidStrengthLevel,numberOfStandardDeviations:this.numberOfStandardDeviations,minPercent:this.minPercent,maxPercent:this.maxPercent,histograms:J(this.histograms),dynamicRangeAdjustment:this.dynamicRangeAdjustment,raster:this.raster})}};h([d({type:Boolean,json:{write:!0}})],L.prototype,"computeGamma",void 0),h([d({type:Boolean,json:{name:"dra",write:!0}})],L.prototype,"dynamicRangeAdjustment",void 0),h([d({type:[Number],json:{write:!0}})],L.prototype,"gamma",void 0),h([d()],L.prototype,"histograms",void 0),h([d({type:Number,json:{write:!0}})],L.prototype,"maxPercent",void 0),h([d({type:Number,json:{write:!0}})],L.prototype,"minPercent",void 0),h([d({type:Number,json:{write:!0}})],L.prototype,"numberOfStandardDeviations",void 0),h([d({type:Number,json:{name:"max",write:!0}})],L.prototype,"outputMax",void 0),h([d({type:Number,json:{name:"min",write:!0}})],L.prototype,"outputMin",void 0),h([d({type:Number,json:{write:!0}})],L.prototype,"sigmoidStrengthLevel",void 0),h([d({json:{type:[[Number]],write:!0}})],L.prototype,"statistics",void 0),h([Ae("statistics")],L.prototype,"writeStatistics",null),h([nt(Qi)],L.prototype,"stretchType",void 0),h([d({type:Boolean,json:{write:!0}})],L.prototype,"useGamma",void 0),L=rs=h([N("esri.layers.support.rasterFunctions.StretchFunctionArguments")],L);const ta=L;let mt=class extends z{constructor(){super(...arguments),this.functionName="Stretch",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null,this.cutOffs=null}_bindSourceRasters(){this.lookup=null,this.cutOffs=null;const t=this.sourceRasterInfos[0],{pixelType:e}=t,{functionArguments:s}=this,{dynamicRangeAdjustment:o,gamma:n,useGamma:a}=s;if(!o&&["u8","u16","s8","s16"].includes(e)){const c=Re(s.toJSON(),{rasterInfo:t}),p=W(this.outputPixelType)?"round":"float";this.lookup=Jn({pixelType:e,...c,gamma:a?n:null,rounding:p}),this.cutOffs=c}else o||(this.cutOffs=Re(s.toJSON(),{rasterInfo:t}));this.outputPixelType=this._getOutputPixelType(e);const i=t.clone();i.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(i),this.outputPixelType==="u8"&&(i.keyProperties.DataType="processed");const{outputMin:u=0,outputMax:l=255}=this.functionArguments;i.statistics=[];for(let c=0;c<i.bandCount;c++)i.statistics[c]={min:u,max:l};return this.rasterInfo=i,{success:!0,supportsGPU:!o}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return e;const{lookup:s}=this;if(s)return ls(e,{...s,outputPixelType:this.rasterInfo.pixelType});const{functionArguments:o}=this,n=this.cutOffs||Re(o.toJSON(),{rasterInfo:this.sourceRasterInfos[0],pixelBlock:e}),a=o.useGamma?o.gamma:null;return Kn(e,{...n,gamma:a,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const{outputMin:t=0,outputMax:e=255,gamma:s,useGamma:o}=this.functionArguments,n=this.rasterInfo.bandCount>=2?3:1,a=o&&s?.length?Xn(n,s):[1,1,1],{minCutOff:i,maxCutOff:u}=this.cutOffs??{minCutOff:[0,0,0],maxCutOff:[255,255,255]};i.length===1&&(i[1]=i[2]=i[0],u[1]=u[2]=u[0]);const l=u.map((f,g)=>(e-t)/(u[g]-i[g])),c=W(this.outputPixelType),p=o&&s?[s[0],s[1]??s[0],s[2]??s[0]]:[1,1,1],m=o?[a[0],a[1]??a[0],a[2]??a[0]]:[1,1,1];return{bandCount:n,minOutput:t,maxOutput:e,minCutOff:i,maxCutOff:u,factor:l,useGamma:o,gamma:p,gammaCorrection:m,stretchType:this.functionArguments.stretchType,isOutputRounded:c,type:"stretch"}}};h([d({json:{write:!0,name:"rasterFunction"}})],mt.prototype,"functionName",void 0),h([d({type:ta,json:{write:!0,name:"rasterFunctionArguments"}})],mt.prototype,"functionArguments",void 0),h([d()],mt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],mt.prototype,"lookup",void 0),h([d({json:{write:!0}})],mt.prototype,"cutOffs",void 0),mt=h([N("esri.layers.support.rasterFunctions.StretchFunction")],mt);const ea=mt;var os;let fe=os=class extends O{constructor(){super(...arguments),this.attributeTableAsRecordSet=null}clone(){return new os({attributeTableAsRecordSet:J(this.attributeTableAsRecordSet)})}};h([d({json:{write:!0}})],fe.prototype,"attributeTableAsRecordSet",void 0),fe=os=h([N("esri.layers.support.rasterFunctions.TableFunctionArguments")],fe);const sa=fe;let Mt=class extends z{constructor(){super(...arguments),this.functionName="Table",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const r=this.sourceRasterInfos[0];if(r.bandCount>1||r.pixelType.startsWith("f"))return{success:!1,supportsGPU:!1,error:"table-function: Source data must be single band and integer pixel type."};const{attributeTableAsRecordSet:t}=this.functionArguments;if(!t)return{success:!1,supportsGPU:!1,error:"table-function: Missing attributeTableAsRecordSet argument."};this.outputPixelType=this._getOutputPixelType(r.pixelType);const e=r.clone();return e.pixelType=this.outputPixelType,e.bandCount=1,e.dataType!=="thematic"&&(e.keyProperties=e.keyProperties?{...e.keyProperties,DataType:"thematic"}:{DataType:"thematic"}),this.rasterInfo=e,{success:!0,supportsGPU:!0}}_processPixels(r){return r.pixelBlocks?.[0]}};h([d({json:{write:!0,name:"rasterFunction"}})],Mt.prototype,"functionName",void 0),h([d({type:sa,json:{write:!0,name:"rasterFunctionArguments"}})],Mt.prototype,"functionArguments",void 0),h([d()],Mt.prototype,"rasterArgumentNames",void 0),h([d()],Mt.prototype,"isNoopProcess",void 0),Mt=h([N("esri.layers.support.rasterFunctions.TableFunction")],Mt);const na=Mt,C=new Map;function ra(r,t){const{rasterFunctionArguments:e}=r;e&&(e.rasters||[e.raster,e.raster2]).forEach(s=>{s&&typeof s!="number"&&(typeof s=="string"?s.startsWith("http")&&(t.includes(s)||t.push(s)):"rasterFunctionArguments"in s&&ra(s,t))})}function Ua(r,t){t=t??{};try{if("function"in(r=J(r))&&"arguments"in r&&r.arguments){const e=wn(r,new Map,t);if(us(e),!e.renderingRule)throw new Gt("raster-function-helper","Unsupported raster function json.");r=e.renderingRule}if("rasterFunction"in r){const e=yn(r=is(r),t);return e.isRoot=!0,e}}catch{}throw new Gt("raster-function-helper","unsupported raster function json.")}function oa(r,t){return t[0]==="rasters"&&Array.isArray(r.rasters)?r.rasters:t.map(e=>r[e])}function Ws(r){return!!(r&&typeof r=="object"&&r.rasterFunction&&r.rasterFunctionArguments)}function is(r){const{rasterFunction:t,rasterFunctionArguments:e}=r,s={};for(const o in e){let n=e[o];const a=o.toLowerCase();if(a==="rasters"&&Array.isArray(n))s.rasters=n.map(i=>Ws(i)?is(i):i);else switch(Ws(n)&&(n=is(n)),a){case"dra":s.dra=n;break;case"pspower":s.psPower=n;break;case"pszfactor":s.psZFactor=n;break;case"bandids":s.bandIds=n;break;default:s[o[0].toLowerCase()+o.slice(1)]=n}}return t!=="Local"||s.rasters?.length||(s.rasters=["$$"]),{...r,rasterFunctionArguments:s}}function yn(r,t){const{rasterFunction:e,rasterFunctionArguments:s}=r,o=r.outputPixelType?.toLowerCase();if(e==null||!C.has(e))throw new Gt("raster-function-helper",`unsupported raster function: ${e}`);const n=C.get(e),a=(typeof n.ctor=="function"?n.ctor:n.ctor.default).fromJSON({...r,outputPixelType:o}),{rasterArgumentNames:i}=a,u=[],l=oa(s,i),c=i[0]==="rasters"||i.length>1,p=[];for(let m=0;m<l.length;m++){const f=l[m];let g;f==null||typeof f=="string"&&f.startsWith("$")?u.push(t?.raster):typeof f=="string"?t[f]&&u.push(t[f]):typeof f!="number"&&"rasterFunction"in f&&(g=yn(f,t),c||(a.functionArguments[i[m]]=g),u.push(g)),c&&p.push(g??f)}if(c&&(i[0]==="rasters"?a.functionArguments.rasters=p:i.forEach((m,f)=>{a.functionArguments[m]=p[f]})),t){a.sourceRasters=u;const m=t.raster?.url;m&&(a.mainPrimaryRasterId=m)}return a}function xn(r,t){if(r&&t)for(const e in r){const s=r[e];s&&typeof s=="object"&&"type"in s&&(s.type==="RasterFunctionTemplate"?xn(s.arguments,t):s.type==="RasterFunctionVariable"&&t[s.name]!=null&&(s.value=t[s.name]))}}function as(r,t){if(!r||typeof r!="object")return r;const{value:e}=r;if(!e||typeof e!="object")return r.isDataset?"$$":e;if(Array.isArray(e))return e.length===0?[]:e.map(o=>o&&typeof o=="object"&&o.type==="RasterFunctionVariable"?as(o,t):o);if("value"in e&&["number","string","boolean"].includes(typeof e.value))return e.value;if(r.isDataset&&e.type!=="Scalar")return"$$";if(!("type"in e))return e;let s=e;switch(e.type){case"Scalar":s=e.value;break;case"AlgorithmicColorRamp":s=qs(e);break;case"MultiPartColorRamp":s={type:"multipart",colorRamps:e.ArrayOfColorRamp.map(qs)};break;case"ArgumentArray":if(e.elements?.length&&e.elements[0].type!=="RasterStatistics"){const o=[];for(let n=0;n<e.elements.length;n++){const a=e.elements[n],{type:i}=a;if(i)if(i==="RasterFunctionTemplate"){const{renderingRule:u}=wn(a,t);o.push(u),a._object_id!=null&&t.set(a._object_id,u)}else{if(i!=="RasterFunctionVariable")throw new Gt("raster-function-helper","unsupported raster function json.");{const u=as(a,t);o.push(u),a._object_id!=null&&t.set(a._object_id,u)}}else o.push(a)}s=o}else s=e.elements}return e._object_id!=null&&t.set(e._object_id,s),s}function qs(r){const t=r.algorithm??"esriHSVAlgorithm";let{FromColor:e,ToColor:s}=r;if(!Array.isArray(e)){const{r:o,g:n,b:a}=gs({h:e.Hue,s:e.Saturation,v:e.Value});e=[o,n,a,e.AlphaValue]}if(!Array.isArray(s)){const{r:o,g:n,b:a}=gs({h:s.Hue,s:s.Saturation,v:s.Value});s=[o,n,a,s.AlphaValue]}return{type:"algorithmic",algorithm:t,fromColor:e,toColor:s}}function wn(r,t,e){e&&xn(r,e);const s={renderingRule:{},templates:t};return bn(r,s),s}function bn(r,t){if(!r||!t.renderingRule)return;const{renderingRule:e,templates:s}=t,{function:o,arguments:n,_object_id:a}=r;if(!o||!n)return;a!=null&&s.set(a,e),e.rasterFunction=o.type.replace("Function",""),e.outputPixelType=o.pixelType;const i={};e.rasterFunctionArguments=i;for(const u in n){if(u==="type"||u==="object_id"||u==="_object_ref_id")continue;const l=n[u];l&&typeof l=="object"&&"type"in l&&(l.type==="RasterFunctionTemplate"||l.type==="RasterFunctionVariable")?(l.type==="RasterFunctionVariable"?i[u]=as(l,s):(e.rasterFunctionArguments[u]={},bn(l,{renderingRule:e.rasterFunctionArguments[u],templates:s})),l._object_id!=null&&s.set(l._object_id,i[u])):i[u]=l}switch(i.DEM&&!i.Raster&&(i.Raster=i.DEM,delete i.DEM),e.rasterFunction){case"Stretch":ia(i);break;case"Colormap":aa(i);break;case"Convolution":ua(i);break;case"Mask":la(i)}}function us(r){const{renderingRule:t,templates:e}=r;if(typeof t!="object"||!t?.rasterFunctionArguments||!e.size)return;const{rasterFunctionArguments:s}=t;for(const o in s){const n=s[o],a=o==="_object_ref_id"?n:n&&typeof n=="object"&&"_object_ref_id"in n?n._object_ref_id:null;if(a==null)n&&typeof n=="object"&&(n.rasterFunctionArguments&&us({renderingRule:n,templates:e}),Array.isArray(n)&&n.forEach((i,u)=>{if(i&&typeof i=="object")if(i._object_ref_id!=null){if(!e.has(i._object_ref_id))throw new Gt("raster-function-helper",`unsupported raster function json. _object_ref_id: ${n} does not exist`);const l=e.get(a);l&&typeof l=="object"?Object.assign(i,l):n[u]=l}else us({renderingRule:i,templates:e})}));else{if(!e.has(a))throw new Gt("raster-function-helper",`unsupported raster function json. _object_ref_id: ${a} does not exist`);const i=e.get(a);o!=="_object_ref_id"?s[o]=i:i&&typeof i=="object"&&Object.assign(s,i)}}}function ia(r){r.Statistics?.length&&typeof r.Statistics=="object"&&(r.Statistics=r.Statistics.map(t=>[t.min,t.max,t.mean,t.standardDeviation])),r.NumberOfStandardDeviation!=null&&(r.NumberOfStandardDeviations=r.NumberOfStandardDeviation,delete r.NumberOfStandardDeviation)}function aa(r){r.ColorRamp?.type?.toLowerCase()==="randomcolorramp"&&(delete r.ColorRamp,r.ColormapName="Random"),r.ColorSchemeType===0&&delete r.ColorRamp}function ua(r){r.ConvolutionType!=null&&(r.Type=r.ConvolutionType,delete r.ConvolutionType)}function la(r){r.NoDataValues?.length&&typeof r.NoDataValues[0]=="string"&&(r.NoDataValues=r.NoDataValues.filter(t=>t!=="").map(t=>Number(t)))}C.set("Arithmetic",{desc:"Arithmetic Function",ctor:Dr,rasterArgumentNames:["rasters"]}),C.set("Aspect",{desc:"Aspect Function",ctor:Ur,rasterArgumentNames:["raster"]}),C.set("BandArithmetic",{desc:"Band Arithmetic Function",ctor:yo,rasterArgumentNames:["raster"]}),C.set("Colormap",{desc:"Colormap Function",ctor:Jo,rasterArgumentNames:["raster"]}),C.set("ColormapToRGB",{desc:"ColormapToRGB Function",ctor:Xo,rasterArgumentNames:["raster"]}),C.set("CompositeBand",{desc:"CompositeBand Function",ctor:Zo,rasterArgumentNames:["rasters"]}),C.set("ComputeChange",{desc:"ComputeChange Function",ctor:ui,rasterArgumentNames:["rasters"]}),C.set("Convolution",{desc:"Convolution Function",ctor:yi,rasterArgumentNames:["raster"]}),C.set("ContrastBrightness",{desc:"Contrast Brightness Function",ctor:ci,rasterArgumentNames:["raster"]}),C.set("ExtractBand",{desc:"ExtractBand Function",ctor:vi,rasterArgumentNames:["raster"]}),C.set("Curvature",{desc:"Curvature Function",ctor:wi,rasterArgumentNames:["raster"]}),C.set("Hillshade",{desc:"Hillshade Function",ctor:Ii,rasterArgumentNames:["raster"]}),C.set("ShadedRelief",{desc:"ShadedRelief Function",ctor:Oi,rasterArgumentNames:["raster"]}),C.set("Grayscale",{desc:"Grayscale Function",ctor:Ni,rasterArgumentNames:["raster"]}),C.set("Clip",{desc:"Clip Function",ctor:zo,rasterArgumentNames:["raster"]}),C.set("Local",{desc:"Local Function",ctor:Si,rasterArgumentNames:["rasters"]}),C.set("Mask",{desc:"Mask Function",ctor:Ci,rasterArgumentNames:["raster"]}),C.set("NDVI",{desc:"NDVI Function",ctor:ji,rasterArgumentNames:["raster"]}),C.set("Remap",{desc:"Remap Function",ctor:zi,rasterArgumentNames:["raster"]}),C.set("Slope",{desc:"Slope Function",ctor:Ui,rasterArgumentNames:["raster"]}),C.set("Statistics",{desc:"Focal Statistics Function",ctor:Xi,rasterArgumentNames:["raster"]}),C.set("StatisticsHistogram",{desc:"Statistics Histogram Function",ctor:Zi,rasterArgumentNames:["raster"]}),C.set("Stretch",{desc:"Stretch Function",ctor:ea,rasterArgumentNames:["raster"]}),C.set("Table",{desc:"Attribute Table Function",ctor:na,rasterArgumentNames:["raster"]});export{js as A,fn as Q,Ua as T,Co as V,ba as _,ut as e,Pa as f,va as i,jo as o,Ro as p,xa as r,Aa as s,Ta as u,wa as v,ra as w};
