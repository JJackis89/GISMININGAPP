import{r as t,m as i,kl as le,a as j,l as P,dm as ue,km as Ze,kn as Bt,dk as He,dn as Ft,bf as F,bd as Q,Z as f,d as U,p as Y,s as We,H as fe,j0 as Qe,ic as Lt,g as St,am as et,a9 as Mt,M as Me,N as me,ay as G,z as Nt,dQ as re,f as ae,L as Ot,ko as Pt,fv as ce,kp as he,P as Rt,bh as Jt,az as Et,e as $t,aM as W,da as xt,de as kt,dc as Ut,dd as Wt,df as _t,ct as Vt,al as Gt,O as qt,cw as yt,k as mt,id as zt,bA as Zt,a1 as Ht,C as Yt,G as Kt,bl as Xt,fQ as Qt,d2 as er,d3 as tr,dU as rr,dp as ir}from"./index-f00bd99f.js";import{i as or}from"./originUtils-5a133ae6.js";import{D as z,U as ze,n as sr,b as ar,w as _e,y as nr,r as Dt,h as lr,m as It,a as Ct,c as ur,q as pr,S as Ve,k as Ge,N as q,p as k,g as je,A as pe,T as qe,R as cr,M as dr,o as yr,f as mr,l as hr,v as Ae}from"./GPMessage-1d5cd9af.js";import{R as fr}from"./normalizeUtils-e6e5ded6.js";import{t as br}from"./commonProperties-da958896.js";import"./normalizeUtilsCommon-3a54feae.js";let te=class extends P{constructor(e){super(e),this.break=new ue({color:[255,255,255],size:12,outline:{color:[0,122,194],width:3}}),this.first=new ue({color:[0,255,0],size:20,outline:{color:[255,255,255],width:4}}),this.unlocated=new ue({color:[255,0,0],size:12,outline:{color:[255,255,255],width:3}}),this.last=new ue({color:[255,0,0],size:20,outline:{color:[255,255,255],width:4}}),this.middle=new ue({color:[51,51,51],size:12,outline:{color:[0,122,194],width:3}}),this.waypoint=new ue({color:[255,255,255],size:12,outline:{color:[0,122,194],width:3}})}};t([i({types:le})],te.prototype,"break",void 0),t([i({types:le})],te.prototype,"first",void 0),t([i({types:le})],te.prototype,"unlocated",void 0),t([i({types:le})],te.prototype,"last",void 0),t([i({types:le})],te.prototype,"middle",void 0),t([i({types:le})],te.prototype,"waypoint",void 0),te=t([j("esri.layers.support.RouteStopSymbols")],te);let X=class extends P{constructor(e){super(e),this.directionLines=new He({color:[0,122,194],width:6}),this.directionPoints=new ue({color:[255,255,255],size:6,outline:{color:[0,122,194],width:2}}),this.pointBarriers=new ue({style:"x",size:10,outline:{color:[255,0,0],width:3}}),this.polygonBarriers=new Ft({color:[255,170,0,.6],outline:{width:7.5,color:[255,0,0,.6]}}),this.polylineBarriers=new He({width:7.5,color:[255,85,0,.7]}),this.routeInfo=new He({width:8,color:[20,89,127]}),this.stops=new te}};t([i({types:Ze})],X.prototype,"directionLines",void 0),t([i({types:le})],X.prototype,"directionPoints",void 0),t([i({types:le})],X.prototype,"pointBarriers",void 0),t([i({types:Bt})],X.prototype,"polygonBarriers",void 0),t([i({types:Ze})],X.prototype,"polylineBarriers",void 0),t([i({types:Ze})],X.prototype,"routeInfo",void 0),t([i({type:te})],X.prototype,"stops",void 0),X=t([j("esri.layers.support.RouteSymbols")],X);let K=class extends P{constructor(e){super(e),this.dataType=null,this.name=null,this.parameterNames=null,this.restrictionUsageParameterName=null,this.timeNeutralAttributeName=null,this.trafficSupport=null,this.units=null,this.usageType=null}};t([i({type:String})],K.prototype,"dataType",void 0),t([F(z,{ignoreUnknown:!1})],K.prototype,"name",void 0),t([i({type:[String]})],K.prototype,"parameterNames",void 0),t([i({type:String})],K.prototype,"restrictionUsageParameterName",void 0),t([F(ze,{ignoreUnknown:!1})],K.prototype,"timeNeutralAttributeName",void 0),t([i({type:String})],K.prototype,"trafficSupport",void 0),t([F(sr)],K.prototype,"units",void 0),t([F(ar)],K.prototype,"usageType",void 0),K=t([j("esri.rest.support.NetworkAttribute")],K);const vr=K;let ne=class extends P{constructor(e){super(e),this.buildTime=null,this.name=null,this.networkAttributes=null,this.networkSources=null,this.state=null}};t([i({type:Number})],ne.prototype,"buildTime",void 0),t([i({type:String})],ne.prototype,"name",void 0),t([i({type:[vr]})],ne.prototype,"networkAttributes",void 0),t([i()],ne.prototype,"networkSources",void 0),t([i({type:String})],ne.prototype,"state",void 0),ne=t([j("esri.rest.support.NetworkDataset")],ne);const Tr=ne;let M=class extends Q.ClonableMixin(P){constructor(e){super(e),this.attributeParameterValues=null,this.description=null,this.distanceAttributeName=null,this.id=null,this.impedanceAttributeName=null,this.name=null,this.restrictionAttributeNames=null,this.simplificationTolerance=null,this.simplificationToleranceUnits=null,this.timeAttributeName=null,this.type=null,this.useHierarchy=null,this.uturnAtJunctions=null}readId(e,r){return r.id??r.itemId??null}readRestrictionAttributes(e,r){const{restrictionAttributeNames:s}=r;return s==null?null:s.map(a=>_e.fromJSON(a))}writeRestrictionAttributes(e,r,s){e!=null&&(r[s]=e.map(a=>_e.toJSON(a)))}};t([i({type:[Object],json:{write:!0}})],M.prototype,"attributeParameterValues",void 0),t([i({type:String,json:{write:!0}})],M.prototype,"description",void 0),t([F(nr,{ignoreUnknown:!1})],M.prototype,"distanceAttributeName",void 0),t([i({type:String,json:{write:!0}})],M.prototype,"id",void 0),t([f("id",["id","itemId"])],M.prototype,"readId",null),t([F(z,{ignoreUnknown:!1})],M.prototype,"impedanceAttributeName",void 0),t([i({type:String,json:{write:!0}})],M.prototype,"name",void 0),t([i({type:[String],json:{write:!0}})],M.prototype,"restrictionAttributeNames",void 0),t([f("restrictionAttributeNames")],M.prototype,"readRestrictionAttributes",null),t([U("restrictionAttributeNames")],M.prototype,"writeRestrictionAttributes",null),t([i({type:Number,json:{write:{allowNull:!0}}})],M.prototype,"simplificationTolerance",void 0),t([F(Dt)],M.prototype,"simplificationToleranceUnits",void 0),t([F(ze,{ignoreUnknown:!1})],M.prototype,"timeAttributeName",void 0),t([F(lr)],M.prototype,"type",void 0),t([i({type:Boolean,json:{write:!0}})],M.prototype,"useHierarchy",void 0),t([F(It)],M.prototype,"uturnAtJunctions",void 0),M=t([j("esri.rest.support.TravelMode")],M);let R=class extends P{constructor(e){super(e),this.accumulateAttributeNames=null,this.attributeParameterValues=null,this.currentVersion=null,this.defaultTravelMode=null,this.directionsLanguage=null,this.directionsLengthUnits=null,this.directionsSupportedLanguages=null,this.directionsTimeAttribute=null,this.hasZ=null,this.impedance=null,this.networkDataset=null,this.supportedTravelModes=null}readAccumulateAttributes(e){return e==null?null:e.map(r=>z.fromJSON(r))}writeAccumulateAttributes(e,r,s){e?.length&&(r[s]=e.map(a=>z.toJSON(a)))}get capabilities(){return{supportsNow:(this.currentVersion??10)>=10.81}}readDefaultTravelMode(e,r){const s=r.supportedTravelModes?.find(({id:a})=>a===r.defaultTravelMode)??r.supportedTravelModes?.find(({itemId:a})=>a===r.defaultTravelMode);return s?M.fromJSON(s):null}};t([i()],R.prototype,"accumulateAttributeNames",void 0),t([f("accumulateAttributeNames")],R.prototype,"readAccumulateAttributes",null),t([U("accumulateAttributeNames")],R.prototype,"writeAccumulateAttributes",null),t([i()],R.prototype,"attributeParameterValues",void 0),t([i()],R.prototype,"capabilities",null),t([i()],R.prototype,"currentVersion",void 0),t([i()],R.prototype,"defaultTravelMode",void 0),t([f("defaultTravelMode",["defaultTravelMode","supportedTravelModes"])],R.prototype,"readDefaultTravelMode",null),t([i()],R.prototype,"directionsLanguage",void 0),t([F(Ct)],R.prototype,"directionsLengthUnits",void 0),t([i()],R.prototype,"directionsSupportedLanguages",void 0),t([F(ze,{ignoreUnknown:!1})],R.prototype,"directionsTimeAttribute",void 0),t([i()],R.prototype,"hasZ",void 0),t([F(z,{ignoreUnknown:!1})],R.prototype,"impedance",void 0),t([i({type:Tr})],R.prototype,"networkDataset",void 0),t([i({type:[M]})],R.prototype,"supportedTravelModes",void 0),R=t([j("esri.rest.support.NetworkServiceDescription")],R);const gr=()=>et.getLogger("esri.rest.networkService");function Pe(o,e,r,s){s[r]=[e.length,e.length+o.length],o.forEach(a=>{e.push(a.geometry)})}function wr(o,e){for(let r=0;r<e.length;r++){const s=o[e[r]];if(s&&s.length)for(const a of s)a.z=void 0}gr().warnOnce(`The remote Network Analysis service is powered by a network dataset which is not Z-aware.
Z-coordinates of the input geometry are ignored.`)}function Sr(o,e){for(let r=0;r<e.length;r++){const s=o[e[r]];if(s&&s.length){for(const a of s)if(a!=null&&a.hasZ)return!0}}return!1}async function jt(o,e,r){if(!o)throw new Y("network-service:missing-url","Url to Network service is missing");const s=We({f:"json",token:e},r),{data:a}=await fe(o,s),c=a.currentVersion>=10.4?Or(o,e,r):Nr(o,r),{defaultTravelMode:n,supportedTravelModes:y}=await c;return a.defaultTravelMode=n,a.supportedTravelModes=y,R.fromJSON(a)}async function Nr(o,e){const r=We({f:"json"},e),{data:s}=await fe(o.replace(/\/rest\/.*$/i,"/info"),r);if(!s?.owningSystemUrl)return{supportedTravelModes:[],defaultTravelMode:null};const{owningSystemUrl:a}=s,c=Qe(a)+"/sharing/rest/portals/self",{data:n}=await fe(c,r),y=Lt("helperServices.routingUtilities.url",n);if(!y)return{supportedTravelModes:[],defaultTravelMode:null};const O=St(a),A=/\/solve$/i.test(O.path)?"Route":/\/solveclosestfacility$/i.test(O.path)?"ClosestFacility":"ServiceAreas",h=We({f:"json",serviceName:A},e),l=Qe(y)+"/GetTravelModes/execute",T=await fe(l,h),C=[];let w=null;if(T?.data?.results?.length){const D=T.data.results;for(const m of D)if(m.paramName==="supportedTravelModes"){if(m.value?.features){for(const{attributes:S}of m.value.features)if(S){const v=JSON.parse(S.TravelMode);C.push(v)}}}else m.paramName==="defaultTravelMode"&&(w=m.value)}return{supportedTravelModes:C,defaultTravelMode:w}}async function Or(o,e,r){try{const s=We({f:"json",token:e},r),a=Qe(o)+"/retrieveTravelModes",{data:{supportedTravelModes:c,defaultTravelMode:n}}=await fe(a,s);return{supportedTravelModes:c,defaultTravelMode:n}}catch(s){throw new Y("network-service:retrieveTravelModes","Could not get to the NAServer's retrieveTravelModes.",{error:s})}}function ie(o,e){if(o==null)return null;const r={},s=new RegExp(`^${e}`,"i");for(const a of Object.keys(o))if(s.test(a)){const c=a.slice(e.length);r[z.fromJSON(c)]=o[a]}return r}function ct(o,e,r){if(o!=null){e.attributes||(e.attributes={});for(const s in o){const a=z.toJSON(s);e.attributes[`${r}${a}`]=o[s]}}}function be(o){const e={};for(const r of Object.keys(o)){const s=r;e[z.fromJSON(s)]=o[r]}return e}function ve(o){const e={};for(const r of Object.keys(o)){const s=r;e[z.toJSON(s)]=o[r]}return e}function Be(o,e){return o==null||e==null?null:Math.round((o-e)/6e4)}function Dr(o){const e=o.toJSON(),r=e;return r.accumulateAttributeNames&&(r.accumulateAttributeNames=e.accumulateAttributeNames?.join()),r.attributeParameterValues&&(r.attributeParameterValues=JSON.stringify(e.attributeParameterValues)),r.barriers&&(r.barriers=JSON.stringify(e.barriers)),r.outSR&&(r.outSR=e.outSR?.wkid),r.overrides&&(r.overrides=JSON.stringify(e.overrides)),r.polygonBarriers&&(r.polygonBarriers=JSON.stringify(e.polygonBarriers)),r.polylineBarriers&&(r.polylineBarriers=JSON.stringify(e.polylineBarriers)),r.restrictionAttributeNames&&(r.restrictionAttributeNames=e.restrictionAttributeNames?.join()),r.stops&&(r.stops=JSON.stringify(e.stops)),r.travelMode&&(r.travelMode=JSON.stringify(e.travelMode)),r}const ht=new Mt({0:"informative",1:"process-definition",2:"process-start",3:"process-stop",50:"warning",100:"error",101:"empty",200:"abort"});let ke=class extends ur{constructor(e){super(e),this.type=null}};t([i({type:String,json:{read:ht.read,write:ht.write}})],ke.prototype,"type",void 0),ke=t([j("esri.rest.support.NAMessage")],ke);const Ir=ke;let Ie=class extends P{constructor(e){super(e)}};t([i({json:{read:{source:"string"}}})],Ie.prototype,"text",void 0),t([F(pr,{name:"stringType"})],Ie.prototype,"type",void 0),Ie=t([j("esri.rest.support.DirectionsString")],Ie);const At=Ie;let se=class extends P{constructor(e){super(e),this.arriveTime=null,this.arriveTimeOffset=null,this.geometry=null,this.strings=null}readArriveTimeOffset(e,r){return Be(r.ETA,r.arriveTimeUTC)}readGeometry(e,r){return Me.fromJSON(r.point)}};t([i({type:Date,json:{read:{source:"arriveTimeUTC"}}})],se.prototype,"arriveTime",void 0),t([i()],se.prototype,"arriveTimeOffset",void 0),t([f("arriveTimeOffset",["arriveTimeUTC","ETA"])],se.prototype,"readArriveTimeOffset",null),t([i({type:Me})],se.prototype,"geometry",void 0),t([f("geometry",["point"])],se.prototype,"readGeometry",null),t([i({type:[At]})],se.prototype,"strings",void 0),se=t([j("esri.rest.support.DirectionsEvent")],se);const Cr=se;function jr(o){if(o==null||o==="")return null;let e=0,r=0,s=0,a=0;const c=[];let n,y,O,A,h,l,T,C,w=0,D=0,m=0;if(h=o.match(/((\+|-)[^+\-|]+|\|)/g),h||(h=[]),parseInt(h[w],32)===0){w=2;const S=parseInt(h[w],32);w++,l=parseInt(h[w],32),w++,1&S&&(D=h.indexOf("|")+1,T=parseInt(h[D],32),D++),2&S&&(m=h.indexOf("|",D)+1,C=parseInt(h[m],32),m++)}else l=parseInt(h[w],32),w++;for(;w<h.length&&h[w]!=="|";){n=parseInt(h[w],32)+e,w++,e=n,y=parseInt(h[w],32)+r,w++,r=y;const S=[n/l,y/l];D&&(A=parseInt(h[D],32)+s,D++,s=A,S.push(A/T)),m&&(O=parseInt(h[m],32)+a,m++,a=O,S.push(O/C)),c.push(S)}return{paths:[c],hasZ:D>0,hasM:m>0}}let ye=class extends G{constructor(e){super(e),this.events=null,this.geometry=null,this.strings=null}readGeometry(e,r){const s=jr(r.compressedGeometry);return s!=null?me.fromJSON(s):null}};t([i({type:[Cr]})],ye.prototype,"events",void 0),t([i({type:me})],ye.prototype,"geometry",void 0),t([f("geometry",["compressedGeometry"])],ye.prototype,"readGeometry",null),t([i({type:[At]})],ye.prototype,"strings",void 0),ye=t([j("esri.rest.support.DirectionsFeature")],ye);const Ar=ye;function Br(o,e){if(o.length===0)return new me({spatialReference:e});const r=[];for(const n of o)for(const y of n.paths)r.push(...y);const s=[];r.forEach((n,y)=>{y!==0&&n[0]===r[y-1][0]&&n[1]===r[y-1][1]||s.push(n)});const{hasM:a,hasZ:c}=o[0];return new me({hasM:a,hasZ:c,paths:[s],spatialReference:e})}let _=class extends re{constructor(e){super(e),this.extent=null,this.features=[],this.geometryType="polyline",this.routeId=null,this.routeName=null,this.totalDriveTime=null,this.totalLength=null,this.totalTime=null}readFeatures(e,r){if(!e)return[];const s=r.summary.envelope.spatialReference??r.spatialReference,a=s&&ae.fromJSON(s);return e.map(c=>{const n=Ar.fromJSON(c);if(n.geometry!=null&&(n.geometry.spatialReference=a),n.events!=null)for(const y of n.events)y.geometry!=null&&(y.geometry.spatialReference=a);return n})}get mergedGeometry(){return this.features?Br(this.features.map(({geometry:e})=>e),this.extent.spatialReference):null}get strings(){return this.features.flatMap(({strings:e})=>e).filter(Ot)}};t([i({type:Nt,json:{read:{source:"summary.envelope"}}})],_.prototype,"extent",void 0),t([i({nonNullable:!0})],_.prototype,"features",void 0),t([f("features")],_.prototype,"readFeatures",null),t([i()],_.prototype,"geometryType",void 0),t([i({readOnly:!0})],_.prototype,"mergedGeometry",null),t([i()],_.prototype,"routeId",void 0),t([i()],_.prototype,"routeName",void 0),t([i({value:null,readOnly:!0})],_.prototype,"strings",null),t([i({json:{read:{source:"summary.totalDriveTime"}}})],_.prototype,"totalDriveTime",void 0),t([i({json:{read:{source:"summary.totalLength"}}})],_.prototype,"totalLength",void 0),t([i({json:{read:{source:"summary.totalTime"}}})],_.prototype,"totalTime",void 0),_=t([j("esri.rest.support.DirectionsFeatureSet")],_);const Fr=_;let Z=class extends P{constructor(e){super(e),this.directionLines=null,this.directionPoints=null,this.directions=null,this.route=null,this.routeName=null,this.stops=null,this.traversedEdges=null,this.traversedJunctions=null,this.traversedTurns=null}};t([i({type:re,json:{write:!0}})],Z.prototype,"directionLines",void 0),t([i({type:re,json:{write:!0}})],Z.prototype,"directionPoints",void 0),t([i({type:Fr,json:{write:!0}})],Z.prototype,"directions",void 0),t([i({type:G,json:{write:!0}})],Z.prototype,"route",void 0),t([i({type:String,json:{write:!0}})],Z.prototype,"routeName",void 0),t([i({type:[G],json:{write:!0}})],Z.prototype,"stops",void 0),t([i({type:re,json:{write:!0}})],Z.prototype,"traversedEdges",void 0),t([i({type:re,json:{write:!0}})],Z.prototype,"traversedJunctions",void 0),t([i({type:re,json:{write:!0}})],Z.prototype,"traversedTurns",void 0),Z=t([j("esri.rest.support.RouteResult")],Z);const Lr=Z;function Ye(o){return o?re.fromJSON(o).features.filter(Ot):[]}let H=class extends P{constructor(e){super(e),this.checksum=null,this.messages=null,this.pointBarriers=null,this.polylineBarriers=null,this.polygonBarriers=null,this.routeResults=null}readPointBarriers(e,r){return Ye(r.barriers)}readPolylineBarriers(e){return Ye(e)}readPolygonBarriers(e){return Ye(e)}};t([i({type:String})],H.prototype,"checksum",void 0),t([i({type:[Ir]})],H.prototype,"messages",void 0),t([i({type:[G]})],H.prototype,"pointBarriers",void 0),t([f("pointBarriers",["barriers"])],H.prototype,"readPointBarriers",null),t([i({type:[G]})],H.prototype,"polylineBarriers",void 0),t([f("polylineBarriers")],H.prototype,"readPolylineBarriers",null),t([i({type:[G]})],H.prototype,"polygonBarriers",void 0),t([f("polygonBarriers")],H.prototype,"readPolygonBarriers",null),t([i({type:[Lr]})],H.prototype,"routeResults",void 0),H=t([j("esri.rest.support.RouteSolveResult")],H);function Re(o){return o instanceof re}async function Mr(o,e,r){const s=[],a=[],c={},n={},y=St(o),{path:O}=y;Re(e.stops)&&Pe(e.stops.features,a,"stops.features",c),Re(e.pointBarriers)&&Pe(e.pointBarriers.features,a,"pointBarriers.features",c),Re(e.polylineBarriers)&&Pe(e.polylineBarriers.features,a,"polylineBarriers.features",c),Re(e.polygonBarriers)&&Pe(e.polygonBarriers.features,a,"polygonBarriers.features",c);const A=await fr(a);for(const C in c){const w=c[C];s.push(C),n[C]=A.slice(w[0],w[1])}if(Sr(n,s)){let C=null;try{C=await jt(O,e.apiKey,r)}catch{}C&&!C.hasZ&&wr(n,s)}for(const C in n)n[C].forEach((w,D)=>{Pt(e,C)[D].geometry=w});const h={...r,query:{...y.query,...Dr(e),f:"json"}},l=O.endsWith("/solve")?O:`${O}/solve`,{data:T}=await fe(l,h);return Pr(T)}function Pr(o){const{barriers:e,checksum:r,directionLines:s,directionPoints:a,directions:c,messages:n,polygonBarriers:y,polylineBarriers:O,routes:A,stops:h,traversedEdges:l,traversedJunctions:T,traversedTurns:C}=o,w=v=>{const L=m.find(J=>J.routeName===v);if(L!=null)return L;const b={routeId:m.length+1,routeName:v};return m.push(b),b},D=v=>{const L=m.find(J=>J.routeId===v);if(L!=null)return L;const b={routeId:v,routeName:null};return m.push(b),b},m=[];A?.features.forEach((v,L)=>{v.geometry.spatialReference=A.spatialReference??void 0;const b=v.attributes.Name,J=L+1;m.push({routeId:J,routeName:b,route:v})}),c?.forEach(v=>{const{routeName:L}=v;w(L).directions=v});const S=(h?.features.every(v=>v.attributes.RouteName==null)??!1)&&m.length>0?m[0].routeName:null;return h?.features.forEach(v=>{var J;v.geometry&&((J=v.geometry).spatialReference??(J.spatialReference=h.spatialReference??void 0));const L=S??v.attributes.RouteName,b=w(L);b.stops??(b.stops=[]),b.stops.push(v)}),s?.features.forEach(v=>{const L=v.attributes.RouteID,b=D(L),{geometryType:J,spatialReference:oe}=s;b.directionLines??(b.directionLines={features:[],geometryType:J,spatialReference:oe}),b.directionLines.features.push(v)}),a?.features.forEach(v=>{const L=v.attributes.RouteID,b=D(L),{geometryType:J,spatialReference:oe}=a;b.directionPoints??(b.directionPoints={features:[],geometryType:J,spatialReference:oe}),b.directionPoints.features.push(v)}),l?.features.forEach(v=>{const L=v.attributes.RouteID,b=D(L),{geometryType:J,spatialReference:oe}=l;b.traversedEdges??(b.traversedEdges={features:[],geometryType:J,spatialReference:oe}),b.traversedEdges.features.push(v)}),T?.features.forEach(v=>{const L=v.attributes.RouteID,b=D(L),{geometryType:J,spatialReference:oe}=T;b.traversedJunctions??(b.traversedJunctions={features:[],geometryType:J,spatialReference:oe}),b.traversedJunctions.features.push(v)}),C?.features.forEach(v=>{const L=v.attributes.RouteID,b=D(L);b.traversedTurns??(b.traversedTurns={features:[]}),b.traversedTurns.features.push(v)}),H.fromJSON({barriers:e,checksum:r,messages:n,polygonBarriers:y,polylineBarriers:O,routeResults:m})}var tt,Te;let $=(Te=class extends Q.ClonableMixin(P){constructor(e){super(e),this.directionLineType=null,this.directionPointId=null,this.distance=null,this.duration=null,this.fromLevel=null,this.geometry=null,this.objectId=null,this.popupTemplate=null,this.symbol=null,this.toLevel=null,this.type="direction-line"}static fromGraphic(e){return new tt({directionLineType:Ve.fromJSON(e.attributes.DirectionLineType),directionPointId:e.attributes.DirectionPointID,distance:e.attributes.Meters,duration:e.attributes.Minutes,fromLevel:e.attributes.FromLevel??null,geometry:e.geometry,objectId:e.attributes.ObjectID??e.attributes.__OBJECTID,popupTemplate:e.popupTemplate,symbol:e.symbol,toLevel:e.attributes.ToLevel??null})}toGraphic(){const e={ObjectID:this.objectId,DirectionLineType:this.directionLineType?Ve.toJSON(this.directionLineType):null,DirectionPointID:this.directionPointId,Meters:this.distance,Minutes:this.duration};return this.fromLevel!=null&&(e.FromLevel=this.fromLevel),this.toLevel!=null&&(e.ToLevel=this.toLevel),new G({geometry:this.geometry,attributes:e,symbol:this.symbol,popupTemplate:this.popupTemplate})}},tt=Te,Te.fields=[{name:"ObjectID",alias:"ObjectID",type:"esriFieldTypeOID"},{name:"DirectionLineType",alias:"Line Type",type:"esriFieldTypeInteger"},{name:"DirectionPointID",alias:"Direction Point ID",type:"esriFieldTypeInteger"},{name:"FromLevel",alias:"From Level",type:"esriFieldTypeInteger"},{name:"Meters",alias:"Meters",type:"esriFieldTypeDouble"},{name:"Minutes",alias:"Minutes",type:"esriFieldTypeDouble"},{name:"ToLevel",alias:"To Level",type:"esriFieldTypeInteger"}],Te);t([i({type:Ve.apiValues,json:{read:{source:"attributes.DirectionLineType",reader:Ve.read}}})],$.prototype,"directionLineType",void 0),t([i({json:{read:{source:"attributes.DirectionPointID"}}})],$.prototype,"directionPointId",void 0),t([i({json:{read:{source:"attributes.Meters"}}})],$.prototype,"distance",void 0),t([i({json:{read:{source:"attributes.Minutes"}}})],$.prototype,"duration",void 0),t([i({json:{read:{source:"attributes.FromLevel"}}})],$.prototype,"fromLevel",void 0),t([i({type:me})],$.prototype,"geometry",void 0),t([i({json:{read:{source:"attributes.ObjectID"}}})],$.prototype,"objectId",void 0),t([i({type:ce})],$.prototype,"popupTemplate",void 0),t([i({types:he})],$.prototype,"symbol",void 0),t([i({json:{read:{source:"attributes.ToLevel"}}})],$.prototype,"toLevel",void 0),t([i({readOnly:!0,json:{read:!1}})],$.prototype,"type",void 0),$=tt=t([j("esri.rest.support.DirectionLine")],$);var rt,ge;let I=(ge=class extends Q.ClonableMixin(P){constructor(e){super(e),this.alternateName=null,this.arrivalTime=null,this.arrivalTimeOffset=null,this.azimuth=null,this.branchName=null,this.directionPointType=null,this.displayText=null,this.exitName=null,this.geometry=null,this.intersectingName=null,this.level=null,this.name=null,this.objectId=null,this.popupTemplate=null,this.sequence=null,this.shortVoiceInstruction=null,this.stopId=null,this.symbol=null,this.towardName=null,this.type="direction-point",this.voiceInstruction=null}readArrivalTime(e,r){return r.attributes.ArrivalTime!=null?new Date(r.attributes.ArrivalTime):null}static fromGraphic(e){return new rt({alternateName:e.attributes.AlternateName??null,arrivalTime:e.attributes.ArrivalTime!=null?new Date(e.attributes.ArrivalTime):null,arrivalTimeOffset:e.attributes.ArrivalUTCOffset??null,azimuth:e.attributes.Azimuth??null,branchName:e.attributes.BranchName??null,directionPointType:Ge.fromJSON(e.attributes.DirectionPointType),displayText:e.attributes.DisplayText??null,exitName:e.attributes.ExitName??null,geometry:e.geometry,intersectingName:e.attributes.IntersectingName??null,level:e.attributes.Level??null,name:e.attributes.Name??null,objectId:e.attributes.ObjectID??e.attributes.__OBJECTID,popupTemplate:e.popupTemplate,sequence:e.attributes.Sequence,shortVoiceInstruction:e.attributes.ShortVoiceInstruction??null,stopId:e.attributes.StopID??null,symbol:e.symbol,towardName:e.attributes.TowardName??null,voiceInstruction:e.attributes.VoiceInstruction??null})}toGraphic(){const e={ObjectID:this.objectId,DirectionPointType:this.directionPointType?Ge.toJSON(this.directionPointType):null,Sequence:this.sequence,StopID:this.stopId};return this.alternateName!=null&&(e.AlternateName=this.alternateName),this.arrivalTime!=null&&(e.ArrivalTime=this.arrivalTime.getTime()),this.arrivalTimeOffset!=null&&(e.ArrivalUTCOffset=this.arrivalTimeOffset),this.azimuth!=null&&(e.Azimuth=this.azimuth),this.branchName!=null&&(e.BranchName=this.branchName),this.displayText!=null&&(e.DisplayText=this.displayText),this.exitName!=null&&(e.ExitName=this.exitName),this.intersectingName!=null&&(e.IntersectingName=this.intersectingName),this.level!=null&&(e.Level=this.level),this.name!=null&&(e.Name=this.name),this.shortVoiceInstruction!=null&&(e.ShortVoiceInstruction=this.shortVoiceInstruction),this.towardName!=null&&(e.TowardName=this.towardName),this.voiceInstruction!=null&&(e.VoiceInstruction=this.voiceInstruction),new G({geometry:this.geometry,attributes:e,symbol:this.symbol,popupTemplate:this.popupTemplate})}},rt=ge,ge.fields=[{name:"ObjectID",alias:"ObjectID",type:"esriFieldTypeOID"},{name:"AlternateName",alias:"Alternative Name",type:"esriFieldTypeString"},{name:"ArrivalTime",alias:"Arrival Time",type:"esriFieldTypeDate"},{name:"ArrivalUTCOffset",alias:"Arrival Time Offset",type:"esriFieldTypeInteger"},{name:"Azimuth",alias:"Azimuth",type:"esriFieldTypeDouble"},{name:"BranchName",alias:"Branch Name",type:"esriFieldTypeString"},{name:"DirectionPointType",alias:"Directions Point Type",type:"esriFieldTypeInteger"},{name:"DisplayText",alias:"Display Text",type:"esriFieldTypeString"},{name:"ExitName",alias:"Exit Name",type:"esriFieldTypeString"},{name:"IntersectingName",alias:"Intersecting Name",type:"esriFieldTypeString"},{name:"Level",alias:"Level",type:"esriFieldTypeInteger"},{name:"Name",alias:"Name",type:"esriFieldTypeString"},{name:"Sequence",alias:"Sequence",type:"esriFieldTypeInteger"},{name:"ShortVoiceInstruction",alias:"Short Voice Instruction",type:"esriFieldTypeString"},{name:"StopID",alias:"Stop ID",type:"esriFieldTypeInteger"},{name:"TowardName",alias:"Toward Name",type:"esriFieldTypeString"},{name:"VoiceInstruction",alias:"Voice Instruction",type:"esriFieldTypeString"}],ge);t([i({json:{read:{source:"attributes.AlternateName"}}})],I.prototype,"alternateName",void 0),t([i({type:Date})],I.prototype,"arrivalTime",void 0),t([f("arrivalTime",["attributes.ArrivalTime"])],I.prototype,"readArrivalTime",null),t([i({json:{read:{source:"attributes.ArrivalUTCOffset"}}})],I.prototype,"arrivalTimeOffset",void 0),t([i({json:{read:{source:"attributes.Azimuth"}}})],I.prototype,"azimuth",void 0),t([i({json:{read:{source:"attributes.BranchName"}}})],I.prototype,"branchName",void 0),t([i({type:Ge.apiValues,json:{read:{source:"attributes.DirectionPointType",reader:Ge.read}}})],I.prototype,"directionPointType",void 0),t([i({json:{read:{source:"attributes.DisplayText"}}})],I.prototype,"displayText",void 0),t([i({json:{read:{source:"attributes.ExitName"}}})],I.prototype,"exitName",void 0),t([i({type:Me})],I.prototype,"geometry",void 0),t([i({json:{read:{source:"attributes.IntersectingName"}}})],I.prototype,"intersectingName",void 0),t([i({json:{read:{source:"attributes.Level"}}})],I.prototype,"level",void 0),t([i({json:{read:{source:"attributes.Name"}}})],I.prototype,"name",void 0),t([i({json:{read:{source:"attributes.ObjectID"}}})],I.prototype,"objectId",void 0),t([i({type:ce})],I.prototype,"popupTemplate",void 0),t([i({json:{read:{source:"attributes.Sequence"}}})],I.prototype,"sequence",void 0),t([i({json:{read:{source:"attributes.ShortVoiceInstruction"}}})],I.prototype,"shortVoiceInstruction",void 0),t([i({json:{read:{source:"attributes.StopID"}}})],I.prototype,"stopId",void 0),t([i({types:he})],I.prototype,"symbol",void 0),t([i({json:{read:{source:"attributes.TowardName"}}})],I.prototype,"towardName",void 0),t([i({readOnly:!0,json:{read:!1}})],I.prototype,"type",void 0),t([i({json:{read:{source:"attributes.VoiceInstruction"}}})],I.prototype,"voiceInstruction",void 0),I=rt=t([j("esri.rest.support.DirectionPoint")],I);var it,we;let B=(we=class extends Q.ClonableMixin(P){constructor(e){super(e),this.addedCost=null,this.barrierType=null,this.costs=null,this.curbApproach=null,this.fullEdge=null,this.geometry=null,this.name=null,this.objectId=null,this.popupTemplate=null,this.sideOfEdge=null,this.sourceId=null,this.sourceOid=null,this.status=null,this.symbol=null,this.type="point-barrier"}readCosts(e,r){return ie(r.attributes,"Attr_")}writeCosts(e,r){ct(e,r,"Attr_")}static fromGraphic(e){return new it({addedCost:e.attributes.AddedCost??null,barrierType:e.attributes.BarrierType!=null?q.fromJSON(e.attributes.BarrierType):null,costs:e.attributes.Costs!=null?be(JSON.parse(e.attributes.Costs)):null,curbApproach:e.attributes.CurbApproach!=null?k.fromJSON(e.attributes.CurbApproach):null,fullEdge:e.attributes.FullEdge!=null?je.fromJSON(e.attributes.FullEdge):null,geometry:e.geometry,name:e.attributes.Name??null,objectId:e.attributes.ObjectID??e.attributes.__OBJECTID,popupTemplate:e.popupTemplate,status:e.attributes.Status!=null?pe.fromJSON(e.attributes.Status):null,symbol:e.symbol})}toGraphic(){const e={ObjectID:this.objectId,AddedCost:this.addedCost,BarrierType:this.barrierType?q.toJSON(this.barrierType):null,Costs:this.costs?JSON.stringify(ve(this.costs)):null,CurbApproach:this.curbApproach?k.toJSON(this.curbApproach):null,FullEdge:this.fullEdge?je.toJSON(this.fullEdge):null,Name:this.name,Status:this.status?pe.toJSON(this.status):null};return new G({geometry:this.geometry,attributes:e,symbol:this.symbol,popupTemplate:this.popupTemplate})}},it=we,we.fields=[{name:"ObjectID",alias:"ObjectID",type:"esriFieldTypeOID"},{name:"AddedCost",alias:"Added Cost",type:"esriFieldTypeDouble"},{name:"BarrierType",alias:"Barrier Type",type:"esriFieldTypeInteger"},{name:"Costs",alias:"Costs",type:"esriFieldTypeString"},{name:"CurbApproach",alias:"Curb Approach",type:"esriFieldTypeInteger"},{name:"FullEdge",alias:"Full Edge",type:"esriFieldTypeInteger"},{name:"Name",alias:"Name",type:"esriFieldTypeString"},{name:"Status",alias:"Status",type:"esriFieldTypeInteger"}],we);t([i()],B.prototype,"addedCost",void 0),t([i({type:q.apiValues,json:{name:"attributes.BarrierType",read:{reader:q.read},write:{writer:q.write}}})],B.prototype,"barrierType",void 0),t([i()],B.prototype,"costs",void 0),t([f("costs",["attributes"])],B.prototype,"readCosts",null),t([U("costs")],B.prototype,"writeCosts",null),t([i({type:k.apiValues,json:{read:{source:"attributes.CurbApproach",reader:k.read}}})],B.prototype,"curbApproach",void 0),t([i({type:je.apiValues,json:{name:"attributes.FullEdge",read:{reader:je.read},write:{writer:je.write}}})],B.prototype,"fullEdge",void 0),t([i({type:Me,json:{write:!0}})],B.prototype,"geometry",void 0),t([i({json:{name:"attributes.Name"}})],B.prototype,"name",void 0),t([i({json:{name:"attributes.ObjectID"}})],B.prototype,"objectId",void 0),t([i({type:ce})],B.prototype,"popupTemplate",void 0),t([i({type:qe.apiValues,json:{read:{source:"attributes.SideOfEdge",reader:qe.read}}})],B.prototype,"sideOfEdge",void 0),t([i({json:{read:{source:"attributes.SourceID"}}})],B.prototype,"sourceId",void 0),t([i({json:{read:{source:"attributes.SourceOID"}}})],B.prototype,"sourceOid",void 0),t([i({type:pe.apiValues,json:{read:{source:"attributes.Status",reader:pe.read}}})],B.prototype,"status",void 0),t([i({types:he})],B.prototype,"symbol",void 0),t([i({readOnly:!0,json:{read:!1}})],B.prototype,"type",void 0),B=it=t([j("esri.rest.support.PointBarrier")],B);var ot,Se;let E=(Se=class extends Q.ClonableMixin(P){constructor(e){super(e),this.barrierType=null,this.costs=null,this.geometry=null,this.name=null,this.objectId=null,this.popupTemplate=null,this.scaleFactor=null,this.symbol=null,this.type="polygon-barrier"}readCosts(e,r){return ie(r.attributes,"Attr_")}writeCosts(e,r){ct(e,r,"Attr_")}static fromGraphic(e){return new ot({barrierType:e.attributes.BarrierType!=null?q.fromJSON(e.attributes.BarrierType):null,costs:e.attributes.Costs!=null?be(JSON.parse(e.attributes.Costs)):null,geometry:e.geometry,name:e.attributes.Name??null,objectId:e.attributes.ObjectID??e.attributes.__OBJECTID,popupTemplate:e.popupTemplate,scaleFactor:e.attributes.ScaleFactor??null,symbol:e.symbol})}toGraphic(){const e={ObjectID:this.objectId,BarrierType:this.barrierType?q.toJSON(this.barrierType):null,Costs:this.costs?JSON.stringify(ve(this.costs)):null,Name:this.name??null,ScaleFactor:this.scaleFactor??null};return new G({geometry:this.geometry,attributes:e,symbol:this.symbol,popupTemplate:this.popupTemplate})}},ot=Se,Se.fields=[{name:"ObjectID",alias:"ObjectID",type:"esriFieldTypeOID"},{name:"BarrierType",alias:"Barrier Type",type:"esriFieldTypeInteger"},{name:"Costs",alias:"Costs",type:"esriFieldTypeString"},{name:"Name",alias:"Name",type:"esriFieldTypeString"},{name:"ScaleFactor",alias:"Scale Factor",type:"esriFieldTypeDouble"}],Se);t([i({type:q.apiValues,json:{name:"attributes.BarrierType",read:{reader:q.read},write:{writer:q.write}}})],E.prototype,"barrierType",void 0),t([i()],E.prototype,"costs",void 0),t([f("costs",["attributes"])],E.prototype,"readCosts",null),t([U("costs")],E.prototype,"writeCosts",null),t([i({type:Rt,json:{write:!0}})],E.prototype,"geometry",void 0),t([i({json:{name:"attributes.Name"}})],E.prototype,"name",void 0),t([i({json:{name:"attributes.ObjectID"}})],E.prototype,"objectId",void 0),t([i({type:ce})],E.prototype,"popupTemplate",void 0),t([i()],E.prototype,"scaleFactor",void 0),t([i({types:he})],E.prototype,"symbol",void 0),t([i({readOnly:!0,json:{read:!1}})],E.prototype,"type",void 0),E=ot=t([j("esri.rest.support.PolygonBarrier")],E);var st,Ne;let x=(Ne=class extends Q.ClonableMixin(P){constructor(e){super(e),this.barrierType=null,this.costs=null,this.geometry=null,this.name=null,this.objectId=null,this.popupTemplate=null,this.scaleFactor=null,this.symbol=null,this.type="polyline-barrier"}readCosts(e,r){return ie(r.attributes,"Attr_")}static fromGraphic(e){return new st({barrierType:e.attributes.BarrierType!=null?q.fromJSON(e.attributes.BarrierType):null,costs:e.attributes.Costs!=null?be(JSON.parse(e.attributes.Costs)):null,geometry:e.geometry,name:e.attributes.Name??null,objectId:e.attributes.ObjectID??e.attributes.__OBJECTID,popupTemplate:e.popupTemplate,scaleFactor:e.attributes.ScaleFactor??null,symbol:e.symbol})}toGraphic(){const e={ObjectID:this.objectId,BarrierType:this.barrierType?q.toJSON(this.barrierType):null,Costs:this.costs?JSON.stringify(ve(this.costs)):null,Name:this.name,ScaleFactor:this.scaleFactor};return new G({geometry:this.geometry,attributes:e,symbol:this.symbol,popupTemplate:this.popupTemplate})}},st=Ne,Ne.fields=[{name:"ObjectID",alias:"ObjectID",type:"esriFieldTypeOID"},{name:"BarrierType",alias:"Barrier Type",type:"esriFieldTypeInteger"},{name:"Costs",alias:"Costs",type:"esriFieldTypeString"},{name:"Name",alias:"Name",type:"esriFieldTypeString"},{name:"ScaleFactor",alias:"Scale Factor",type:"esriFieldTypeDouble"}],Ne);t([i({type:q.apiValues,json:{read:{source:"attributes.BarrierType",reader:q.read}}})],x.prototype,"barrierType",void 0),t([i()],x.prototype,"costs",void 0),t([f("costs",["attributes"])],x.prototype,"readCosts",null),t([i({type:me,json:{write:!0}})],x.prototype,"geometry",void 0),t([i({json:{name:"attributes.Name"}})],x.prototype,"name",void 0),t([i({json:{name:"attributes.ObjectID"}})],x.prototype,"objectId",void 0),t([i({type:ce})],x.prototype,"popupTemplate",void 0),t([i()],x.prototype,"scaleFactor",void 0),t([i({types:he})],x.prototype,"symbol",void 0),t([i({readOnly:!0,json:{read:!1}})],x.prototype,"type",void 0),x=st=t([j("esri.rest.support.PolylineBarrier")],x);let V=class extends P{constructor(o){super(o),this.accumulateAttributes=null,this.directionsLanguage=null,this.findBestSequence=null,this.preserveFirstStop=null,this.preserveLastStop=null,this.startTimeIsUTC=null,this.timeWindowsAreUTC=null,this.travelMode=null}readAccumulateAttributes(o){return o==null?null:o.map(e=>z.fromJSON(e))}writeAccumulateAttributes(o,e,r){o?.length&&(e[r]=o.map(s=>z.toJSON(s)))}};t([i({type:[String],json:{name:"accumulateAttributeNames",write:!0}})],V.prototype,"accumulateAttributes",void 0),t([f("accumulateAttributes")],V.prototype,"readAccumulateAttributes",null),t([U("accumulateAttributes")],V.prototype,"writeAccumulateAttributes",null),t([i({type:String,json:{write:!0}})],V.prototype,"directionsLanguage",void 0),t([i({type:Boolean,json:{write:!0}})],V.prototype,"findBestSequence",void 0),t([i({type:Boolean,json:{write:!0}})],V.prototype,"preserveFirstStop",void 0),t([i({type:Boolean,json:{write:!0}})],V.prototype,"preserveLastStop",void 0),t([i({type:Boolean,json:{write:!0}})],V.prototype,"startTimeIsUTC",void 0),t([i({type:Boolean,json:{write:!0}})],V.prototype,"timeWindowsAreUTC",void 0),t([i({type:M,json:{write:!0}})],V.prototype,"travelMode",void 0),V=t([j("esri.rest.support.RouteSettings")],V);var at,Oe;let N=(Oe=class extends Q.ClonableMixin(P){constructor(e){super(e),this.analysisSettings=null,this.endTime=null,this.endTimeOffset=null,this.firstStopId=null,this.geometry=null,this.lastStopId=null,this.messages=null,this.name=null,this.objectId=null,this.popupTemplate=null,this.startTime=null,this.startTimeOffset=null,this.stopCount=null,this.symbol=null,this.totalCosts=null,this.totalDistance=null,this.totalDuration=null,this.totalLateDuration=null,this.totalViolations=null,this.totalWait=null,this.totalWaitDuration=null,this.type="route-info",this.version="1.0.0"}readEndTime(e,r){return r.attributes.EndTimeUTC!=null?new Date(r.attributes.EndTimeUTC):null}readEndTimeOffset(e,r){return Be(r.attributes.EndTime,r.attributes.EndTimeUTC)}readStartTime(e,r){return r.attributes.StartTimeUTC!=null?new Date(r.attributes.StartTimeUTC):null}readStartTimeOffset(e,r){return Be(r.attributes.StartTime,r.attributes.StartTimeUTC)}readTotalCosts(e,r){return ie(r.attributes,"Total_")}readTotalViolations(e,r){return ie(r.attributes,"TotalViolation_")}readTotalWait(e,r){return ie(r.attributes,"TotalWait_")}static fromGraphic(e){return new at({analysisSettings:e.attributes.AnalysisSettings!=null?V.fromJSON(JSON.parse(e.attributes.AnalysisSettings)):null,endTime:e.attributes.EndTime!=null?new Date(e.attributes.EndTime):null,endTimeOffset:e.attributes.EndUTCOffset??null,geometry:e.geometry,messages:e.attributes.Messages!=null?JSON.parse(e.attributes.Messages):null,name:e.attributes.RouteName,objectId:e.attributes.ObjectID??e.attributes.__OBJECTID,popupTemplate:e.popupTemplate,startTime:e.attributes.StartTime!=null?new Date(e.attributes.StartTime):null,startTimeOffset:e.attributes.StartUTCOffset??null,symbol:e.symbol,totalCosts:e.attributes.TotalCosts!=null?be(JSON.parse(e.attributes.TotalCosts)):null,totalDistance:e.attributes.TotalMeters??null,totalDuration:e.attributes.TotalMinutes??null,totalLateDuration:e.attributes.TotalLateMinutes??null,totalWaitDuration:e.attributes.TotalWaitMinutes??null,version:e.attributes.Version})}toGraphic(){const e={ObjectID:this.objectId,AnalysisSettings:this.analysisSettings?JSON.stringify(this.analysisSettings.toJSON()):null,EndTime:this.endTime?.getTime()??null,EndUTCOffset:this.endTimeOffset,Messages:this.messages?JSON.stringify(this.messages):null,RouteName:this.name,StartTime:this.startTime?.getTime()??null,StartUTCOffset:this.startTimeOffset,TotalCosts:this.totalCosts?JSON.stringify(ve(this.totalCosts)):null,TotalLateMinutes:this.totalLateDuration,TotalMeters:this.totalDistance,TotalMinutes:this.totalDuration,TotalWaitMinutes:this.totalWaitDuration,Version:this.version};return new G({geometry:this.geometry,attributes:e,symbol:this.symbol,popupTemplate:this.popupTemplate})}},at=Oe,Oe.fields=[{name:"ObjectID",alias:"ObjectID",type:"esriFieldTypeOID"},{name:"AnalysisSettings",alias:"Analysis Settings",type:"esriFieldTypeString"},{name:"EndTime",alias:"End Time",type:"esriFieldTypeDate"},{name:"EndUTCOffset",alias:"End Time Offset",type:"esriFieldTypeInteger"},{name:"Messages",alias:"Messages",type:"esriFieldTypeString"},{name:"RouteName",alias:"Route Name",type:"esriFieldTypeString"},{name:"StartTime",alias:"Start Time",type:"esriFieldTypeDate"},{name:"StartUTCOffset",alias:"Start Time Offset",type:"esriFieldTypeInteger"},{name:"TotalCosts",alias:"Total Costs",type:"esriFieldTypeString"},{name:"TotalLateMinutes",alias:"Total Late Minutes",type:"esriFieldTypeDouble"},{name:"TotalMeters",alias:"Total Meters",type:"esriFieldTypeDouble"},{name:"TotalMinutes",alias:"Total Minutes",type:"esriFieldTypeDouble"},{name:"TotalWaitMinutes",alias:"Total Wait Minutes",type:"esriFieldTypeDouble"},{name:"Version",alias:"Version",type:"esriFieldTypeString"}],Oe);t([i()],N.prototype,"analysisSettings",void 0),t([i({type:Date})],N.prototype,"endTime",void 0),t([f("endTime",["attributes.EndTimeUTC"])],N.prototype,"readEndTime",null),t([i()],N.prototype,"endTimeOffset",void 0),t([f("endTimeOffset",["attributes.EndTime","attributes.EndTimeUTC"])],N.prototype,"readEndTimeOffset",null),t([i({json:{read:{source:"attributes.FirstStopID"}}})],N.prototype,"firstStopId",void 0),t([i({type:me})],N.prototype,"geometry",void 0),t([i({json:{read:{source:"attributes.LastStopID"}}})],N.prototype,"lastStopId",void 0),t([i()],N.prototype,"messages",void 0),t([i({json:{read:{source:"attributes.Name"}}})],N.prototype,"name",void 0),t([i({json:{read:{source:"attributes.ObjectID"}}})],N.prototype,"objectId",void 0),t([i({type:ce})],N.prototype,"popupTemplate",void 0),t([i({type:Date})],N.prototype,"startTime",void 0),t([f("startTime",["attributes.StartTimeUTC"])],N.prototype,"readStartTime",null),t([i()],N.prototype,"startTimeOffset",void 0),t([f("startTimeOffset",["attributes.StartTime","attributes.StartTimeUTC"])],N.prototype,"readStartTimeOffset",null),t([i({json:{read:{source:"attributes.StopCount"}}})],N.prototype,"stopCount",void 0),t([i({types:he})],N.prototype,"symbol",void 0),t([i()],N.prototype,"totalCosts",void 0),t([f("totalCosts",["attributes"])],N.prototype,"readTotalCosts",null),t([i()],N.prototype,"totalDistance",void 0),t([i()],N.prototype,"totalDuration",void 0),t([i()],N.prototype,"totalLateDuration",void 0),t([i()],N.prototype,"totalViolations",void 0),t([f("totalViolations",["attributes"])],N.prototype,"readTotalViolations",null),t([i()],N.prototype,"totalWait",void 0),t([f("totalWait",["attributes"])],N.prototype,"readTotalWait",null),t([i()],N.prototype,"totalWaitDuration",void 0),t([i({readOnly:!0,json:{read:!1}})],N.prototype,"type",void 0),t([i()],N.prototype,"version",void 0),N=at=t([j("esri.rest.support.RouteInfo")],N);let ee=class extends Q.ClonableMixin(P){constructor(o){super(o),this.doNotLocateOnRestrictedElements=null,this.geometry=null,this.geometryType=null,this.name=null,this.spatialRelationship=null,this.type="layer",this.where=null}};t([i({type:Boolean,json:{write:!0}})],ee.prototype,"doNotLocateOnRestrictedElements",void 0),t([i({types:Jt,json:{read:Et,write:!0}})],ee.prototype,"geometry",void 0),t([F(cr)],ee.prototype,"geometryType",void 0),t([i({type:String,json:{name:"layerName",write:!0}})],ee.prototype,"name",void 0),t([F(dr,{name:"spatialRel"})],ee.prototype,"spatialRelationship",void 0),t([i({type:String,json:{write:!0}})],ee.prototype,"type",void 0),t([i({type:String,json:{write:!0}})],ee.prototype,"where",void 0),ee=t([j("esri.rest.support.DataLayer")],ee);var nt,Fe;let Ue=(Fe=class extends re{constructor(e){super(e),this.doNotLocateOnRestrictedElements=null}clone(){return new nt({doNotLocateOnRestrictedElements:this.doNotLocateOnRestrictedElements,...this.cloneProperties()})}},nt=Fe,Fe);t([i({type:Boolean,json:{write:!0}})],Ue.prototype,"doNotLocateOnRestrictedElements",void 0),Ue=nt=t([j("esri.rest.support.NetworkFeatureSet")],Ue);let Ce=class extends Q.ClonableMixin(P){constructor(o){super(o),this.doNotLocateOnRestrictedElements=null,this.url=null}};t([i({type:Boolean,json:{write:!0}})],Ce.prototype,"doNotLocateOnRestrictedElements",void 0),t([i({type:String,json:{write:!0}})],Ce.prototype,"url",void 0),Ce=t([j("esri.rest.support.NetworkUrl")],Ce);var lt,Le;let u=(Le=class extends Q.ClonableMixin(P){constructor(e){super(e),this.accumulateAttributes=null,this.apiKey=null,this.attributeParameterValues=null,this.checksum=null,this.directionsLanguage=null,this.directionsLengthUnits=null,this.directionsOutputType=null,this.directionsStyleName=null,this.directionsTimeAttribute=null,this.findBestSequence=null,this.geometryPrecision=null,this.geometryPrecisionM=null,this.geometryPrecisionZ=null,this.ignoreInvalidLocations=null,this.impedanceAttribute=null,this.outputGeometryPrecision=null,this.outputGeometryPrecisionUnits=null,this.outputLines="true-shape",this.outSpatialReference=null,this.overrides=null,this.pointBarriers=null,this.polygonBarriers=null,this.polylineBarriers=null,this.preserveFirstStop=null,this.preserveLastStop=null,this.preserveObjectID=null,this.restrictionAttributes=null,this.restrictUTurns=null,this.returnBarriers=!1,this.returnDirections=!1,this.returnPolygonBarriers=!1,this.returnPolylineBarriers=!1,this.returnRoutes=!0,this.returnStops=!1,this.returnTraversedEdges=null,this.returnTraversedJunctions=null,this.returnTraversedTurns=null,this.returnZ=!0,this.startTime=null,this.startTimeIsUTC=!0,this.stops=null,this.timeWindowsAreUTC=null,this.travelMode=null,this.useHierarchy=null,this.useTimeWindows=null}static from(e){return $t(lt,e)}readAccumulateAttributes(e){return e==null?null:e.map(r=>z.fromJSON(r))}writeAccumulateAttributes(e,r,s){e?.length&&(r[s]=e.map(a=>z.toJSON(a)))}writePointBarriers(e,r,s){Je(e,r,s)}writePolygonBarrier(e,r,s){Je(e,r,s)}writePolylineBarrier(e,r,s){Je(e,r,s)}readRestrictionAttributes(e){return e==null?null:e.map(r=>_e.fromJSON(r))}writeRestrictionAttributes(e,r,s){e?.length&&(r[s]=e.map(a=>_e.toJSON(a)))}readStartTime(e,r){const{startTime:s}=r;return s==null?null:s==="now"?"now":new Date(s)}writeStartTime(e,r){e!=null&&(r.startTime=e==="now"?"now":e.getTime())}readStops(e,r){return xr(r.stops)}writeStops(e,r,s){Je(e,r,s)}},lt=Le,Le);function Rr(o){return o&&"type"in o}function Jr(o){return o&&"features"in o&&"doNotLocateOnRestrictedElements"in o}function Er(o){return o&&"url"in o}function $r(o){return o&&"features"in o}function xr(o){return Rr(o)?ee.fromJSON(o):Er(o)?Ce.fromJSON(o):Jr(o)?Ue.fromJSON(o):$r(o)?re.fromJSON(o):null}function Je(o,e,r){o!=null&&(e[r]=W.isCollection(o)?{features:o.toArray().map(s=>s.toJSON())}:o.toJSON())}t([i({type:[String],json:{name:"accumulateAttributeNames",write:!0}})],u.prototype,"accumulateAttributes",void 0),t([f("accumulateAttributes")],u.prototype,"readAccumulateAttributes",null),t([U("accumulateAttributes")],u.prototype,"writeAccumulateAttributes",null),t([i(br)],u.prototype,"apiKey",void 0),t([i({json:{write:!0}})],u.prototype,"attributeParameterValues",void 0),t([i({type:String,json:{write:!0}})],u.prototype,"checksum",void 0),t([i({type:String,json:{write:!0}})],u.prototype,"directionsLanguage",void 0),t([F(Ct)],u.prototype,"directionsLengthUnits",void 0),t([F(yr)],u.prototype,"directionsOutputType",void 0),t([F(mr)],u.prototype,"directionsStyleName",void 0),t([F(ze,{name:"directionsTimeAttributeName",ignoreUnknown:!1})],u.prototype,"directionsTimeAttribute",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"findBestSequence",void 0),t([i({type:Number,json:{write:!0}})],u.prototype,"geometryPrecision",void 0),t([i({type:Number,json:{write:!0}})],u.prototype,"geometryPrecisionM",void 0),t([i({type:Number,json:{write:!0}})],u.prototype,"geometryPrecisionZ",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"ignoreInvalidLocations",void 0),t([F(z,{name:"impedanceAttributeName",ignoreUnknown:!1})],u.prototype,"impedanceAttribute",void 0),t([i({type:Number,json:{write:!0}})],u.prototype,"outputGeometryPrecision",void 0),t([F(Dt)],u.prototype,"outputGeometryPrecisionUnits",void 0),t([F(hr)],u.prototype,"outputLines",void 0),t([i({type:ae,json:{name:"outSR",write:!0}})],u.prototype,"outSpatialReference",void 0),t([i({json:{write:!0}})],u.prototype,"overrides",void 0),t([i({json:{name:"barriers",write:!0}})],u.prototype,"pointBarriers",void 0),t([U("pointBarriers")],u.prototype,"writePointBarriers",null),t([i({json:{write:!0}})],u.prototype,"polygonBarriers",void 0),t([U("polygonBarriers")],u.prototype,"writePolygonBarrier",null),t([i({json:{write:!0}})],u.prototype,"polylineBarriers",void 0),t([U("polylineBarriers")],u.prototype,"writePolylineBarrier",null),t([i({type:Boolean,json:{write:!0}})],u.prototype,"preserveFirstStop",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"preserveLastStop",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"preserveObjectID",void 0),t([i({type:[String],json:{name:"restrictionAttributeNames",write:!0}})],u.prototype,"restrictionAttributes",void 0),t([f("restrictionAttributes")],u.prototype,"readRestrictionAttributes",null),t([U("restrictionAttributes")],u.prototype,"writeRestrictionAttributes",null),t([F(It)],u.prototype,"restrictUTurns",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"returnBarriers",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"returnDirections",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"returnPolygonBarriers",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"returnPolylineBarriers",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"returnRoutes",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"returnStops",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"returnTraversedEdges",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"returnTraversedJunctions",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"returnTraversedTurns",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"returnZ",void 0),t([i({json:{write:!0}})],u.prototype,"startTime",void 0),t([f("startTime")],u.prototype,"readStartTime",null),t([U("startTime")],u.prototype,"writeStartTime",null),t([i({type:Boolean,json:{write:!0}})],u.prototype,"startTimeIsUTC",void 0),t([i({json:{write:!0}})],u.prototype,"stops",void 0),t([f("stops")],u.prototype,"readStops",null),t([U("stops")],u.prototype,"writeStops",null),t([i({type:Boolean,json:{write:!0}})],u.prototype,"timeWindowsAreUTC",void 0),t([i({type:M,json:{write:!0}})],u.prototype,"travelMode",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"useHierarchy",void 0),t([i({type:Boolean,json:{write:!0}})],u.prototype,"useTimeWindows",void 0),u=lt=t([j("esri.rest.support.RouteParameters")],u);var ut,De;let p=(De=class extends Q.ClonableMixin(P){constructor(e){super(e),this.arriveCurbApproach=null,this.arriveTime=null,this.arriveTimeOffset=null,this.bearing=null,this.bearingTol=null,this.cumulativeCosts=null,this.cumulativeDistance=null,this.cumulativeDuration=null,this.curbApproach=null,this.departCurbApproach=null,this.departTime=null,this.departTimeOffset=null,this.distanceToNetworkInMeters=null,this.geometry=null,this.lateDuration=null,this.locationType=null,this.name=null,this.navLatency=null,this.objectId=null,this.popupTemplate=null,this.posAlong=null,this.routeName=null,this.serviceCosts=null,this.serviceDistance=null,this.serviceDuration=null,this.sequence=null,this.sideOfEdge=null,this.snapX=null,this.snapY=null,this.snapZ=null,this.sourceId=null,this.sourceOid=null,this.status=null,this.symbol=null,this.timeWindowEnd=null,this.timeWindowEndOffset=null,this.timeWindowStart=null,this.timeWindowStartOffset=null,this.type="stop",this.violations=null,this.waitDuration=null,this.wait=null}readArriveTimeOffset(e,r){return Be(r.attributes.ArriveTime,r.attributes.ArriveTimeUTC)}readCumulativeCosts(e,r){return ie(r.attributes,"Cumul_")}readDepartTimeOffset(e,r){return Be(r.attributes.DepartTime,r.attributes.DepartTimeUTC)}readServiceCosts(e,r){return ie(r.attributes,"Attr_")}writeServiceCosts(e,r){ct(e,r,"Attr_")}writeTimeWindowEnd(e,r){e!=null&&(r.attributes||(r.attributes={}),r.attributes.TimeWindowEnd=e.getTime())}writeTimeWindowStart(e,r){e!=null&&(r.attributes||(r.attributes={}),r.attributes.TimeWindowStart=e.getTime())}readViolations(e,r){return ie(r.attributes,"Violation_")}readWait(e,r){return ie(r.attributes,"Wait_")}static fromGraphic(e){return new ut({arriveCurbApproach:e.attributes.ArrivalCurbApproach!=null?k.fromJSON(e.attributes.ArrivalCurbApproach):null,arriveTime:e.attributes.ArrivalTime!=null?new Date(e.attributes.ArrivalTime):null,arriveTimeOffset:e.attributes.ArrivalUTCOffset,cumulativeCosts:e.attributes.CumulativeCosts!=null?be(JSON.parse(e.attributes.CumulativeCosts)):null,cumulativeDistance:e.attributes.CumulativeMeters??null,cumulativeDuration:e.attributes.CumulativeMinutes??null,curbApproach:e.attributes.CurbApproach!=null?k.fromJSON(e.attributes.CurbApproach):null,departCurbApproach:e.attributes.DepartureCurbApproach!=null?k.fromJSON(e.attributes.DepartureCurbApproach):null,departTime:e.attributes.DepartureTime!=null?new Date(e.attributes.DepartureTime):null,departTimeOffset:e.attributes.DepartureUTCOffset??null,geometry:e.geometry,lateDuration:e.attributes.LateMinutes??null,locationType:e.attributes.LocationType!=null?Ae.fromJSON(e.attributes.LocationType):null,name:e.attributes.Name,objectId:e.attributes.ObjectID??e.attributes.__OBJECTID,popupTemplate:e.popupTemplate,routeName:e.attributes.RouteName,sequence:e.attributes.Sequence??null,serviceCosts:e.attributes.ServiceCosts!=null?be(JSON.parse(e.attributes.ServiceCosts)):null,serviceDistance:e.attributes.ServiceMeters??null,serviceDuration:e.attributes.ServiceMinutes??null,status:e.attributes.Status!=null?pe.fromJSON(e.attributes.Status):null,symbol:e.symbol,timeWindowEnd:e.attributes.TimeWindowEnd!=null?new Date(e.attributes.TimeWindowEnd):null,timeWindowEndOffset:e.attributes.TimeWindowEndUTCOffset??null,timeWindowStart:e.attributes.TimeWindowStart!=null?new Date(e.attributes.TimeWindowStart):null,timeWindowStartOffset:e.attributes.TimeWindowStartUTCOffset??null,waitDuration:e.attributes.WaitMinutes??null})}toGraphic(){const e={ObjectID:this.objectId,ArrivalCurbApproach:this.arriveCurbApproach?k.toJSON(this.arriveCurbApproach):null,ArrivalTime:this.arriveTime?.getTime()??null,ArrivalUTCOffset:this.arriveTimeOffset,CumulativeCosts:this.cumulativeCosts?JSON.stringify(ve(this.cumulativeCosts)):null,CumulativeMeters:this.cumulativeDistance,CumulativeMinutes:this.cumulativeDuration,CurbApproach:this.curbApproach?k.toJSON(this.curbApproach):null,DepartureCurbApproach:this.departCurbApproach?k.toJSON(this.departCurbApproach):null,DepartureTime:this.departTime?.getTime()??null,DepartureUTCOffset:this.departTimeOffset,LateMinutes:this.lateDuration,LocationType:this.locationType?Ae.toJSON(this.locationType):null,Name:this.name,RouteName:this.routeName,Sequence:this.sequence,ServiceCosts:this.serviceCosts?JSON.stringify(ve(this.serviceCosts)):null,ServiceMeters:this.serviceDistance,ServiceMinutes:this.serviceDuration,Status:this.status?pe.toJSON(this.status):null,TimeWindowEnd:this.timeWindowEnd?.getTime()??null,TimeWindowEndUTCOffset:this.timeWindowEndOffset??this.arriveTimeOffset,TimeWindowStart:this.timeWindowStart?.getTime()??null,TimeWindowStartUTCOffset:this.timeWindowStartOffset??this.arriveTimeOffset,WaitMinutes:this.waitDuration};return new G({geometry:this.geometry,attributes:e,symbol:this.symbol,popupTemplate:this.popupTemplate})}},ut=De,De.fields=[{name:"ObjectID",alias:"ObjectID",type:"esriFieldTypeOID"},{name:"ArrivalCurbApproach",alias:"Arrival Curb Approach",type:"esriFieldTypeInteger"},{name:"ArrivalTime",alias:"Arrival Time",type:"esriFieldTypeDate"},{name:"ArrivalUTCOffset",alias:"Arrival Time",type:"esriFieldTypeInteger"},{name:"CumulativeCosts",alias:"Cumulative Costs",type:"esriFieldTypeString"},{name:"CumulativeMeters",alias:"Cumulative Meters",type:"esriFieldTypeDouble"},{name:"CumulativeMinutes",alias:"Cumulative Minutes",type:"esriFieldTypeDouble"},{name:"CurbApproach",alias:"Curb Approach",type:"esriFieldTypeInteger"},{name:"DepartureCurbApproach",alias:"Departure Curb Approach",type:"esriFieldTypeInteger"},{name:"DepartureTime",alias:"Departure Time",type:"esriFieldTypeDate"},{name:"DepartureUTCOffset",alias:"Departure Time",type:"esriFieldTypeInteger"},{name:"LateMinutes",alias:"Minutes Late",type:"esriFieldTypeDouble"},{name:"LocationType",alias:"Location Type",type:"esriFieldTypeInteger"},{name:"Name",alias:"Name",type:"esriFieldTypeString"},{name:"RouteName",alias:"Route Name",type:"esriFieldTypeString"},{name:"Sequence",alias:"Sequence",type:"esriFieldTypeInteger"},{name:"ServiceCosts",alias:"Service Costs",type:"esriFieldTypeString"},{name:"ServiceMeters",alias:"Service Meters",type:"esriFieldTypeDouble"},{name:"ServiceMinutes",alias:"Service Minutes",type:"esriFieldTypeDouble"},{name:"Status",alias:"Status",type:"esriFieldTypeInteger"},{name:"TimeWindowEnd",alias:"Time Window End",type:"esriFieldTypeDate"},{name:"TimeWindowEndUTCOffset",alias:"Time Window End Offset",type:"esriFieldTypeInteger"},{name:"TimeWindowStart",alias:"Time Window Start",type:"esriFieldTypeDate"},{name:"TimeWindowStartUTCOffset",alias:"Time Window Start Offset",type:"esriFieldTypeInteger"},{name:"WaitMinutes",alias:"Minutes Wait",type:"esriFieldTypeDouble"}],De);t([i({type:k.apiValues,json:{read:{source:"attributes.ArrivalCurbApproach",reader:k.read}}})],p.prototype,"arriveCurbApproach",void 0),t([i({type:Date,json:{read:{source:"attributes.ArriveTimeUTC"}}})],p.prototype,"arriveTime",void 0),t([i()],p.prototype,"arriveTimeOffset",void 0),t([f("arriveTimeOffset",["attributes.ArriveTime","attributes.ArriveTimeUTC"])],p.prototype,"readArriveTimeOffset",null),t([i({json:{name:"attributes.Bearing",read:!1,write:!0}})],p.prototype,"bearing",void 0),t([i({json:{name:"attributes.BearingTol",read:!1,write:!0}})],p.prototype,"bearingTol",void 0),t([i()],p.prototype,"cumulativeCosts",void 0),t([f("cumulativeCosts",["attributes"])],p.prototype,"readCumulativeCosts",null),t([i()],p.prototype,"cumulativeDistance",void 0),t([i()],p.prototype,"cumulativeDuration",void 0),t([i({type:k.apiValues,json:{name:"attributes.CurbApproach",read:{reader:k.read},write:{writer:k.write}}})],p.prototype,"curbApproach",void 0),t([i({type:k.apiValues,json:{read:{source:"attributes.DepartCurbApproach",reader:k.read}}})],p.prototype,"departCurbApproach",void 0),t([i({type:Date,json:{read:{source:"attributes.DepartTimeUTC"}}})],p.prototype,"departTime",void 0),t([i()],p.prototype,"departTimeOffset",void 0),t([f("departTimeOffset",["attributes.DepartTime","attributes.DepartTimeUTC"])],p.prototype,"readDepartTimeOffset",null),t([i({json:{read:{source:"attributes.DistanceToNetworkInMeters"}}})],p.prototype,"distanceToNetworkInMeters",void 0),t([i({type:Me,json:{write:!0}})],p.prototype,"geometry",void 0),t([i()],p.prototype,"lateDuration",void 0),t([i({type:Ae.apiValues,json:{name:"attributes.LocationType",read:{reader:Ae.read},write:{writer:Ae.write}}})],p.prototype,"locationType",void 0),t([i({json:{name:"attributes.Name"}})],p.prototype,"name",void 0),t([i({json:{name:"attributes.NavLatency",read:!1,write:!0}})],p.prototype,"navLatency",void 0),t([i({json:{name:"attributes.ObjectID"}})],p.prototype,"objectId",void 0),t([i({type:ce})],p.prototype,"popupTemplate",void 0),t([i({json:{read:{source:"attributes.PosAlong"}}})],p.prototype,"posAlong",void 0),t([i({json:{name:"attributes.RouteName"}})],p.prototype,"routeName",void 0),t([i()],p.prototype,"serviceCosts",void 0),t([f("serviceCosts",["attributes"])],p.prototype,"readServiceCosts",null),t([U("serviceCosts")],p.prototype,"writeServiceCosts",null),t([i()],p.prototype,"serviceDistance",void 0),t([i()],p.prototype,"serviceDuration",void 0),t([i({json:{name:"attributes.Sequence"}})],p.prototype,"sequence",void 0),t([i({type:qe.apiValues,json:{read:{source:"attributes.SideOfEdge",reader:qe.read}}})],p.prototype,"sideOfEdge",void 0),t([i({json:{read:{source:"attributes.SnapX"}}})],p.prototype,"snapX",void 0),t([i({json:{read:{source:"attributes.SnapY"}}})],p.prototype,"snapY",void 0),t([i({json:{read:{source:"attributes.SnapZ"}}})],p.prototype,"snapZ",void 0),t([i({json:{read:{source:"attributes.SourceID"}}})],p.prototype,"sourceId",void 0),t([i({json:{read:{source:"attributes.SourceOID"}}})],p.prototype,"sourceOid",void 0),t([i({type:pe.apiValues,json:{read:{source:"attributes.Status",reader:pe.read}}})],p.prototype,"status",void 0),t([i({types:he})],p.prototype,"symbol",void 0),t([i({type:Date,json:{name:"attributes.TimeWindowEnd"}})],p.prototype,"timeWindowEnd",void 0),t([U("timeWindowEnd")],p.prototype,"writeTimeWindowEnd",null),t([i()],p.prototype,"timeWindowEndOffset",void 0),t([i({type:Date,json:{name:"attributes.TimeWindowStart"}})],p.prototype,"timeWindowStart",void 0),t([U("timeWindowStart")],p.prototype,"writeTimeWindowStart",null),t([i()],p.prototype,"timeWindowStartOffset",void 0),t([i({readOnly:!0,json:{read:!1}})],p.prototype,"type",void 0),t([i()],p.prototype,"violations",void 0),t([f("violations",["attributes"])],p.prototype,"readViolations",null),t([i()],p.prototype,"waitDuration",void 0),t([i()],p.prototype,"wait",void 0),t([f("wait",["attributes"])],p.prototype,"readWait",null),p=ut=t([j("esri.rest.support.Stop")],p);function Ee(o){if(!o.length)return;const e=o.toArray(),r=e.map(({objectId:a})=>a).filter(a=>a!=null);let s=Math.max(...r,0);for(const a of e)a.objectId==null&&(a.objectId=++s)}function $e(o,e){return!!o.length&&o.length===e.length&&ft(o)&&ft(e)}function ft(o){return o.every(({objectId:e})=>e!=null)}function Ke(o){return o.length?o:null}function pt(o){switch(o){case"esriGeometryPoint":return{type:"esriSMS",style:"esriSMSCircle",size:12,color:[0,0,0,0],outline:pt("esriGeometryPolyline")};case"esriGeometryPolyline":return{type:"esriSLS",style:"esriSLSSolid",width:1,color:[0,0,0,0]};case"esriGeometryPolygon":return{type:"esriSFS",style:"esriSFSNull",outline:pt("esriGeometryPolyline")}}}function xe(o){return"layers"in o}function kr(o){return o.declaredClass==="esri.rest.support.FeatureSet"}function Ur(o){return o.declaredClass==="esri.rest.support.NetworkFeatureSet"}function Wr(o,e){for(const r of o){const s=e.find(a=>a.objectId===r.objectId);s&&(s.addedCost=r.addedCost,s.barrierType=r.barrierType,s.costs=r.costs,s.curbApproach=r.curbApproach,s.fullEdge=r.fullEdge,s.geometry=r.geometry,s.name=r.name,s.sideOfEdge=r.sideOfEdge,s.sourceId=r.sourceId,s.sourceOid=r.sourceOid,s.status=r.status,s.symbol=r.symbol)}}function _r(o,e){for(const r of o){const s=e.find(a=>a.objectId===r.objectId);s&&(s.barrierType=r.barrierType,s.costs=r.costs,s.geometry=r.geometry,s.name=r.name,s.scaleFactor=r.scaleFactor,s.symbol=r.symbol)}}function Vr(o,e){for(const r of o){const s=e.find(a=>a.objectId===r.objectId);s&&(s.barrierType=r.barrierType,s.costs=r.costs,s.geometry=r.geometry,s.name=r.name,s.scaleFactor=r.scaleFactor,s.symbol=r.symbol)}}function Gr(o,e){for(const r of o){const s=e.find(a=>a.objectId===r.objectId);s&&(s.arriveCurbApproach=r.arriveCurbApproach,s.arriveTime=r.arriveTime,s.arriveTimeOffset=r.arriveTimeOffset,s.cumulativeCosts=r.cumulativeCosts,s.cumulativeDistance=r.cumulativeDistance,s.cumulativeDuration=r.cumulativeDuration,s.curbApproach=r.curbApproach,s.departCurbApproach=r.departCurbApproach,s.departTime=r.departTime,s.departTimeOffset=r.departTimeOffset,s.distanceToNetworkInMeters=r.distanceToNetworkInMeters,s.geometry=r.geometry,s.lateDuration=r.lateDuration,s.name=r.name,s.navLatency=r.navLatency,s.posAlong=r.posAlong,s.routeName=r.routeName,s.serviceCosts=r.serviceCosts,s.serviceDistance=r.serviceDistance,s.serviceDuration=r.serviceDuration,s.sequence=r.sequence,s.sideOfEdge=r.sideOfEdge,s.snapX=r.snapX,s.snapY=r.snapY,s.snapZ=r.snapZ,s.sourceId=r.sourceId,s.sourceOid=r.sourceOid,s.status=r.status,s.symbol=r.symbol,s.timeWindowEnd=r.timeWindowEnd,s.timeWindowStart=r.timeWindowStart,s.violations=r.violations,s.waitDuration=r.waitDuration,s.wait=r.wait)}}async function bt(o){const e=ae.WGS84;return await er(o.spatialReference,e),tr(o,e)}function de(o,e){switch(e){case"seconds":return o/60;case"hours":return 60*o;case"days":return 60*o*24;default:return o}}function Xe(o,e){return e==="decimal-degrees"||e==="points"||e==="unknown"?o:rr(o,e,"meters")}function qr(o){const{attributes:e,geometry:r,popupTemplate:s,symbol:a}=o.toGraphic().toJSON();return{attributes:e,geometry:r,popupInfo:s,symbol:a}}const zr=W.ofType($),Zr=W.ofType(I),vt=W.ofType(B),Tt=W.ofType(E),gt=W.ofType(x),wt=W.ofType(p);let g=class extends xt(kt(Ut(Wt(_t(ir))))){constructor(o){super(o),this._cachedServiceDescription=null,this._featureCollection=null,this._type="Feature Collection",this.checksum=null,this.defaultSymbols=new X,this.directionLines=null,this.directionPoints=null,this.featureCollectionType="route",this.legendEnabled=!1,this.maxScale=0,this.minScale=0,this.pointBarriers=new vt,this.polygonBarriers=new Tt,this.polylineBarriers=new gt,this.routeInfo=null,this.spatialReference=ae.WGS84,this.stops=new wt,this.type="route";const e=()=>{this._setStopSymbol(this.stops)};this.addHandles(Vt(()=>this.stops,"change",e,{sync:!0,onListenerAdd:e}))}writeFeatureCollectionWebmap(o,e,r,s){const a=[this._writePolygonBarriers(),this._writePolylineBarriers(),this._writePointBarriers(),this._writeRouteInfo(),this._writeDirectionLines(),this._writeDirectionPoints(),this._writeStops()].filter(y=>!!y),c=a.map((y,O)=>O),n=s.origin==="web-map"?"featureCollection.layers":"layers";Gt(n,a,e),e.opacity=this.opacity,e.visibility=this.visible,e.visibleLayers=c}readDirectionLines(o,e){return this._getNetworkFeatures(e,"DirectionLines",r=>$.fromGraphic(r))}readDirectionPoints(o,e){return this._getNetworkFeatures(e,"DirectionPoints",r=>I.fromGraphic(r))}get fullExtent(){const o=new Nt({xmin:-180,ymin:-90,xmax:180,ymax:90,spatialReference:ae.WGS84});if(this.routeInfo?.geometry!=null)return this.routeInfo.geometry.extent??o;if(this.stops==null)return o;const e=this.stops.filter(a=>a.geometry!=null);if(e.length<2)return o;const{spatialReference:r}=e.at(0).geometry;if(r==null)return o;const s=e.toArray().map(a=>{const c=a.geometry;return[c.x,c.y]});return new qt({points:s,spatialReference:r}).extent}readMaxScale(o,e){return(xe(e)?e.layers:e.featureCollection?.layers)?.find(a=>a.layerDefinition.maxScale!=null)?.layerDefinition.maxScale??0}readMinScale(o,e){return(xe(e)?e.layers:e.featureCollection?.layers)?.find(a=>a.layerDefinition.minScale!=null)?.layerDefinition.minScale??0}readPointBarriers(o,e){return this._getNetworkFeatures(e,"Barriers",r=>B.fromGraphic(r))}readPolygonBarriers(o,e){return this._getNetworkFeatures(e,"PolygonBarriers",r=>E.fromGraphic(r))}readPolylineBarriers(o,e){return this._getNetworkFeatures(e,"PolylineBarriers",r=>x.fromGraphic(r))}readRouteInfo(o,e){return this._getNetworkFeatures(e,"RouteInfo",r=>N.fromGraphic(r)).at(0)??null}readSpatialReference(o,e){const r=xe(e)?e.layers:e.featureCollection?.layers;if(!r?.length)return ae.WGS84;const{layerDefinition:s,featureSet:a}=r[0],c=a.features[0],n=c?.geometry?.spatialReference??a.spatialReference??s.spatialReference??s.extent.spatialReference??yt;return ae.fromJSON(n)}readStops(o,e){return this._getNetworkFeatures(e,"Stops",r=>p.fromGraphic(r),r=>this._setStopSymbol(r))}get title(){return this.routeInfo?.name??"Route"}set title(o){this._overrideIfSome("title",o)}get url(){return mt.routeServiceUrl}set url(o){o!=null?this._set("url",zt(o,et.getLogger(this))):this._set("url",mt.routeServiceUrl)}load(o){return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Feature Collection"]},o)),Promise.resolve(this)}removeAll(){this.removeResult(),this.pointBarriers.removeAll(),this.polygonBarriers.removeAll(),this.polylineBarriers.removeAll(),this.stops.removeAll()}removeResult(){this.directionLines!=null&&(this.directionLines.removeAll(),this._set("directionLines",null)),this.directionPoints!=null&&(this.directionPoints.removeAll(),this._set("directionPoints",null)),this.routeInfo!=null&&this._set("routeInfo",null)}async save(){await this.load();const{fullExtent:o,portalItem:e}=this;if(!e)throw new Y("routelayer:portal-item-not-set","save() requires to the layer to have a portal item");if(!e.id)throw new Y("routelayer:portal-item-not-saved","Please use saveAs() first to save the routelayer");if(e.type!=="Feature Collection")throw new Y("routelayer:portal-item-wrong-type",'Portal item needs to have type "Feature Collection"');if(!this.routeInfo)throw new Y("routelayer:route-unsolved","save() requires a solved route");const{portal:r}=e;await r.signIn(),r.user||await e.reload();const{itemUrl:s,itemControl:a}=e;if(a!=="admin"&&a!=="update")throw new Y("routelayer:insufficient-permissions","To save this layer, you need to be the owner or an administrator of your organization");const c={messages:[],origin:"portal-item",portal:r,url:s?Zt(s):void 0,writtenProperties:[]},n=this.write(void 0,c);return e.extent=await bt(o),e.title=this.title,await e.update({data:n}),e}async saveAs(o,e={}){if(await this.load(),this.routeInfo==null)throw new Y("routelayer:route-unsolved","saveAs() requires a solved route");const r=Ht.from(o).clone();r.extent??(r.extent=await bt(this.fullExtent)),r.id=null,r.portal??(r.portal=Yt.getDefault()),r.title??(r.title=this.title),r.type="Feature Collection",r.typeKeywords=["Data","Feature Collection",Kt.MULTI_LAYER,"Route Layer"];const{portal:s}=r,a={messages:[],origin:"portal-item",portal:s,url:null,writtenProperties:[]};await s.signIn();const c=e?.folder,n=this.write(void 0,a);return await s.user.addItem({item:r,folder:c,data:n}),this.portalItem=r,or(a),a.portalItem=r,r}async solve(o,e){Ee(this.stops),Ee(this.pointBarriers),Ee(this.polylineBarriers),Ee(this.polygonBarriers);const r=o?.stops??this.stops,s=o?.pointBarriers??Ke(this.pointBarriers),a=o?.polylineBarriers??Ke(this.polylineBarriers),c=o?.polygonBarriers??Ke(this.polygonBarriers);if(r==null)throw new Y("routelayer:undefined-stops","the route layer must have stops defined in the route parameters.");if((kr(r)||Ur(r))&&r.features.length<2||W.isCollection(r)&&r.length<2)throw new Y("routelayer:insufficent-stops","the route layer must have two or more stops to solve a route.");if(W.isCollection(r))for(const m of r)m.routeName=null;const n=o?.apiKey,{checksum:y,url:O}=this,A=await this._getServiceDescription(O,n,e),h=o?.travelMode??A.defaultTravelMode,l=o?.accumulateAttributes??[];h&&(l.push(h.distanceAttributeName),h.timeAttributeName&&l.push(h.timeAttributeName));const T={accumulateAttributes:l,checksum:y,directionsOutputType:"featuresets",ignoreInvalidLocations:!0,pointBarriers:s,polylineBarriers:a,polygonBarriers:c,preserveObjectID:!0,returnBarriers:!!s,returnDirections:!0,returnPolygonBarriers:!!c,returnPolylineBarriers:!!a,returnRoutes:!0,returnStops:!0,stops:r},C=u.from(o??{});let w;C.set(T);try{w=await Mr(O,C,e)}catch(m){throw Xt(m)?m:new Y("routelayer:failed-route-request","the routing request failed",{error:m})}const D=this._toRouteLayerSolution(w);return this._isOverridden("title")||(this.title=D.routeInfo.name??"Route"),this._populatePortalFields(D,A,C),D}update(o){const{checksum:e,directionLines:r,directionPoints:s,pointBarriers:a,polygonBarriers:c,polylineBarriers:n,routeInfo:y,stops:O}=o;$e(O,this.stops)?Gr(O,this.stops):this.set({stops:O}),$e(a,this.pointBarriers)?Wr(a,this.pointBarriers):this.set({pointBarriers:a}),$e(n,this.polylineBarriers)?_r(n,this.polylineBarriers):this.set({polylineBarriers:n}),$e(c,this.polygonBarriers)?Vr(c,this.polygonBarriers):this.set({polygonBarriers:c}),this.set({checksum:e}),this._set("directionLines",r),this._set("directionPoints",s),this._set("routeInfo",y),y.geometry!=null&&(this.spatialReference=y.geometry.spatialReference)}_getNetworkFeatures(o,e,r,s){const a=xe(o)?o.layers:o.featureCollection?.layers,c=a?.find(D=>D.layerDefinition.name===e);if(c==null)return new W;const{layerDefinition:n,popupInfo:y,featureSet:O}=c,A=n.drawingInfo.renderer,{features:h}=O,l=O.spatialReference??n.spatialReference??n.extent.spatialReference??yt,T=A&&Qt(A),C=ae.fromJSON(l),w=h.map(D=>{const m=G.fromJSON(D);m.geometry!=null&&D.geometry!=null&&D.geometry.spatialReference==null&&(m.geometry.spatialReference=C);const S=r(m);return S.symbol??(S.symbol=T?.getSymbol(m)??this._getNetworkSymbol(e)),S.popupTemplate??(S.popupTemplate=y&&ce.fromJSON(y)),S});return s&&w.some(({symbol:D})=>!D)&&s(w),new W(w)}_getNetworkSymbol(o){switch(o){case"Barriers":return this.defaultSymbols.pointBarriers;case"DirectionPoints":return this.defaultSymbols.directionPoints;case"DirectionLines":return this.defaultSymbols.directionLines;case"PolylineBarriers":return this.defaultSymbols.polylineBarriers;case"PolygonBarriers":return this.defaultSymbols.polygonBarriers;case"RouteInfo":return this.defaultSymbols.routeInfo;case"Stops":return null}}async _getServiceDescription(o,e,r){if(this._cachedServiceDescription!=null&&this._cachedServiceDescription.url===o)return this._cachedServiceDescription.serviceDescription;const s=await jt(o,e,r);return this._cachedServiceDescription={serviceDescription:s,url:o},s}_setStopSymbol(o){if(!o||!o.length||!this.defaultSymbols.stops||o.every(({symbol:l})=>!!l))return;const{first:e,last:r,middle:s,unlocated:a,waypoint:c,break:n}=this.defaultSymbols.stops,y=o.map(({sequence:l})=>l).filter(l=>l!=null),O=o.length===y.length;if(!this.routeInfo&&!O||o.length===1)return void o.forEach((l,T)=>{switch(T){case 0:l.symbol=e;break;case o.length-1:l.symbol=r;break;default:l.symbol=s}});const A=Math.min(...y),h=Math.max(...y);for(const l of o)l.sequence!==A?l.sequence!==h?this.routeInfo&&l.status!=="ok"&&l.status!=="not-located-on-closest"?l.symbol=a:l.locationType!=="waypoint"?l.locationType!=="break"?l.symbol=s:l.symbol=n:l.symbol=c:l.symbol=r:l.symbol=e}_toRouteLayerSolution(o){const{checksum:e,routeResults:r}=o,s=r[0].stops?.map(l=>p.fromJSON(l.toJSON()));this._setStopSymbol(s);const a=new wt(s),c=new Tt(o.polygonBarriers?.map(l=>{const T=E.fromJSON(l.toJSON());return T.symbol=this.defaultSymbols.polygonBarriers,T})),n=new gt(o.polylineBarriers?.map(l=>{const T=x.fromJSON(l.toJSON());return T.symbol=this.defaultSymbols.polylineBarriers,T})),y=new vt(o.pointBarriers?.map(l=>{const T=B.fromJSON(l.toJSON());return T.symbol=this.defaultSymbols.pointBarriers,T})),O=r[0].route?.toJSON(),A=N.fromJSON(O);A.symbol=this.defaultSymbols.routeInfo;const h=new Zr(r[0].directionPoints?.features.map(l=>{const T=I.fromJSON(l.toJSON());return T.symbol=this.defaultSymbols.directionPoints,T}));return{checksum:e,directionLines:new zr(r[0].directionLines?.features.map(l=>{const T=$.fromJSON(l.toJSON());return T.symbol=this.defaultSymbols.directionLines,T})),directionPoints:h,pointBarriers:y,polygonBarriers:c,polylineBarriers:n,routeInfo:A,stops:a}}_writeDirectionLines(){return this._writeNetworkFeatures(this.directionLines,this.defaultSymbols.directionLines,"esriGeometryPolyline",$.fields,"DirectionLines","Direction Lines")}_writeDirectionPoints(){return this._writeNetworkFeatures(this.directionPoints,this.defaultSymbols.directionPoints,"esriGeometryPoint",I.fields,"DirectionPoints","Direction Points")}_writeNetworkFeatures(o,e,r,s,a,c){if(!o?.length)return null;const n=this.spatialReference.toJSON(),{fullExtent:y,maxScale:O,minScale:A}=this;return{featureSet:{features:o.toArray().map(h=>qr(h)),geometryType:r,spatialReference:n},layerDefinition:{capabilities:"Query,Update,Editing",drawingInfo:{renderer:{type:"simple",symbol:e!=null?e.toJSON():pt(r)}},extent:y.toJSON(),fields:s,geometryType:r,hasM:!1,hasZ:!1,maxScale:O,minScale:A,name:a,objectIdField:"ObjectID",spatialReference:n,title:c,type:"Feature Layer",typeIdField:""}}}_writePointBarriers(){return this._writeNetworkFeatures(this.pointBarriers,this.defaultSymbols.pointBarriers,"esriGeometryPoint",B.fields,"Barriers","Point Barriers")}_writePolygonBarriers(){return this._writeNetworkFeatures(this.polygonBarriers,this.defaultSymbols.polygonBarriers,"esriGeometryPolygon",E.fields,"PolygonBarriers","Polygon Barriers")}_writePolylineBarriers(){return this._writeNetworkFeatures(this.polylineBarriers,this.defaultSymbols.polylineBarriers,"esriGeometryPolyline",x.fields,"PolylineBarriers","Line Barriers")}_writeRouteInfo(){return this._writeNetworkFeatures(this.routeInfo!=null?new W([this.routeInfo]):null,this.defaultSymbols.routeInfo,"esriGeometryPolyline",N.fields,"RouteInfo","Route Details")}_writeStops(){const o=this._writeNetworkFeatures(this.stops,null,"esriGeometryPoint",p.fields,"Stops","Stops");if(o==null)return null;const{stops:e}=this.defaultSymbols,r=e?.first?.toJSON(),s=e?.middle?.toJSON(),a=e?.last?.toJSON();return o.layerDefinition.drawingInfo.renderer={type:"uniqueValue",field1:"Sequence",defaultSymbol:s,uniqueValueInfos:[{value:"1",symbol:r,label:"First Stop"},{value:`${this.stops.length}`,symbol:a,label:"Last Stop"}]},o}_populatePortalFields(o,e,r){const s=e.networkDataset?.networkAttributes,a=s?.filter(({usageType:d})=>d==="cost")??[],c=r.travelMode??e.defaultTravelMode;if(c==null)return void et.getLogger(this).warn("route-layer:missing-travel-mode","The routing service must have a default travel mode or one must be specified in the route parameter.");const{timeAttributeName:n,distanceAttributeName:y}=c,O=a.find(({name:d})=>d===n),A=a.find(({name:d})=>d===y),h=r.travelMode?.impedanceAttributeName??r.impedanceAttribute??e.impedance,l=O?.units,T=A?.units;if(!l||!T)throw new Y("routelayer:unknown-impedance-units","the units of either the distance or time impedance are unknown");const C=r.directionsLanguage??e.directionsLanguage,w=r.accumulateAttributes??e.accumulateAttributeNames??[],D=new Set(a.filter(({name:d})=>d===n||d===y||d===h||d!=null&&w.includes(d)).map(({name:d})=>d)),m=d=>{for(const dt in d)D.has(dt)||delete d[dt]};for(const d of o.pointBarriers)d.costs!=null&&(d.addedCost=d.costs[h]??0,m(d.costs));for(const d of o.polygonBarriers)d.costs!=null&&(d.scaleFactor=d.costs[h]??1,m(d.costs));for(const d of o.polylineBarriers)d.costs!=null&&(d.scaleFactor=d.costs[h]??1,m(d.costs));const{routeInfo:S}=o,{findBestSequence:v,preserveFirstStop:L,preserveLastStop:b,startTimeIsUTC:J,timeWindowsAreUTC:oe}=r;S.analysisSettings=new V({accumulateAttributes:w,directionsLanguage:C,findBestSequence:v,preserveFirstStop:L,preserveLastStop:b,startTimeIsUTC:J,timeWindowsAreUTC:oe,travelMode:c}),S.totalDuration=de(S.totalCosts?.[n]??0,l),S.totalDistance=Xe(S.totalCosts?.[y]??0,T),S.totalLateDuration=de(S.totalViolations?.[n]??0,l),S.totalWaitDuration=de(S.totalWait?.[n]??0,l),S.totalCosts!=null&&m(S.totalCosts),S.totalViolations!=null&&m(S.totalViolations),S.totalWait!=null&&m(S.totalWait);for(const d of o.stops)d.serviceCosts!=null&&(d.serviceDuration=de(d.serviceCosts[n]??0,l),d.serviceDistance=Xe(d.serviceCosts[y]??0,T),m(d.serviceCosts)),d.cumulativeCosts!=null&&(d.cumulativeDuration=de(d.cumulativeCosts[n]??0,l),d.cumulativeDistance=Xe(d.cumulativeCosts[y]??0,T),m(d.cumulativeCosts)),d.violations!=null&&(d.lateDuration=de(d.violations[n]??0,l),m(d.violations)),d.wait!=null&&(d.waitDuration=de(d.wait[n]??0,l),m(d.wait))}};t([i({readOnly:!0,json:{read:!1,origins:{"portal-item":{write:{allowNull:!0,ignoreOrigin:!0}},"web-map":{write:{overridePolicy(){return{allowNull:!0,ignoreOrigin:this.portalItem==null}}}}}}})],g.prototype,"_featureCollection",void 0),t([U(["web-map","portal-item"],"_featureCollection")],g.prototype,"writeFeatureCollectionWebmap",null),t([i({readOnly:!0,json:{read:!1,origins:{"web-map":{write:{target:"type",overridePolicy(){return{ignoreOrigin:this.portalItem!=null}}}}}}})],g.prototype,"_type",void 0),t([i({type:String})],g.prototype,"checksum",void 0),t([i({nonNullable:!0,type:X})],g.prototype,"defaultSymbols",void 0),t([i({readOnly:!0})],g.prototype,"directionLines",void 0),t([f(["web-map","portal-item"],"directionLines",["layers","featureCollection.layers"])],g.prototype,"readDirectionLines",null),t([i({readOnly:!0})],g.prototype,"directionPoints",void 0),t([f(["web-map","portal-item"],"directionPoints",["layers","featureCollection.layers"])],g.prototype,"readDirectionPoints",null),t([i({readOnly:!0,json:{read:!1,origins:{"web-map":{write:{ignoreOrigin:!0}}}}})],g.prototype,"featureCollectionType",void 0),t([i({readOnly:!0})],g.prototype,"fullExtent",null),t([i({json:{origins:{"web-map":{name:"featureCollection.showLegend"}},write:!0}})],g.prototype,"legendEnabled",void 0),t([i({type:["show","hide"]})],g.prototype,"listMode",void 0),t([i({type:Number,nonNullable:!0,json:{write:!1}})],g.prototype,"maxScale",void 0),t([f(["web-map","portal-item"],"maxScale",["layers","featureCollection.layers"])],g.prototype,"readMaxScale",null),t([i({type:Number,nonNullable:!0,json:{write:!1}})],g.prototype,"minScale",void 0),t([f(["web-map","portal-item"],"minScale",["layers","featureCollection.layers"])],g.prototype,"readMinScale",null),t([i({type:["ArcGISFeatureLayer"],value:"ArcGISFeatureLayer"})],g.prototype,"operationalLayerType",void 0),t([i({nonNullable:!0,type:W.ofType(B)})],g.prototype,"pointBarriers",void 0),t([f(["web-map","portal-item"],"pointBarriers",["layers","featureCollection.layers"])],g.prototype,"readPointBarriers",null),t([i({nonNullable:!0,type:W.ofType(E)})],g.prototype,"polygonBarriers",void 0),t([f(["web-map","portal-item"],"polygonBarriers",["layers","featureCollection.layers"])],g.prototype,"readPolygonBarriers",null),t([i({nonNullable:!0,type:W.ofType(x)})],g.prototype,"polylineBarriers",void 0),t([f(["web-map","portal-item"],"polylineBarriers",["layers","featureCollection.layers"])],g.prototype,"readPolylineBarriers",null),t([i({readOnly:!0})],g.prototype,"routeInfo",void 0),t([f(["web-map","portal-item"],"routeInfo",["layers","featureCollection.layers"])],g.prototype,"readRouteInfo",null),t([i({type:ae})],g.prototype,"spatialReference",void 0),t([f(["web-map","portal-item"],"spatialReference",["layers","featureCollection.layers"])],g.prototype,"readSpatialReference",null),t([i({nonNullable:!0,type:W.ofType(p)})],g.prototype,"stops",void 0),t([f(["web-map","portal-item"],"stops",["layers","featureCollection.layers"])],g.prototype,"readStops",null),t([i()],g.prototype,"title",null),t([i({readOnly:!0,json:{read:!1}})],g.prototype,"type",void 0),t([i()],g.prototype,"url",null),g=t([j("esri.layers.RouteLayer")],g);const mi=g;export{mi as default};
