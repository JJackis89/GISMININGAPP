import{aE as j,ga as fe,hr as ge,H as Re,a6 as pe,p as Pe,hM as xe,ew as ne,iK as be,hK as Q,am as Se,_ as Be,eT as ie,ey as Ee,cq as ye}from"./index-8ee34b61.js";import{a as Ce}from"./devEnvironmentUtils-00b414cb.js";import{i as oe,j as Le,n as Ne}from"./mat3-848c9a5e.js";import{n as te,e as Te}from"./mat3f64-d34bdb1e.js";import{r as ae,t as Ue,e as je}from"./mat4f64-a3dc1405.js";import{a as Fe}from"./vec2f64-44b9a02c.js";import{o as C,u as S,g as L,W as ke,E as re,c as qe,i as ue,r as ze,A as De,I as He}from"./vec32-37618b70.js";import{S as Ve,n as V,e as Ge,c as We,o as Ke,L as we,W as Y,t as Qe,s as Ye,a as Ze,b as Je,d as Xe,f as G}from"./DefaultMaterial-e8c850aa.js";import{s as et,T as ve,g as tt,M as rt,o as $e,O as st,V as nt}from"./BufferView-b8fa1162.js";import{r as it,n as ot,d as le,l as ce}from"./vec3-fc54a44a.js";import{o as at,d as he}from"./vec4-63e2976c.js";import{n as ut,o as lt,b as ct}from"./indexUtils-70808102.js";import{n as W}from"./resourceUtils-eec94bba.js";import{a as ht,i as mt}from"./vec2f32-d593cd8d.js";import{u as dt}from"./memoryEstimations-95fc020c.js";import{e as ft,A as _e}from"./Indices-e0ee64fb.js";import{t as k}from"./orientedBoundingBox-8de5994f.js";import{t as gt,e as se,i as A,n as pt}from"./basicInterfaces-cbf2757f.js";import{e as I}from"./VertexAttribute-123db042.js";import{P as me}from"./enums-ff43618c.js";import{a as de}from"./NormalAttribute.glsl-3245b73c.js";import"./videoUtils-18e4b8a5.js";import"./TextureFormat-60b88abd.js";import"./sphere-2ec54985.js";import"./vectorStacks-f3f45332.js";import"./quatf64-216ddd5a.js";import"./lineSegment-de126745.js";import"./InterleavedLayout-842614cb.js";import"./types-d99602e0.js";import"./plane-881ab901.js";import"./vec2-08ad2285.js";import"./quat-3ef9ebee.js";import"./spatialReferenceEllipsoidUtils-b06c2c3c.js";import"./computeTranslationToOriginAndRotation-e96691a8.js";function xt(s,e){if(!s)return!1;const{size:t,data:r,indices:a}=s;C(e,0,0,0),C(_,0,0,0);let u=0,i=0;for(let o=0;o<a.length-2;o+=3){const c=a[o]*t,n=a[o+1]*t,l=a[o+2]*t;C(b,r[c],r[c+1],r[c+2]),C(B,r[n],r[n+1],r[n+2]),C(K,r[l],r[l+1],r[l+2]);const h=Ve(b,B,K);h?(S(b,b,B),S(b,b,K),L(b,b,1/3*h),S(e,e,b),u+=h):(S(_,_,b),S(_,_,B),S(_,_,K),i+=3)}return(i!==0||u!==0)&&(u!==0?(L(e,e,1/u),!0):i!==0&&(L(e,_,1/i),!0))}function bt(s,e){if(!s)return!1;const{size:t,data:r,indices:a}=s;C(e,0,0,0);let u=-1,i=0;for(let o=0;o<a.length;o++){const c=a[o]*t;u!==c&&(e[0]+=r[c],e[1]+=r[c+1],e[2]+=r[c+2],i++),u=c}return i>1&&L(e,e,1/i),i>0}function yt(s,e,t){if(!s)return!1;C(t,0,0,0),C(_,0,0,0);let r=0,a=0;const{size:u,data:i,indices:o}=s,c=o.length-1,n=c+(e?2:0);for(let l=0;l<n;l+=2){const h=l<c?l+1:0,g=o[l<c?l:c]*u,d=o[h]*u;b[0]=i[g],b[1]=i[g+1],b[2]=i[g+2],B[0]=i[d],B[1]=i[d+1],B[2]=i[d+2],L(b,S(b,b,B),.5);const p=ke(b,B);p>0?(S(t,t,L(b,b,p)),r+=p):r===0&&(S(_,_,b),a++)}return r!==0?(L(t,t,1/r),!0):a!==0&&(L(t,_,1/a),!0)}const b=j(),B=j(),K=j(),_=j();class Tt{constructor(){this.uid=fe()}}class wt extends Tt{constructor(e){super(),this.highlightName=e,this.channel=gt.Highlight}}class Z{constructor(e,t,r=null,a=V.Mesh,u=null,i=-1){this.material=e,this.mapPositions=r,this.type=a,this.objectAndLayerIdColor=u,this.edgeIndicesLength=i,this.highlights=new Set,this._highlightOptionsCounts=new Map,this.id=fe(),this.visible=!0,this._attributes=new Map,this._boundingInfo=null;for(const[o,c]of t)this._attributes.set(o,{...c,indices:ft(c.indices)}),o===I.POSITION&&(this.edgeIndicesLength=this.edgeIndicesLength<0?this._attributes.get(o).indices.length:this.edgeIndicesLength)}instantiate(e={}){const t=new Z(e.material||this.material,[],this.mapPositions,this.type,this.objectAndLayerIdColor,this.edgeIndicesLength);return this._attributes.forEach((r,a)=>{r.exclusive=!1,t._attributes.set(a,r)}),t._boundingInfo=this._boundingInfo,t.transformation=e.transformation||this.transformation,t}get attributes(){return this._attributes}getMutableAttribute(e){let t=this._attributes.get(e);return t&&!t.exclusive&&(t={...t,exclusive:!0,data:Ge(t.data)},this._attributes.set(e,t)),t}setAttributeData(e,t){const r=this._attributes.get(e);r?this._attributes.set(e,{...r,exclusive:!0,data:t}):We()&&console.warn(`Setting undefined attribute ${e} data`)}get indexCount(){return this._attributes.values().next().value?.indices?.length??0}get faceCount(){return this.indexCount/3}get boundingInfo(){return this._boundingInfo??(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo}computeAttachmentOrigin(e){return!!(this.type===V.Mesh?this._computeAttachmentOriginTriangles(e):this.type===V.Line?this._computeAttachmentOriginLines(e):this._computeAttachmentOriginPoints(e))&&(this._transformation!=null&&re(e,e,this._transformation),!0)}_computeAttachmentOriginTriangles(e){const t=this.attributes.get(I.POSITION);return xt(t,e)}_computeAttachmentOriginLines(e){const t=this.attributes.get(I.POSITION);return yt(t,vt(this.material.parameters,t),e)}_computeAttachmentOriginPoints(e){const t=this.attributes.get(I.POSITION);return bt(t,e)}invalidateBoundingInfo(){this._boundingInfo=null}_calculateBoundingInfo(){const e=this.attributes.get(I.POSITION);if(!e||e.indices.length===0)return null;const t=this.type===V.Mesh?3:1;et(e.indices.length%t===0,"Indexing error: "+e.indices.length+" not divisible by "+t);const r=_e(e.indices.length/t);return new Ke(r,t,e)}get transformation(){return this._transformation??ae}set transformation(e){this._transformation=e&&e!==ae?Ue(e):null}get highlightNames(){return this._highlightOptionsCounts}get hasHighlights(){return this._highlightOptionsCounts.size>0}foreachHighlightOptions(e){this._highlightOptionsCounts.forEach((t,r)=>e(r))}allocateIdAndHighlight(e){const t=new wt(e);return this.addHighlight(t)}addHighlight(e){this.highlights.add(e);const{highlightName:t}=e,r=(this._highlightOptionsCounts.get(t)??0)+1;return this._highlightOptionsCounts.set(t,r),e}removeHighlight(e){if(this.highlights.delete(e)){const{highlightName:t}=e,r=this._highlightOptionsCounts.get(t)??0;r<=1?this._highlightOptionsCounts.delete(t):this._highlightOptionsCounts.set(t,r-1)}}}function vt(s,e){return!(!("isClosed"in s)||!s.isClosed)&&e.indices.length>2}function q(s){if(s==null)return null;const e=s.offset!=null?s.offset:ht,t=s.rotation!=null?s.rotation:0,r=s.scale!=null?s.scale:mt,a=te(1,0,0,0,1,0,e[0],e[1],1),u=te(Math.cos(t),-Math.sin(t),0,Math.sin(t),Math.cos(t),0,0,0,1),i=te(r[0],0,0,0,r[1],0,0,0,1),o=Te();return oe(o,u,i),oe(o,a,o),o}class $t{constructor(){this.geometries=new Array,this.materials=new Array,this.textures=new Array}}let _t=class{constructor(e,t,r){this.name=e,this.lodThreshold=t,this.pivotOffset=r,this.stageResources=new $t,this.numberOfVertices=0}};class It{constructor(){this._outer=new Map}clear(){this._outer.clear()}get empty(){return this._outer.size===0}get outerSize(){return this._outer.size}get(e,t){return this._outer.get(e)?.get(t)}getInner(e){return this._outer.get(e)}set(e,t,r){const a=this._outer.get(e);a?a.set(t,r):this._outer.set(e,new Map([[t,r]]))}delete(e,t){const r=this._outer.get(e);r&&(r.delete(t),r.size===0&&this._outer.delete(e))}forEach(e){this._outer.forEach((t,r)=>e(t,r))}forAll(e){this._outer.forEach((t,r)=>t.forEach((a,u)=>e(a,r,u)))}}const P=()=>Se.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");class Ot{constructor(e,t,r){this.resource=e,this.textures=t,this.cachedMemory=r}}async function At(s,e){const t=await Mt(s,e),r=await Et(t.textureDefinitions??{},e);let a=0;for(const u in r)if(r.hasOwnProperty(u)){const i=r[u];a+=i?.image?i.image.width*i.image.height*4:0}return new Ot(t,r,a+dt(t))}async function Mt(s,e){const t=e?.streamDataRequester;if(t)return Rt(s,t,e);const r=await ge(Re(s,e));if(r.ok===!0)return r.value.data;pe(r.error),Ie(r.error)}async function Rt(s,e,t){const r=await ge(e.request(s,"json",t));if(r.ok===!0)return r.value;pe(r.error),Ie(r.error.details.url)}function Ie(s){throw new Pe("",`Request for object resource failed: ${s}`)}function Pt(s){const e=s.params,t=e.topology;let r=!0;switch(e.vertexAttributes||(P().warn("Geometry must specify vertex attributes"),r=!1),e.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const u=e.faces;if(u){if(e.vertexAttributes)for(const i in e.vertexAttributes){const o=u[i];o?.values?(o.valueType!=null&&o.valueType!=="UInt32"&&(P().warn(`Unsupported indexed geometry indices type '${o.valueType}', only UInt32 is currently supported`),r=!1),o.valuesPerElement!=null&&o.valuesPerElement!==1&&(P().warn(`Unsupported indexed geometry values per element '${o.valuesPerElement}', only 1 is currently supported`),r=!1)):(P().warn(`Indexed geometry does not specify face indices for '${i}' attribute`),r=!1)}}else P().warn("Indexed geometries must specify faces"),r=!1;break}default:P().warn(`Unsupported topology '${t}'`),r=!1}s.params.material||(P().warn("Geometry requires material"),r=!1);const a=s.params.vertexAttributes;for(const u in a)a[u].values||(P().warn("Geometries with externally defined attributes are not yet supported"),r=!1);return r}function St(s,e){const t=new Array,r=new Array,a=new Array,u=new It,i=s.resource,o=xe.parse(i.version||"1.0","wosr");Lt.validate(o);const c=i.model.name,n=i.model.geometries,l=i.materialDefinitions??{},h=s.textures;let g=0;const d=new Map;for(let p=0;p<n.length;p++){const m=n[p];if(!Pt(m))continue;const w=Ct(m),T=m.params.vertexAttributes,v=[],x=f=>{if(m.params.topology==="PerAttributeArray")return null;const O=m.params.faces;for(const y in O)if(y===f)return O[y].values;return null},$=T[I.POSITION],z=$.values.length/$.valuesPerElement;for(const f in T){const O=T[f],y=O.values,X=x(f)??_e(z);v.push([f,new k(y,X,O.valuesPerElement,!0)])}const M=w.texture,N=h&&h[M];if(N&&!d.has(M)){const{image:f,parameters:O}=N,y=new we(f,O);r.push(y),d.set(M,y)}const D=d.get(M),J=D?D.id:void 0,R=w.material;let E=u.get(R,M);if(E==null){const f=l[R.slice(R.lastIndexOf("/")+1)].params;f.transparency===1&&(f.transparency=0);const O=N?Oe(N.alphaChannelUsage):void 0,y={ambient:ne(f.diffuse),diffuse:ne(f.diffuse),opacity:1-(f.transparency||0),textureAlphaMode:O,textureAlphaCutoff:.33,textureId:J,doubleSided:!0,cullFace:se.None,colorMixMode:f.externalColorMixMode||"tint",textureAlphaPremultiplied:N?.parameters.preMultiplyAlpha??!1};e?.materialParameters&&Object.assign(y,e.materialParameters),E=new Y(y,e),u.set(R,M,E)}a.push(E);const H=new Z(E,v);g+=v.find(f=>f[0]===I.POSITION)?.[1]?.indices.length??0,t.push(H)}return{engineResources:[{name:c,stageResources:{textures:r,materials:a,geometries:t},pivotOffset:i.model.pivotOffset,numberOfVertices:g,lodThreshold:null}],referenceBoundingBox:Bt(t)}}function Bt(s){const e=be();return s.forEach(t=>{const r=t.boundingInfo;r!=null&&(Q(e,r.bbMin),Q(e,r.bbMax))}),e}async function Et(s,e){const t=new Array;for(const u in s){const i=s[u],o=i.images[0].data;if(!o){P().warn("Externally referenced texture data is not yet supported");continue}const c=i.encoding+";base64,"+o,n="/textureDefinitions/"+u,l=i.channels==="rgba"?i.alphaChannelUsage||"transparency":"none",h={noUnpackFlip:!0,wrap:{s:me.REPEAT,t:me.REPEAT},preMultiplyAlpha:Oe(l)!==A.Opaque},g=e?.disableTextures?Promise.resolve(null):Qe(c,e);t.push(g.then(d=>({refId:n,image:d,parameters:h,alphaChannelUsage:l})))}const r=await Promise.all(t),a={};for(const u of r)a[u.refId]=u;return a}function Oe(s){switch(s){case"mask":return A.Mask;case"maskAndTransparency":return A.MaskBlend;case"none":return A.Opaque;default:return A.Blend}}function Ct(s){const e=s.params;return{id:1,material:e.material,texture:e.texture,region:e.texture}}const Lt=new xe(1,2,"wosr");async function $r(s,e){const t=Nt(Ce(s));if(t.fileType==="wosr"){const h=await(e.cache?e.cache.loadWOSR(t.url,e):At(t.url,e)),{engineResources:g,referenceBoundingBox:d}=St(h,e);return{lods:g,referenceBoundingBox:d,isEsriSymbolResource:!1,isWosr:!0}}let r;if(e.cache)r=await e.cache.loadGLTF(t.url,e,!!e.usePBR);else{const{loadGLTF:h}=await Be(()=>import("./loader-40a3241e.js"),["assets/loader-40a3241e.js","assets/index-8ee34b61.js","assets/index-a5714ce2.css","assets/mat4f64-a3dc1405.js","assets/enums-ff43618c.js","assets/quat-3ef9ebee.js","assets/mat3f64-d34bdb1e.js","assets/quatf64-216ddd5a.js","assets/vec32-37618b70.js","assets/BufferView-b8fa1162.js","assets/vec2-08ad2285.js","assets/vec2f64-44b9a02c.js","assets/resourceUtils-eec94bba.js","assets/basicInterfaces-cbf2757f.js"]);r=await h(new ut(e.streamDataRequester),t.url,e,e.usePBR)}const a=r.model.meta?.ESRI_proxyEllipsoid,u=r.meta.isEsriSymbolResource&&a!=null&&r.meta.ESRI_webstyle==="EsriRealisticTreesStyle";u&&!r.customMeta.esriTreeRendering&&(r.customMeta.esriTreeRendering=!0,qt(r,a));const i=!!e.usePBR,o=r.meta.isEsriSymbolResource?{usePBR:i,isSchematic:!1,treeRendering:u,mrrFactors:Ye}:{usePBR:i,isSchematic:!1,treeRendering:!1,mrrFactors:Ze},c={...e.materialParameters,treeRendering:u},{engineResources:n,referenceBoundingBox:l}=Ut(r,o,c,e,t.specifiedLodIndex,u);return{lods:n,referenceBoundingBox:l,isEsriSymbolResource:r.meta.isEsriSymbolResource,isWosr:!1}}function Nt(s){const e=s.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/);return e?{fileType:"gltf",url:e[1],specifiedLodIndex:e[4]!=null?Number(e[4]):null}:s.match(/(.*\.(json|json\.gz))$/)?{fileType:"wosr",url:s,specifiedLodIndex:null}:{fileType:"unknown",url:s,specifiedLodIndex:null}}function Ut(s,e,t,r,a,u){const i=s.model,o=new Array,c=new Map,n=new Map,l=i.lods.length,h=be();return i.lods.forEach((g,d)=>{const p=r.skipHighLods===!0&&(l>1&&d===0||l>3&&d===1)||r.skipHighLods===!1&&a!=null&&d!==a;if(p&&d!==0)return;const m=new _t(g.name,g.lodThreshold,[0,0,0]);g.parts.forEach(w=>{const T=p?new Y({},r):jt(i,w,m,e,t,c,n,r,u),{geometry:v,vertexCount:x}=Ft(w,T??new Y({},r)),$=v.boundingInfo;$!=null&&d===0&&(Q(h,$.bbMin),Q(h,$.bbMax)),T!=null&&(m.stageResources.geometries.push(v),m.numberOfVertices+=x)}),p||o.push(m)}),{engineResources:o,referenceBoundingBox:h}}function jt(s,e,t,r,a,u,i,o,c){const n=s.materials.get(e.material);if(n==null)return null;const{normal:l,color:h,texCoord0:g,tangent:d}=e.attributes,p=e.material+(l?"_normal":"")+(h?"_color":"")+(g?"_texCoord0":"")+(d?"_tangent":""),m=e.attributes.texCoord0!=null,w=e.attributes.normal!=null,T=kt(n.alphaMode);if(!u.has(p)){if(m){const f=(y,X=!1,Ae=!1)=>{if(y!=null&&!i.has(y)){const ee=s.textures.get(y);if(ee){const U=ee.data,Me=X&&!W(U)?o.compressionOptions:void 0;i.set(y,new we(W(U)?U.data:U,{...ee.parameters,preMultiplyAlpha:!W(U)&&Ae,encoding:W(U)?U.encoding:void 0,compressionOptions:Me}))}}},O=T!==A.Opaque&&!c;f(n.colorTexture,O,T!==A.Opaque),f(n.normalTexture),f(n.occlusionTexture,!0),f(n.emissiveTexture),f(n.metallicRoughnessTexture,!0)}const x=1/ye,$=n.color[0]**x,z=n.color[1]**x,M=n.color[2]**x,N=n.emissiveFactor[0]**x,D=n.emissiveFactor[1]**x,J=n.emissiveFactor[2]**x,R=n.colorTexture!=null&&m?i.get(n.colorTexture):null,E=Je(n),H=n.normalTextureTransform?.scale!=null?n.normalTextureTransform?.scale:Fe;u.set(p,new Y({...r,customDepthTest:pt.Lequal,textureAlphaMode:T,textureAlphaCutoff:n.alphaCutoff,diffuse:[$,z,M],ambient:[$,z,M],opacity:n.alphaMode==="OPAQUE"?1:n.opacity,doubleSided:n.doubleSided,doubleSidedType:"winding-order",cullFace:n.doubleSided?se.None:se.Back,hasVertexColors:!!e.attributes.color,hasVertexTangents:!!e.attributes.tangent,normalType:w?de.Attribute:de.ScreenDerivative,castShadows:!0,receiveShadows:n.receiveShadows,receiveAmbientOcclusion:n.receiveAmbientOcclusion,textureId:R?.id,colorMixMode:n.colorMixMode,normalTextureId:n.normalTexture!=null&&m?i.get(n.normalTexture).id:void 0,textureAlphaPremultiplied:R!=null&&!!R.parameters.preMultiplyAlpha,occlusionTextureId:n.occlusionTexture!=null&&m?i.get(n.occlusionTexture).id:void 0,emissiveTextureId:n.emissiveTexture!=null&&m?i.get(n.emissiveTexture).id:void 0,metallicRoughnessTextureId:n.metallicRoughnessTexture!=null&&m?i.get(n.metallicRoughnessTexture).id:void 0,emissiveBaseColor:[N,D,J],mrrFactors:E?Xe:[n.metallicFactor,n.roughnessFactor,r.mrrFactors[2]],isSchematic:E,colorTextureTransformMatrix:q(n.colorTextureTransform),normalTextureTransformMatrix:q(n.normalTextureTransform),scale:[H[0],H[1]],occlusionTextureTransformMatrix:q(n.occlusionTextureTransform),emissiveTextureTransformMatrix:q(n.emissiveTextureTransform),metallicRoughnessTextureTransformMatrix:q(n.metallicRoughnessTextureTransform),...a},o))}const v=u.get(p);if(t.stageResources.materials.push(v),m){const x=$=>{$!=null&&t.stageResources.textures.push(i.get($))};x(n.colorTexture),x(n.normalTexture),x(n.occlusionTexture),x(n.emissiveTexture),x(n.metallicRoughnessTexture)}return v}function Ft(s,e){const t=s.attributes.position.count,r=lt(s.indices||t,s.primitiveType),a=G(3*t),{typedBuffer:u,typedBufferStride:i}=s.attributes.position;it(a,u,s.transform,3,i);const o=[[I.POSITION,new k(a,r,3,!0)]];if(s.attributes.normal!=null){const n=G(3*t),{typedBuffer:l,typedBufferStride:h}=s.attributes.normal;Le(F,s.transform),ot(n,l,F,3,h),ie(F)&&le(n,n),o.push([I.NORMAL,new k(n,r,3,!0)])}if(s.attributes.tangent!=null){const n=G(4*t),{typedBuffer:l,typedBufferStride:h}=s.attributes.tangent;Ne(F,s.transform),at(n,l,F,4,h),ie(F)&&le(n,n,4),o.push([I.TANGENT,new k(n,r,4,!0)])}if(s.attributes.texCoord0!=null){const n=G(2*t),{typedBuffer:l,typedBufferStride:h}=s.attributes.texCoord0;ct(n,l,2,h),o.push([I.UV0,new k(n,r,2,!0)])}const c=s.attributes.color;if(c!=null){const n=new Uint8Array(4*t);c.elementCount===4?c instanceof ve?he(n,c,1,255):(c instanceof tt||c instanceof rt)&&he(n,c,1/255,255):(n.fill(255),c instanceof $e?ce(n,c.typedBuffer,1,255,4,c.typedBufferStride):(s.attributes.color instanceof st||s.attributes.color instanceof nt)&&ce(n,c.typedBuffer,1/255,255,4,s.attributes.color.typedBufferStride)),o.push([I.COLOR,new k(n,r,4,!0)])}return{geometry:new Z(e,o),vertexCount:t}}const F=Te();function kt(s){switch(s){case"BLEND":return A.Blend;case"MASK":return A.Mask;case"OPAQUE":case null:case void 0:return A.Opaque}}function qt(s,e){for(let t=0;t<s.model.lods.length;++t){const r=s.model.lods[t];for(const a of r.parts){const u=a.attributes.normal;if(u==null)return;const i=a.attributes.position,o=i.count,c=j(),n=j(),l=j(),h=new Float32Array(4*o),g=new Float32Array(3*o),d=Ee(je(),a.transform);let p=0,m=0;for(let w=0;w<o;w++){i.getVec(w,n),u.getVec(w,c),re(n,n,a.transform),qe(l,n,e.center),ue(l,l,e.radius);const T=l[2],v=ze(l),x=Math.min(.45+.55*v*v,1)**ye;ue(l,l,e.radius),d!==null&&re(l,l,d),De(l,l),t+1!==s.model.lods.length&&s.model.lods.length>1&&He(l,l,c,T>-1?.2:Math.min(-4*T-3.8,1)),g[p]=l[0],g[p+1]=l[1],g[p+2]=l[2],p+=3,h[m]=x,h[m+1]=x,h[m+2]=x,h[m+3]=1,m+=4}a.attributes.normal=new $e(g),a.attributes.color=new ve(h)}}}export{$r as fetch,Nt as parseUrl};
