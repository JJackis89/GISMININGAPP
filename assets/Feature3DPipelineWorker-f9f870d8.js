import{kN as tn,gD as rn,bZ as ft,kO as nn,kP as an,kQ as br,ew as ht,gF as qe,co as sn,kR as on,aE as V,kS as mt,kT as ln,kU as vr,kV as zt,c7 as cn,ei as dn,eh as un,kW as fn,f6 as hn,e_ as mn,fQ as pn,ga as gn,r as S,m as N,a as xr,cr as yn,hu as _n,cB as jt,el as bn,kX as vn,ix as xn,ee as pt,ef as gt,T as $e,io as Cn,L as Cr,ad as Lt,aI as wn,kY as In,cv as Sn,c8 as wr,hJ as On,cx as An,p as Pn,dH as $n,i6 as Tn,j6 as Rn,_ as En,kZ as Bt,ey as Pt,cV as Dn,ca as Ir,ea as Fn,f9 as tt,b1 as Mn,eY as Sr,f1 as zn,hD as Or,i8 as Se,k_ as jn,du as Ln,ec as Bn,aw as Ut,f as Vt,ap as Nt,z as Un,d2 as Vn,d3 as Nn,ac as Gn,g4 as kn}from"./index-8ee34b61.js";import{L as Hn}from"./QueryEngine-bec069b7.js";import{e as Ce}from"./mat4f64-a3dc1405.js";import{c as Z,_ as nt,A as me,o as Oe,E as pe,g as J,s as q,r as Te,p as Ar,u as $t,R as qn,N as Qn,P as Wn}from"./vec32-37618b70.js";import"./MeshLocalVertexSpace-b4d6a09d.js";import{o as Tt,r as Xn,I as Yn}from"./vec2-08ad2285.js";import{r as G,n as Rt}from"./vec2f64-44b9a02c.js";import{g as Zn,h as Gt,f as kt,e as Jn,H as Ht,Q as qt,d as Kn,j as Pr,k as ea,l as ta,p as Et,q as yt,r as Qe,u as ra,w as na,x as $r,y as Tr,z as aa,A as ia,B as Rr,C as sa,D as oa,E as la,F as ca,G as da,I as Qt,J as at,M as Wt,N as ua,O as K,P as fa,T as Ae,U as ha,V as ma,X as pa,Y as ga,Z as ya,_ as _a,$ as ba,a0 as va,a1 as D,a2 as xa,a3 as Ca,a4 as wa,a5 as Ia,a6 as re,a7 as Sa,a8 as Er,a9 as Dr,aa as Oa,ab as Aa,ac as Pa,ad as $a,ae as Ta,af as Ra,ag as Ea,ah as Da,ai as Xt,aj as Yt,ak as Fa,al as Ma,am as za,an as Zt,W as ja,o as La,ao as Ba,ap as Ua}from"./DefaultMaterial-e8c850aa.js";import{n as We}from"./projectVectorToVector-05a9d263.js";import{e as Va,A as Na}from"./Indices-e0ee64fb.js";import{o as Ga}from"./floatRGBA-d8c359da.js";import{P as Jt,R as Kt,C as ka}from"./enums-ff43618c.js";import{t as k,l as fe}from"./orientedBoundingBox-8de5994f.js";import{e as g}from"./VertexAttribute-123db042.js";import{m as Ha}from"./computeTranslationToOriginAndRotation-e96691a8.js";import{r as L,n as Ee}from"./vec3f32-5edf24fc.js";import{q as qa}from"./plane-881ab901.js";import{V as Qa,f as Wa,u as Xa}from"./sphere-2ec54985.js";import{e as er}from"./basicInterfaces-cbf2757f.js";import"./IntersectorType-fff45762.js";import{s as tr}from"./ReactiveMap-240c4127.js";import{s as ve,t as Ya,n as Fr,a as Za}from"./memoryEstimations-95fc020c.js";import{s as Ja,E as Mr}from"./PooledRBush-f0ac9ac2.js";import{n as Ka,e as _t}from"./OptimizedFeature-eb8a9ca3.js";import{m as ei}from"./query-769e0ffd.js";import{a as ti}from"./pbf-7aa9e413.js";import{u as ri}from"./quantizationUtils-b1a838dd.js";import{b as ni,h as ai}from"./pbfQueryUtils-926ff7f8.js";import{n as zr}from"./mat3-848c9a5e.js";import{e as jr}from"./mat3f64-d34bdb1e.js";import{s as ii,g as si,o as rr,f as oi,y as li,T as nr}from"./BufferView-b8fa1162.js";import{O as ci}from"./InterleavedLayout-842614cb.js";import{n as b,b as di,c as H,t as M,u as Lr,w as it}from"./NormalAttribute.glsl-3245b73c.js";import{a as ui}from"./spatialReferenceEllipsoidUtils-b06c2c3c.js";import{i as fi}from"./projectPointToVector-030380a1.js";import{c as ee}from"./vectorStacks-f3f45332.js";function hi(a){a.code.add(b`const float MAX_RGBA_FLOAT =
255.0 / 256.0 +
255.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 / 256.0;
const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
vec4 float2rgba(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);
vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);
const float toU8AsFloat = 1.0 / 255.0;
return fixedPointU8 * toU8AsFloat;
}`),a.code.add(b`const vec4 RGBA_TO_FLOAT_FACTORS = vec4(
255.0 / (256.0),
255.0 / (256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0 * 256.0)
);
float rgbaTofloat(vec4 rgba) {
return dot(rgba, RGBA_TO_FLOAT_FACTORS);
}`),a.code.add(b`const vec4 uninterpolatedRGBAToFloatFactors = vec4(
1.0 / 256.0,
1.0 / 256.0 / 256.0,
1.0 / 256.0 / 256.0 / 256.0,
1.0 / 256.0 / 256.0 / 256.0 / 256.0
);
float uninterpolatedRGBAToFloat(vec4 rgba) {
return (dot(round(rgba * 255.0), uninterpolatedRGBAToFloatFactors) - 0.5) * 2.0;
}`)}let mi=class extends Zn{constructor(e,t){super(e,"vec4",di.Draw,(r,n,i)=>r.setUniform4fv(e,t(n,i)))}},Q=class Br{constructor(e,t,r){this.renderCommandContext=e,this.renderCommandBuffer=t,this.pipelineStateCommands=r}append(e){this.appendRenderCommands(e.renderCommandBuffer),this.appendPipelineStateCommands(e.pipelineStateCommands)}appendRenderCommands(e){this.renderCommandBuffer.commands.push(...e.commands),this.renderCommandBuffer.transferList.push(...e.transferList)}appendPipelineStateCommand(e){this.pipelineStateCommands.push(e)}appendPipelineStateCommands(e){for(const t of e)this.appendPipelineStateCommand(t)}async execute(){for(const e of this.pipelineStateCommands)e();await this.renderCommandContext.dispatchRenderCommands(this.renderCommandBuffer)}static create(e,t=[]){return new Br(e,e.createRenderCommandBuffer(),t)}};function pi(a){return a.length===0?null:a.reduce((e,t)=>(e.append(t),e))}function Ur(){return new tn({material:new rn({color:new ft("red")})})}function gi(){return new nn}function yi(a,e,t=null){const r=an(br);return a!=null&&(r[0]=a[0],r[1]=a[1],r[2]=a[2]),e!=null?r[3]=e:a!=null&&a.length>3&&(r[3]=a[3]),t&&(r[0]*=t,r[1]*=t,r[2]*=t,r[3]*=t),r}function _i(a=qe,e,t,r=1){const n=new Array(3);if(e==null||t==null)n[0]=1,n[1]=1,n[2]=1;else{let i,s=0;for(let o=2;o>=0;o--){const c=a[o],d=c!=null,f=o===0&&!i&&!d,l=t[o];let u;c==="symbol-value"||f?u=l!==0?e[o]/l:1:d&&c!=="proportional"&&isFinite(c)&&(u=l!==0?c/l:1),u!=null&&(n[o]=u,i=u,s=Math.max(s,Math.abs(u)))}for(let o=2;o>=0;o--)n[o]==null?n[o]=i:n[o]===0&&(n[o]=.001*s)}for(let i=2;i>=0;i--)n[i]/=r;return ht(n)}var ar;(function(a){a[a.Left=0]="Left",a[a.Center=1]="Center",a[a.Right=2]="Right"})(ar||(ar={}));const bi=Object.freeze({"bottom-left":G(0,0),bottom:G(.5,0),"bottom-right":G(1,0),left:G(0,.5),center:G(.5,.5),right:G(1,.5),"top-left":G(0,1),top:G(.5,1),"top-right":G(1,1)});function Dt(a){const{featureCount:e}=a;if(e===0)return new Uint32Array;const t=new Uint32Array(e);return a.getObjectIdsArray(t),t}function bt(a){const{featureCount:e}=a;if(e===0)return new Float64Array;const t=new Float64Array(3*e);return a.getCoordinatesArray(t),t}function vi(a,e){const t=a.length/3,r=e.viewSpatialReference,n=e.renderSpatialReference,i=new Float64Array(3*t);if(!sn(a,r,0,i,n,0,t))throw new Error("Failed to project coordinates");return i}function ir(a,e){const t=e.viewSpatialReference,r=e.renderSpatialReference,{extent:n}=a,i=on(n),s=V();return We([i[0],i[1],0],t,s,r),s}function Vr(a){const e=new Map;for(const[t,r]of a)e.set(t,{...r,indices:Va(r.indices)});return e}const Nr=128,he=.5,xi=mt(he/2,he/2,1-he/2,1-he/2);function Ci(a){return a==="cross"||a==="x"}function wi(a,e=Nr,t=e*he,r=0){return{data:Ii(a,e,t,r),parameters:{mipmap:!1,wrap:{s:Jt.CLAMP_TO_EDGE,t:Jt.CLAMP_TO_EDGE},width:e,height:e,components:4,noUnpackFlip:!0,reloadable:!0}}}function Ii(a,e=Nr,t=e*he,r=0){switch(a){case"circle":default:return Si(e,t);case"square":return Oi(e,t);case"cross":return Pi(e,t,r);case"x":return $i(e,t,r);case"kite":return Ai(e,t);case"triangle":return Ti(e,t);case"arrow":return Ri(e,t)}}function Si(a,e){const t=a/2-.5;return De(a,Hr(t,t,e/2))}function Oi(a,e){return Gr(a,e,!1)}function Ai(a,e){return Gr(a,e,!0)}function Pi(a,e,t=0){return kr(a,e,!1,t)}function $i(a,e,t=0){return kr(a,e,!0,t)}function Ti(a,e){return De(a,qr(a/2,e,e/2))}function Ri(a,e){const t=e,r=e/2,n=a/2,i=.8*t,s=Hr(n,(a-e)/2-i,Math.sqrt(i*i+r*r)),o=qr(n,t,r);return De(a,(c,d)=>Math.max(o(c,d),-s(c,d)))}function Gr(a,e,t){return t&&(e/=Math.SQRT2),De(a,(r,n)=>{let i=r-.5*a+.25,s=.5*a-n-.75;if(t){const o=(i+s)/Math.SQRT2;s=(s-i)/Math.SQRT2,i=o}return Math.max(Math.abs(i),Math.abs(s))-.5*e})}function kr(a,e,t,r=0){e-=r,t&&(e*=Math.SQRT2);const n=.5*e;return De(a,(i,s)=>{let o,c=i-.5*a,d=.5*a-s-1;if(t){const f=(c+d)/Math.SQRT2;d=(d-c)/Math.SQRT2,c=f}return c=Math.abs(c),d=Math.abs(d),o=c>d?c>n?Math.sqrt((c-n)*(c-n)+d*d):d:d>n?Math.sqrt(c*c+(d-n)*(d-n)):c,o-=r/2,o})}function Hr(a,e,t){return(r,n)=>{const i=r-a,s=n-e;return Math.sqrt(i*i+s*s)-t}}function qr(a,e,t){const r=Math.sqrt(e*e+t*t);return(n,i)=>{const s=Math.abs(n-a)-t,o=i-a+e/2+.75,c=(e*s+t*o)/r,d=-o;return Math.max(c,d)}}function De(a,e){const t=new Uint8Array(4*a*a);for(let r=0;r<a;r++)for(let n=0;n<a;n++){const i=n+a*r;let s=e(n,r);s=s/a+.5,Ga(s,t,4*i)}return t}let vt=class{constructor(e,t){this._context=null,this._symbolLayer=null,this._draped=!1,this._loaded=!1,this._loadingPromise=null,this._iconTextureID=null,this._materialId=null,this._context=t,this._symbolLayer=e}get loaded(){return this._loaded}load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}_destroy(){this._iconTextureID=null}async _load(){const e=this._context.renderCommandContext,t=await e.createTexture(()=>wi("circle"));this._iconTextureID=t;const r={anchorPosition:bi.center,occlusionTest:!0,hasSlicePlane:!1,color:this._getFillColor(),outlineColor:this._getOutlineColor(),outlineSize:1,distanceFieldBoundingBox:xi,textureId:t,textureIsSignedDistanceField:!0,sampleSignedDistanceFieldTexelCenter:Ci("circle")};this._materialId=await e.createMaterial({type:"hud",parameters:r}),await e.createDirectRenderer(this._materialId),this._loaded=!0}async createAddCommand(e){const{_materialId:t,_context:r}=this,{renderCommandContext:n}=r;if(t==null)throw new Error("expected material not to be null");const i=await this._createGeometry(e);if(i==null)return r.createPipelineCommand();const s=ir(e,r);return r.createPipelineCommand(n.addDirectRendererGeometry(e.id,i,s))}async _createGeometry(e){const{_materialId:t,_context:r}=this,{mainThreadDelegate:n}=r,{featureCount:i}=e;if(i===0||t==null)return null;const s=Dt(e),o=bt(e),c=await n.applyElevationAlignmentTo(o),d=vi(c,r),f=new Float64Array([0,0,1]),l=new Float64Array([255,255,255,255]),u=new Float64Array([24,24]),p=new Float64Array([0,0,0,1]),_=new Float64Array([0,0]),w=new Float64Array([0]),C=new Uint32Array(i);for(let T=0;T<i;++T)C[T]=T;const m=new Uint32Array(i);for(let T=0;T<i;++T)m[T]=0;const y=new k(d,C,3,!0),x=new k(f,m,3,!0),I=new k(_,m,2,!0),h=new k(l,m,4,!0),P=new k(w,m,1,!0),R=new k(u,m,2,!0),v=new k(p,m,4,!0),j=[[g.POSITION,y],[g.NORMAL,x],[g.UV0,I],[g.COLOR,h],[g.ROTATION,P],[g.SIZE,R],[g.CENTEROFFSETANDDISTANCE,v]],z=new Uint8Array(i);return e.getVisibilityArray(z),{attributes:Vr(j),objectAndLayerIdColor:void 0,transformation:Ce(),materialId:t,objectIds:s,visibilities:z}}async createRemoveCommand(e){const{_materialId:t,_context:r}=this,n=r.renderCommandContext;return t==null?r.createPipelineCommand():r.createPipelineCommand(n.removeDirectRendererGeometryBuffer(t,e))}async createUpdateVisibilityCommand(e){const{_materialId:t,_context:r}=this,n=r.renderCommandContext;if(t==null)return r.createPipelineCommand();const i=new Uint8Array(e.featureCount);return e.getVisibilityArray(i),r.createPipelineCommand(n.updateVisibility(t,e.id,i))}async createUpdateLayerViewOpacityCommand(e){const{_context:t,_materialId:r}=this,n=t.renderCommandContext;return r==null?t.createPipelineCommand():t.createPipelineCommand(n.updateMaterial({type:"hud",materialId:r,parameters:{color:this._getFillColor(),outlineColor:this._getOutlineColor()}}))}async createUpdateElevationCommand(e){const{_materialId:t,_context:r}=this,{renderCommandContext:n}=r,{featureCount:i,id:s}=e;if(t==null||i===0)return r.createPipelineCommand();const o=await this._createGeometry(e);if(o==null)return r.createPipelineCommand();const c=ir(e,r);return r.createPipelineCommand(n.updateDirectRendererGeometry(s,o,c))}async createDestroyCommand(){const{_iconTextureID:e,_context:t}=this,r=t.renderCommandContext;let n;return n=e!=null?await r.releaseTexture(e):Q.create(r),n.appendPipelineStateCommand(()=>this._destroy()),n}_getOutlineColor(){const e=this._getLayerOpacity(),t=this._symbolLayer,r=t?.outline?.color;if(r!=null){const n=ft.toUnitRGB(r),i=r.a*e;return[n[0],n[1],n[2],i]}return[0,0,0,0]}_getFillColor(){if(Ei(this._getPrimitive()))return Fi;const e=this._getPrimitive()==null,t=this._symbolLayer?.material?.color;return this._getCombinedOpacityAndColor(t,{hasIntrinsicColor:e})}_getLayerOpacity(){return this._context.layerViewInfo.fullOpacity}_getCombinedOpacity(e,t=sr){const r=this._draped?1:this._getLayerOpacity();return e?r*e.a:t.hasIntrinsicColor?r:0}_getCombinedOpacityAndColor(e,t=sr){const r=this._getCombinedOpacity(e,t),n=e!=null?ft.toUnitRGB(e):qe;return yi(n,r)}_getPrimitive(){return Di(this._symbolLayer)}};function Ei(a){return a!=null&&(a==="cross"||a==="x")}function Di(a){return a.resource?.href?null:a.resource?.primitive??ln}const sr={hasIntrinsicColor:!1},Fi=vr;let Mi=class{constructor(e,t){this._loaded=!1,this._loadingPromise=null,this._context=null,this._symbol=null,this._symbolLayerRenderers=[],this._context=t,this._symbol=e}_destroy(){}get loaded(){return this._loaded}load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}async _load(){const{_context:e,_symbol:t,_symbolLayerRenderers:r}=this,n=[];for(const i of t.symbolLayers){const s=e.symbolRendererFactory.createSymbolRendererFromSymbolLayer(i);s!=null&&(n.push(s.load()),r.push(s))}await Promise.all(n),this._loaded=!0}async createDestroyCommand(){const{_context:e,_symbolLayerRenderers:t}=this,r=[];for(const i of t)r.push(i.createDestroyCommand());const n=e.joinPipelineCommands(await Promise.all(r));return n.appendPipelineStateCommand(()=>this._destroy()),n}async createAddCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,n=[];for(const i of r)n.push(i.createAddCommand(e));return t.joinPipelineCommands(await Promise.all(n))}async createRemoveCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,n=[];for(const i of r)n.push(i.createRemoveCommand(e));return t.joinPipelineCommands(await Promise.all(n))}async createUpdateVisibilityCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,n=[];for(const i of r)n.push(i.createUpdateVisibilityCommand(e));return t.joinPipelineCommands(await Promise.all(n))}async createUpdateLayerViewOpacityCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,n=[];for(const i of r)n.push(i.createUpdateLayerViewOpacityCommand(e));return t.joinPipelineCommands(await Promise.all(n))}async createUpdateElevationCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,n=[];for(const i of r)n.push(i.createUpdateElevationCommand(e));return t.joinPipelineCommands(await Promise.all(n))}},zi=class{constructor(e,t){this._symbol=null,this._featureData=new Map,this._loaded=!1,this._loadingPromise=null,this._renderer=null,this._context=t,this._renderer=e}async load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}async _load(){const{_renderer:e,_context:t}=this;this._symbol=t.symbolRendererFactory.createSymbolRendererFromSymbol(e.symbol),this._loaded=!0}get loaded(){return this._loaded}async createAddCommand(e){const t=this._context,r=await this._provisionSymbol(),n=r==null?t.createPipelineCommand():await r.createAddCommand(e);return n.appendPipelineStateCommand(()=>this._featureData.set(e.id,e)),n}async createRemoveCommand(e){const t=this._context,r=await this._provisionSymbol(),n=r==null?t.createPipelineCommand():await r.createRemoveCommand(e);return n.appendPipelineStateCommand(()=>this._featureData.delete(e)),n}async createUpdateVisibilityCommand(e){const t=this._context,r=await this._provisionSymbol();return r==null?t.createPipelineCommand():await r.createUpdateVisibilityCommand(e)}async createUpdateLayerViewOpacityCommand(e){const t=this._context,r=await this._provisionSymbol();return r==null?t.createPipelineCommand():await r.createUpdateLayerViewOpacityCommand(e)}async createUpdateElevationCommand(){const{_featureData:e,_context:t}=this,r=await this._provisionSymbol();if(r==null)return t.createPipelineCommand();const n=[];for(const s of e.values())n.push(r.createUpdateElevationCommand(s));const i=await Promise.all(n);return t.joinPipelineCommands(i)}async createDestroyCommand(){const{_symbol:e,_context:t,_featureData:r}=this;if(!e)return t.createPipelineCommand();const n=[];for(const s of r.keys())n.push(this.createRemoveCommand(s));n.push(e.createDestroyCommand());const i=await Promise.all(n);return t.joinPipelineCommands(i)}async _provisionSymbol(){const e=this._symbol;return e?(e.loaded||await e.load(),e):null}};var xt;(function(a){function e(s,o){const c=s[o],d=s[o+1],f=s[o+2];return Math.sqrt(c*c+d*d+f*f)}function t(s,o){const c=s[o],d=s[o+1],f=s[o+2],l=1/Math.sqrt(c*c+d*d+f*f);s[o]*=l,s[o+1]*=l,s[o+2]*=l}function r(s,o,c){s[o]*=c,s[o+1]*=c,s[o+2]*=c}function n(s,o,c,d,f,l=o){(f=f||s)[l]=s[o]+c[d],f[l+1]=s[o+1]+c[d+1],f[l+2]=s[o+2]+c[d+2]}function i(s,o,c,d,f,l=o){(f=f||s)[l]=s[o]-c[d],f[l+1]=s[o+1]-c[d+1],f[l+2]=s[o+2]-c[d+2]}a.length=e,a.normalize=t,a.scale=r,a.add=n,a.subtract=i})(xt||(xt={}));const ne=xt,ji=new Array(36);for(let a=0;a<6;a++)for(let e=0;e<6;e++)ji[6*a+e]=a;const ae=new Array(36);for(let a=0;a<6;a++)ae[6*a]=0,ae[6*a+1]=1,ae[6*a+2]=2,ae[6*a+3]=2,ae[6*a+4]=3,ae[6*a+5]=0;const st=L(-.5,0,-.5),ot=L(.5,0,-.5),lt=L(0,0,.5),ct=L(0,.5,0),ie=Ee(),se=Ee(),ge=Ee(),ye=Ee(),_e=Ee();Z(ie,st,ct),Z(se,st,ot),nt(ge,ie,se),me(ge,ge),Z(ie,ot,ct),Z(se,ot,lt),nt(ye,ie,se),me(ye,ye),Z(ie,lt,ct),Z(se,lt,st),nt(_e,ie,se),me(_e,_e);ge[0],ge[1],ge[2],ye[0],ye[1],ye[2],_e[0],_e[1],_e[2];function Li(a,e,t){const r=a;let n,i;if(t)n=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],i=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const d=r*(1+Math.sqrt(5))/2;n=[-r,d,0,r,d,0,-r,-d,0,r,-d,0,0,-r,d,0,r,d,0,-r,-d,0,r,-d,d,0,-r,d,0,r,-d,0,-r,-d,0,r],i=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let d=0;d<n.length;d+=3)ne.scale(n,d,a/ne.length(n,d));let s={};function o(d,f){d>f&&([d,f]=[f,d]);const l=d.toString()+"."+f.toString();if(s[l])return s[l];let u=n.length;return n.length+=3,ne.add(n,3*d,n,3*f,n,u),ne.scale(n,u,a/ne.length(n,u)),u/=3,s[l]=u,u}for(let d=0;d<e;d++){const f=i.length,l=new Array(4*f);for(let u=0;u<f;u+=3){const p=i[u],_=i[u+1],w=i[u+2],C=o(p,_),m=o(_,w),y=o(w,p),x=4*u;l[x]=p,l[x+1]=C,l[x+2]=y,l[x+3]=_,l[x+4]=m,l[x+5]=C,l[x+6]=w,l[x+7]=y,l[x+8]=m,l[x+9]=C,l[x+10]=m,l[x+11]=y}i=l,s={}}const c=Gt(n);for(let d=0;d<c.length;d+=3)ne.normalize(c,d);return[[g.POSITION,new k(Gt(n),i,3,!0)],[g.NORMAL,new k(c,i,3,!0)]]}function Bi(a,e,t,r,n=!0,i=!0){let s=0;const o=e,c=a;let d=L(0,s,0),f=L(0,s+c,0),l=L(0,-1,0),u=L(0,1,0);r&&(s=c,f=L(0,0,0),d=L(0,s,0),l=L(0,1,0),u=L(0,-1,0));const p=[f,d],_=[l,u],w=t+2,C=Math.sqrt(c*c+o*o);if(r)for(let h=t-1;h>=0;h--){const P=h*(2*Math.PI/t),R=L(Math.cos(P)*o,s,Math.sin(P)*o);p.push(R);const v=L(c*Math.cos(P)/C,-o/C,c*Math.sin(P)/C);_.push(v)}else for(let h=0;h<t;h++){const P=h*(2*Math.PI/t),R=L(Math.cos(P)*o,s,Math.sin(P)*o);p.push(R);const v=L(c*Math.cos(P)/C,o/C,c*Math.sin(P)/C);_.push(v)}const m=new Array,y=new Array;if(n){for(let h=3;h<p.length;h++)m.push(1),m.push(h-1),m.push(h),y.push(0),y.push(0),y.push(0);m.push(p.length-1),m.push(2),m.push(1),y.push(0),y.push(0),y.push(0)}if(i){for(let h=3;h<p.length;h++)m.push(h),m.push(h-1),m.push(0),y.push(h),y.push(h-1),y.push(1);m.push(0),m.push(2),m.push(p.length-1),y.push(1),y.push(2),y.push(_.length-1)}const x=kt(3*w);for(let h=0;h<w;h++)x[3*h]=p[h][0],x[3*h+1]=p[h][1],x[3*h+2]=p[h][2];const I=kt(3*w);for(let h=0;h<w;h++)I[3*h]=_[h][0],I[3*h+1]=_[h][1],I[3*h+2]=_[h][2];return[[g.POSITION,new k(x,m,3,!0)],[g.NORMAL,new k(I,y,3,!0)]]}function Ui(a){switch(a){case"sphere":case"cube":case"diamond":case"cylinder":case"cone":case"inverted-cone":case"tetrahedron":return!0}return!1}function Vi(a,e){const t=(r,n,i=!1)=>({levels:r.map(s=>{const o=Vr(n(s.tesselation));return i&&Ni(o),{components:[{attributes:o,objectAndLayerIdColor:void 0,transformation:null,materialId:e,visibilities:new Uint8Array([1]),objectIds:new Uint32Array([-1])}],minScreenSpaceRadius:s.minScreenSpaceRadius}})});switch(a){case"cone":return t(Gi,r=>Bi(1,.5,r,!1),!0);case"sphere":return t([{tesselation:0,minScreenSpaceRadius:0},{tesselation:1,minScreenSpaceRadius:8},{tesselation:2,minScreenSpaceRadius:16},{tesselation:3,minScreenSpaceRadius:50},{tesselation:4,minScreenSpaceRadius:250}],r=>Li(.5,r,!0));case"cube":case"inverted-cone":case"cylinder":case"tetrahedron":case"diamond":throw new Error("not implemented");default:return}}function Ni(a){const e=a,t=e.get(g.POSITION).data,r=e.get(g.NORMAL).data;if(r){const n=or(a,g.NORMAL).data;for(let i=0;i<r.length;i+=3){const s=r[i+1];n[i+1]=-r[i+2],n[i+2]=s}}if(t){const n=or(a,g.POSITION).data;for(let i=0;i<t.length;i+=3){const s=t[i+1];n[i+1]=-t[i+2],n[i+2]=s}}}function or(a,e){let t=a.get(e);return t&&!t.exclusive&&(t={...t,exclusive:!0,data:Jn(t.data)},a.set(e,t)),t}const Gi=[{tesselation:6,minScreenSpaceRadius:0},{tesselation:18,minScreenSpaceRadius:7},{tesselation:64,minScreenSpaceRadius:65}];let ki=class{constructor(e,t){this._loaded=!1,this._loadingPromise=null,this._primitiveMaterialId=null,this._lodRendererId=null,this._context=null,this._symbolLayer=null,this._primitive=null,this._context=t,this._symbolLayer=e}_destroy(){this._lodRendererId=null,this._primitiveMaterialId=null}get loaded(){return this._loaded}get _isPrimitive(){return this._primitive!=null}load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}async _load(){const e=this._context.renderCommandContext,t={physicalBasedRenderingEnabled:!0,slicePlaneEnabled:!1,castShadows:!0},r=this._getLayerOpacity();let n={usePBR:t.physicalBasedRenderingEnabled,isSchematic:!0,mrrFactors:Kn,ambient:qe,diffuse:qe,hasSlicePlane:t.slicePlaneEnabled,castShadows:t.castShadows,layerOpacity:r,offsetTransparentBackfaces:!1,screenSizePerspective:{}};if(n.externalColor=br,n.isInstanced=!0,this._isPrimitive){const c=new Ht;c.layerOpacity=r,n={...n,cullFace:lr(qt(c))}}const i=await e.createMaterial({type:"default",parameters:n}),s=this._symbolLayer.resource;this._primitive=s&&Ui(s?.primitive)?s.primitive:zt;const o=Vi(this._primitive,i);this._lodRendererId=await e.createLodRenderer(o),this._primitiveMaterialId=i,this._loaded=!0}async createDestroyCommand(){const{_lodRendererId:e,_primitiveMaterialId:t,_context:r}=this,n=r.renderCommandContext,i=[];return e!=null&&i.push(n.destroyLodRenderer(e)),t!=null&&i.push(n.destroyMaterial(t)),new Q(n,n.mergeRenderCommandBuffers(i),[()=>this._destroy()])}async createAddCommand(e){const t=this._context,{renderCommandContext:r,mainThreadDelegate:n}=t;if(this._lodRendererId==null)throw new Error("expected lod renderer id to not be null");const{featureCount:i}=e;if(i===0)return t.createPipelineCommand();const s=this._isPrimitive,o=this._primitive||zt,c=cn(dn(o)),d=ht(un(c)),f=ht(fn(d,{isPrimitive:s,width:100,depth:null,height:null})),l=new Float64Array(16*i),u=new Float64Array(16*i),p=bt(e),_=await n.applyElevationAlignmentTo(p);for(let y=0;y<i;++y){const x=y,I=_[3*y+0],h=_[3*y+1],P=_[3*y+2],R=this._computeGlobalTransform(I,h,P,this._context.viewSpatialReference,cr),v=this._computeLocalTransform(f,d,Hi);this._writeMatrixToTypedBuffer(l,x,v),this._writeMatrixToTypedBuffer(u,x,R)}const w=Dt(e),C=new Uint8Array(i);e.getVisibilityArray(C);const m={featureIds:new Uint32Array(w),visibility:C,localTransforms:l,globalTransforms:u};return t.createPipelineCommand(r.addLodInstances(this._lodRendererId,e.id,m))}async createRemoveCommand(e){const{_context:t,_lodRendererId:r}=this,n=t.renderCommandContext;return r==null?t.createPipelineCommand():t.createPipelineCommand(n.removeLodInstances(r,e))}async createUpdateVisibilityCommand(e){const{_lodRendererId:t,_context:r}=this,n=r.renderCommandContext;if(t==null)return r.createPipelineCommand();const i=new Uint8Array(e.featureCount);return e.getVisibilityArray(i),r.createPipelineCommand(n.updateVisibility(t,e.id,i))}async createUpdateLayerViewOpacityCommand(e){const{_context:t}=this,r=t.renderCommandContext,n=this._primitiveMaterialId;if(n==null)return t.createPipelineCommand();const i=this._getLayerOpacity();let s={layerOpacity:i};if(this._isPrimitive){const o=new Ht;o.layerOpacity=i,s={...s,cullFace:lr(qt(o))}}return t.createPipelineCommand(r.updateMaterial({type:"default",materialId:n,parameters:s}))}async createUpdateElevationCommand(e){const{_context:t,_lodRendererId:r}=this,{renderCommandContext:n,mainThreadDelegate:i}=t,{featureCount:s,id:o}=e;if(r==null||s===0)return t.createPipelineCommand();const c=new Float64Array(16*s),d=bt(e),f=await i.applyElevationAlignmentTo(d);for(let l=0;l<s;++l){const u=l,p=f[3*l+0],_=f[3*l+1],w=f[3*l+2],C=this._computeGlobalTransform(p,_,w,this._context.viewSpatialReference,cr);this._writeMatrixToTypedBuffer(c,u,C)}return t.createPipelineCommand(n.updateLodInstancesData(r,o,c))}_writeMatrixToTypedBuffer(e,t,r){let n=16*t;for(let i=0;i<16;i++)e[n++]=r[i]}_computeGlobalTransform(e,t,r,n,i){return je[0]=e,je[1]=t,je[2]=r,Ha(n,je,i,this._context.renderSpatialReference),i}_computeLocalTransform(e,t,r){return hn(r),this._applyObjectScale(e,t,r),r}_applyObjectScale(e,t,r){const n=_i(e,e,t,this._context.renderCoordsHelper.unitInMeters);n[0]===1&&n[1]===1&&n[2]===1||mn(r,r,n)}_getLayerOpacity(){return this._context.layerViewInfo.fullOpacity}};function lr(a){return a?er.None:er.Back}const je=V(),Hi=Ce(),cr=Ce();let qi=class{constructor(e,t){this._symbols=new Array,this._featureDataPartitioning=new Map,this._loaded=!1,this._loadingPromise=null,this._renderer=null,this._context=t,this._renderer=e}async load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}async _load(){this._symbols[0]=new vt(Ur(),this._context),this._symbols[1]=new ki(gi(),this._context),this._loaded=!0}get loaded(){return this._loaded}async createAddCommand(e){const t=this._context,r=this._partition(e),n=await Promise.all(r.map(async({index:s,features:o})=>await(await this._provisionSymbol(s))?.createAddCommand(o))),i=t.joinPipelineCommands(n);return i.appendPipelineStateCommand(()=>this._featureDataPartitioning.set(e.id,r)),i}async createRemoveCommand(e){const{_featureDataPartitioning:t,_context:r}=this,n=r.renderCommandContext,i=t.get(e);if(i==null)return new Q(n,n.createRenderCommandBuffer(),[]);const s=await Promise.all(i.map(async({index:c,features:d})=>await this._getLoadedSymbol(c)?.createRemoveCommand(d.id))),o=r.joinPipelineCommands(s);return o.appendPipelineStateCommand(()=>t.delete(e)),o}async createUpdateVisibilityCommand(e){const{_featureDataPartitioning:t,_context:r}=this,n=r.renderCommandContext,i=t.get(e.id);if(i==null)return new Q(n,n.createRenderCommandBuffer(),[]);const s=await Promise.all(i.map(async({index:o,features:c})=>await this._getLoadedSymbol(o)?.createUpdateVisibilityCommand(c)));return r.joinPipelineCommands(s)}async createUpdateLayerViewOpacityCommand(e){const t=this._context,r=[];for(let i=0;i<this._symbols.length;++i){const s=this._symbols[i];s!=null&&s.loaded&&r.push(s.createUpdateLayerViewOpacityCommand(e))}const n=await Promise.all(r);return t.joinPipelineCommands(n)}async createUpdateElevationCommand(){const{_featureDataPartitioning:e,_context:t}=this,r=[];for(const i of e.values()){const s=i.map(async({index:o,features:c})=>await this._getLoadedSymbol(o)?.createUpdateElevationCommand(c));r.push(...s)}const n=await Promise.all(r);return t.joinPipelineCommands(n)}async createDestroyCommand(){const{_featureDataPartitioning:e,_context:t}=this,r=[];for(const i of e.keys())r.push(this.createRemoveCommand(i));for(const i of this._symbols)r.push(i.createDestroyCommand());const n=await Promise.all(r);return t.joinPipelineCommands(n)}async _provisionSymbol(e){if(e==null)return null;const t=this._symbols[e];return t?(t.loaded||await t.load(),t):null}_getLoadedSymbol(e){if(e==null)return null;const t=this._symbols[e];return t!=null&&t.loaded?t:null}_partition(e){const t=Dt(e);if(t==null)throw new Error("unable to fetch objectIds");const{featureCount:r}=e,n=[[],[]];for(let i=0;i<r;++i)n[t[i]%2].push(i);return n.map((i,s)=>new Qi(s,e.subset(new Uint32Array(i)))).filter(i=>i.features.featureCount>0)}},Qi=class{constructor(e,t){this.index=e,this.features=t}},Wi=class{constructor(e,t,r,n,i,s,o){this.viewSpatialReference=e,this.renderSpatialReference=t,this.mainThreadDelegate=r,this.renderCoordsHelper=n,this.renderCommandContext=i,this.layerInfo=s,this.layerViewInfo=o,this.symbolRendererFactory=new Xi(this)}createPipelineCommand(e=this.renderCommandContext.createRenderCommandBuffer(),t=[]){return new Q(this.renderCommandContext,e,t)}joinPipelineCommands(e){return e.length===0?this.createPipelineCommand():e.filter(t=>t!=null).reduce((t,r)=>(t.append(r),t))}},Xi=class{constructor(e){this.context=e}createSymbolRendererFromJSON(e){const t=pn(e??dr)??void 0;if(!t)throw new Error("Failed to create renderer");const r=t.type;switch(r){case"simple":return new zi(t,this.context);case"unique-value":return new qi(t,this.context);default:return console.warn(`Unable to create symbolrenderer for renderer of ${r}`),this.createSymbolRendererFromJSON(dr)}}createSymbolRendererFromSymbol(e){const t=e?.type;switch(t){case"point-3d":return new Mi(e,this.context);case"picture-marker":case"simple-marker":return new vt(Ur(),this.context);default:return console.warn(`Unable to create symbolrenderer for symbol of ${t}`),null}}createSymbolRendererFromSymbolLayer(e){const t=e.type;return t==="icon"?new vt(e,this.context):(console.warn(`Unable to create symbolrenderer for symbolLayer of ${t}`),null)}};const dr={type:"simple"};function Xe(a=""){return`${a}${gn()}`}let Yi=class Qr{constructor(e,t){this._parent=e,this._subsetIndices=t,this.id=Xe(`featureDataSubset-${e.id}-`)}get tileId(){return this._parent.tileId}get extent(){return this._parent.extent}get featureCount(){return this._subsetIndices.length}get usedMemory(){return this._parent.usedMemory+ve+this._subsetIndices.byteLength}get isFullyEnabled(){for(const e of this._subsetIndices)if(!this._parent.getEnabled(e))return!1;return!0}getObjectId(e){return this._parent.getObjectId(this._subsetIndices[e])}getAttribute(e,t){return this._parent.getAttribute(this._subsetIndices[e],t)}getAttributeAsTimestamp(e,t){return this._parent.getAttribute(this._subsetIndices[e],t)}getAttributes(e){return this._parent.getAttributes(this._subsetIndices[e])}getCoordinates(e,t,r){return this._parent.getCoordinates(this._subsetIndices[e],t,r)}getOptimizedGeometry(e){return this._parent.getOptimizedGeometry(this._subsetIndices[e])}getCentroid(e,t){return this._parent.getCentroid(this._subsetIndices[e],t)}getBounds(e){return this._parent.getBounds(this._subsetIndices[e])}getBoundingBox(e){return this._parent.getBoundingBox(this._subsetIndices[e])}getObjectIdsArray(e,t,r){return this._parent.getObjectIdsArray(e,this._translatedIndices(t),r)}getCoordinatesArray(e,t,r){return this._parent.getCoordinatesArray(e,this._translatedIndices(t),r)}objectIds(e){return this._parent.objectIds(this._translatedIndices(e))}subset(e){const{_subsetIndices:t}=this,r=new Uint32Array(e.length);for(let n=0;n<r.length;++n)r[n]=t[e[n]];return new Qr(this._parent,r)}disableObjectIds(e){if(e.size===0)return;const{featureCount:t}=this,r=new Array;for(let n=0;n<t;++n)this.getEnabled(n)&&e.has(this.getObjectId(n))&&r.push(n);if(r.length!==0)for(const n of r)this.setEnabled(n,!1)}setEnabled(e,t){this._parent.setEnabled(this._subsetIndices[e],t)}getEnabled(e){return this._parent.getEnabled(this._subsetIndices[e])}enableAll(){const{_subsetIndices:e,_parent:t}=this;for(const r of e)t.setEnabled(r,!0)}getVisibilityArray(e,t,r){return this._parent.getVisibilityArray(e,this._translatedIndices(t),r)}enabledObjectIds(e){return this._parent.enabledObjectIds(this._translatedIndices(e))}*_translatedIndices(e){const{_subsetIndices:t}=this;if(e!=null)for(const r of e)yield t[r];else yield*t}};class Zi{constructor(e){this._tile=e,this.id=Xe(`featureData-${e.id}-`),this._enabled=new Array(e.featureCount).fill(!0)}get tileId(){return this._tile.id}get featureCount(){return this._tile.featureCount}get usedMemory(){return ve+Ya(this.id)}get extent(){return this._tile.descriptor.extent}get isFullyEnabled(){return this._enabled.every(e=>e)}getObjectId(e){return this._tile.getObjectId(e)}getAttribute(e,t){return this._tile.getAttribute(e,t)}getAttributeAsTimestamp(e,t){return this._tile.getAttribute(e,t)}getAttributes(e){return this._tile.getAttributes(e)}getCoordinates(e,t,r){return this._tile.getCoordinates(e,t,r)}getOptimizedGeometry(e){return this._tile.getOptimizedGeometry(e)}getCentroid(e,t){return this._tile.getCentroid(e,t)}getBounds(e){return this._tile.getBounds(e)}getBoundingBox(e){return this._tile.getBoundingBox(e)}getObjectIdsArray(e,t,r){return this._tile.getObjectIdsArray(e,t,r)}getCoordinatesArray(e,t,r){return this._tile.getCoordinatesArray(e,t,r)}objectIds(e){return this._tile.objectIds(e)}subset(e){return new Yi(this,e)}disableObjectIds(e){if(e.size===0)return;const{_enabled:t}=this,r=new Array;for(const n of this._allFeatureIndices())t[n]&&e.has(this.getObjectId(n))&&r.push(n);if(r.length!==0)for(const n of r)t[n]=!1}setEnabled(e,t){this._enabled[e]=t}getEnabled(e){return this._enabled[e]}enableAll(){this._enabled.fill(!0)}getVisibilityArray(e,t=this._allFeatureIndices(),r=0){const{_enabled:n}=this;for(const i of t)e[r++]=Number(n[i]);return r}*enabledObjectIds(e=this._allFeatureIndices()){const{_enabled:t}=this;for(const r of e)t[r]&&(yield this.getObjectId(r))}*_allFeatureIndices(){const{featureCount:e}=this;for(let t=0;t<e;++t)yield t}}let U=class extends yn{constructor(e){super(e),this.extent=null,this._tileHandles=new tr,this._wanted=new tr,this._updateRequested=!1,this._synchronizationTask=null,this._requestedTiles=new Array}destroy(){this._tileHandles.clear(),this._wanted.clear()}get updating(){return this._updateRequested||!(this._synchronizationTask?.finished??1)}get _boundingRect(){const{extent:e}=this;return e==null?null:_n(e)}get _missingTiles(){const e=new Array,t=this._wanted,r=this._tileHandles;for(const n of t.values())r.get(n.id)?.featureData==null&&e.push(n);return e}onTileTreeChange({tiles:e}){this._requestedTiles=e,this._scheduleTilesSync()}_scheduleTilesSync(){if(this._updateRequested)return;this._updateRequested=!0;const e=this._synchronizationTask,t=jt(async()=>{try{await bn(()=>e?.finished??!0),await vn(),this._updateRequested=!1,await this._synchronizeTiles()}finally{this._synchronizationTask===t&&(this._synchronizationTask=null)}});this._synchronizationTask=t}async _synchronizeTiles(){const e=this._requestedTiles,t=this._tileHandles,r=new Array;for(const u of e)t.has(u.id)||r.push(u);const n=new Array;for(const u of t.values()){const{id:p}=u;e.every(_=>_.id!==p)&&n.push(u.descriptor)}const i=this._tileHandles,{_boundingRect:s}=this,o=s!=null?r.filter(u=>xn(s,u.extent)):r,c=this._wanted,d=new Array;for(const{id:u}of n)c.delete(u);for(const u of o)c.set(u.id,u);const f=this._missingTiles;for(const u of n){const{id:p}=u;if(f.some(w=>oe(w,u)||oe(u,w)))continue;const _=i.get(p);_!=null&&d.push(this._removeTile(_))}for(const u of o)d.push(this._addTile(u));const l=await Promise.allSettled(d);for(const u of l)u.status==="rejected"&&console.error(u.reason)}forEachTile(e){for(const t of this._tileHandles.values()){const r=t.featureData;r!=null&&e(r)}}*loadedTiles(){for(const e of this._tileHandles.values()){const t=e.featureData;t!=null&&(yield t)}}async _removeTile(e){e.loadTask.abort(),this._tileHandles.delete(e.id),this._validate();const{featureData:t}=e;if(t!=null){const r={stack:[],error:void 0,hasError:!1};try{pt(r,await this.tileLocks.lock([t.tileId]),!1),await(await this.createRemoveCommand(t.id))?.execute()}catch(n){r.error=n,r.hasError=!0}finally{gt(r)}}}async _addTile(e){const{_tileHandles:t}=this,r=t.get(e.id);if(r!=null)return!Ne(r)||r.featureData.isFullyEnabled?void 0:(r.featureData.enableAll(),void await this._onTileLoad(r));const n=new Ji(e,jt(async i=>{const s=await this.loadTile(e,i);return $e(i),new Zi(s)}));this._tileHandles.set(n.id,n);try{await n.loadTask.promise}catch(i){return void Cn(i)}Ki(n),await this._onTileLoad(n)}async _onTileLoad(e){const t={stack:[],error:void 0,hasError:!1};try{const{_wanted:r,_tileHandles:n,_missingTiles:i}=this,s=e.descriptor,o=new Array,c=new Array,d=new Array,f=new Set;for(const m of n.values()){if(m===e)continue;const{descriptor:y,id:x}=m;if(r.has(x)||i.some(I=>oe(I,y)||oe(y,I))){if(Ne(m)){if(oe(s,y)){const I=m.featureData;for(const h of I.objectIds())f.add(h)}if(oe(y,s)){const{featureData:I}=m;c.push(I)}}}else{n.delete(x),m.loadTask.abort();const{featureData:I}=m;I!=null&&o.push(I)}}f.size>0&&(e.featureData.disableObjectIds(f),this._validateRemoval(e.featureData,f)),this._validate(),d.push(e.featureData);const l=[...d,...o,...c].map(m=>m.tileId);if(pt(t,await this.tileLocks.lock(l),!1),c.length!==0){const m=e.featureData,y=new Set(m.objectIds());for(const x of c)x.disableObjectIds(y),this._validateRemoval(x,y)}const u=o.map(m=>this.createRemoveCommand(m.id)),p=d.map(m=>this.createAddCommand(m)),_=c.map(m=>this.createUpdateCommand(m)),w=await Promise.all([...u,...p,..._]);await pi(w.filter(Cr))?.execute()}catch(r){t.error=r,t.hasError=!0}finally{gt(t)}}_validate(){if(!Lt("feature-pipeline-3d-test-validation"))return;const e=new Array;for(const t of this._tileHandles.values()){if(!Ne(t))continue;const{featureData:r}=t;e.push({featureData:r,objectIds:new Set(r.enabledObjectIds())})}for(let t=0;t<e.length;++t){const{featureData:r,objectIds:n}=e[t];for(let i=t+1;i<e.length;++i){const{featureData:s,objectIds:o}=e[i];for(const c of o)if(n.has(c))throw new Error(`${r.id} and ${s.id} both contain ${c}.`)}}}_validateRemoval(e,t){if(Lt("feature-pipeline-3d-test-validation")){for(const r of e.enabledObjectIds())if(t.has(r))throw new Error(`Failed to remove ${r} from ${e.id}!`)}}};function oe({lij:[a,e,t]},{lij:[r,n,i]}){const s=r-a;return s>=0&&e===n>>s&&t===i>>s}S([N()],U.prototype,"updating",null),S([N({constructOnly:!0})],U.prototype,"loadTile",void 0),S([N({constructOnly:!0})],U.prototype,"createAddCommand",void 0),S([N({constructOnly:!0})],U.prototype,"createRemoveCommand",void 0),S([N({constructOnly:!0})],U.prototype,"createUpdateCommand",void 0),S([N({constructOnly:!0})],U.prototype,"tileLocks",void 0),S([N()],U.prototype,"extent",void 0),S([N()],U.prototype,"_boundingRect",null),S([N()],U.prototype,"_missingTiles",null),S([N()],U.prototype,"_updateRequested",void 0),S([N()],U.prototype,"_synchronizationTask",void 0),U=S([xr("esri.views.3d.layers.graphics.pipeline.Tile3DManager")],U);class Ji{constructor(e,t){this.descriptor=e,this.loadTask=t}get id(){return this.descriptor.id}get featureData(){return this.loadTask.value}}function Ne(a){return a.featureData!=null}function Ki(a){if(!Ne(a))throw new Error}class es{constructor(){this._previousActions=new Map}async lock(e){const{_previousActions:t}=this,r=e.map(c=>t.get(c)).filter(Cr),n=Promise.allSettled(r),i=wn(),s=Sn(()=>i.resolve()),o=i.promise.finally(()=>{for(const c of e)t.get(c)===o&&t.delete(c)});for(const c of e)t.set(c,o);return await n,In(s)}}let Ct=class{constructor(e,t){this._index=e,this._view=t}get usedMemory(){return ve+Fr}getObjectId(){return this._view.getObjectId(this._index)}getAttribute(e){return this._view.getAttribute(this._index,e)}getAttributeAsTimestamp(e){return this._view.getAttributeAsTimestamp(this._index,e)}getAttributes(){return this._view.getAttributes(this._index)}getOptimizedGeometry(){return this._view.getOptimizedGeometry(this._index)}getCentroid(e){return this._view.getCentroid(this._index,e)}getBounds(){return this._view.getBounds(this._index)}getBoundingBox(){return this._view.getBoundingBox(this._index)}cloneWithGeometry(e){return new ts(this._index,this._view,e)}},ts=class extends Ct{constructor(e,t,r){super(e,t),this._geometryOverride=r}getOptimizedGeometry(){return this._geometryOverride}getCentroid(e){return Ka(new _t,this._geometryOverride,e.hasZ,e.hasM)}},rs=class{constructor(e,t){this.featureData=e,this.bounds=t}},ns=class{constructor(){this._tileBounds=new Map,this.events=new wr,this.featureAdapter=as.shared}get usedMemory(){return ve+ve*this._tileBounds.size}addTile(e){const{featureCount:t}=e;if(t===0)return;const r=new Ja(9,i=>e.getBounds(i)),n=new Array;for(let i=0;i<t;++i)n[i]=i;r.load(n),this._tileBounds.set(e.id,new rs(e,r)),this.events.emit("changed")}removeTile(e){this._tileBounds.delete(e),this.events.emit("changed")}clear(){this._tileBounds.clear(),this.events.emit("changed")}forEach(e){for(const{featureData:t,bounds:r}of this._tileBounds.values())r.all(n=>{t.getEnabled(n)&&e(new Ct(n,t))})}forEachInBounds(e,t){we.minX=e[0],we.minY=e[1],we.maxX=e[2],we.maxY=e[3];for(const{featureData:r,bounds:n}of this._tileBounds.values())n.search(we,i=>{r.getEnabled(i)&&t(new Ct(i,r))})}forEachBounds(e,t){for(const r of e)t(r.getBoundingBox())}getFullExtent(e){let t=1/0,r=1/0,n=-1/0,i=-1/0;for(const{bounds:s}of this._tileBounds.values()){const{minX:o,minY:c,maxX:d,maxY:f}=s.toJSON();t=Math.min(t,o),r=Math.min(r,c),n=Math.min(n,d),i=Math.min(i,f)}return{xmin:t,ymin:r,xmax:n,ymax:i,spatialReference:e}}};var xe;let as=(xe=class{getObjectId(e){return e.getObjectId()}getAttribute(e,t){return e.getAttribute(t)}getAttributeAsTimestamp(e,t){return e.getAttributeAsTimestamp(t)}getAttributes(e){return e.getAttributes()}getGeometry(e){return e.getOptimizedGeometry()}getCentroid(e,t){return e.getCentroid(t)}cloneWithGeometry(e,t){return e.cloneWithGeometry(t)}},xe.shared=new xe,xe);const we=new Mr;let is=class{constructor(e,t,r){this.descriptor=e,this._pages=t,this._pageSize=r;const n=Za+t.reduce((s,{usedMemory:o})=>s+o,0),i=3*Fr;this.usedMemory=ve+n+i,this.featureCount=t.reduce((s,o)=>s+o.featureCount,0)}get id(){return this.descriptor.id}getObjectId(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getObjectId(r)}getAttribute(e,t){const{pageIndex:r,featurePageIndex:n}=this._translateIndex(e);return this._pages[r].getAttribute(n,t)}getAttributeAsTimestamp(e,t){const{pageIndex:r,featurePageIndex:n}=this._translateIndex(e);return this._pages[r].getAttributeAsTimestamp(n,t)}getAttributes(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getAttributes(r)}getCoordinates(e,t,r){const{pageIndex:n,featurePageIndex:i}=this._translateIndex(e);this._pages[n].getCoordinates(i,t,r)}getOptimizedGeometry(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getOptimizedGeometry(r)}getCentroid(e,t){const{pageIndex:r,featurePageIndex:n}=this._translateIndex(e);return this._pages[r].getCentroid(n,t)}getBounds(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getBounds(r)}getBoundingBox(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getBoundingBox(r)}getObjectIdsArray(e,t=this._allFeatureIndices(),r=0){let n=r;for(const{page:i,indices:s}of this._batchPageIndices(t))n=i.getObjectIdsArray(e,s,n);return n}getCoordinatesArray(e,t=this._allFeatureIndices(),r=0){let n=r;for(const{page:i,indices:s}of this._batchPageIndices(t))n=i.getCoordinatesArray(e,s,n);return n}*objectIds(e=this._allFeatureIndices()){for(const{page:t,indices:r}of this._batchPageIndices(e))for(const n of t.objectIds(r))yield n}*_allFeatureIndices(){const{featureCount:e}=this;for(let t=0;t<e;++t)yield t}_translateIndex(e){const{_pageSize:t}=this;return{pageIndex:Math.floor(e/t),featurePageIndex:e%t}}*_batchPageIndices(e){const t=new Array;{let n=0,i=new Array;for(const s of e){const{pageIndex:o,featurePageIndex:c}=this._translateIndex(s);n!==o&&(i.length!==0&&t.push({pageIndex:n,indices:i}),n=o,i=[]),i.push(c)}i.length!==0&&t.push({pageIndex:n,indices:i})}const{_pages:r}=this;for(const{pageIndex:n,indices:i}of t)yield{page:r[n],indices:i}}},ss=class{constructor(e){this._reader=new ti(new Uint8Array(e),new DataView(e)),this._index=os(this._reader)}get featureCount(){return this._index.featureIndices.length}get exceededTransferLimit(){return this._index.exceededTransferLimit}get usedMemory(){return this._reader.usedMemory}getObjectId(e){return this.getAttribute(e,this._index.objectIdFieldName)}getAttribute(e,t){const{_index:{fieldsIndex:r,attributeIndices:n}}=this,i=r.get(t)?.index;if(i==null)return;const s=n[e*r.fields.length+i],o=this._reader;return o.move(s),Le(o)}getAttributeAsTimestamp(e,t){const r=this.getAttribute(e,t);return typeof r=="string"?new Date(r).getTime():typeof r=="number"||r==null?r:null}getAttributes(e){const{_index:{fieldsIndex:t,attributeIndices:r}}=this,n=e*t.fields.length,i=this._reader,s={};for(const o of t.fields){const c=r[n+o.index];i.move(c),s[o.name]=Le(i)}return s}getCoordinates(e,t,r=0){const n=this._reader,{transform:i,featureIndices:s}=this._index,{scale:o,translate:c}=i;n.move(s[e]),this._readCoordinates(o,c,t,r)}getOptimizedGeometry(e){const t=V();return this.getCoordinates(e,t),new _t([],t)}getCentroid(e,{hasZ:t,hasM:r}){this.getCoordinates(e,le);const[n,i,s]=le,o=[n,i];return t&&(o[3]=s),r&&(o[t?4:3]=0),new _t([],o)}getBounds(e){this.getCoordinates(e,le);const[t,r]=le,n=new Mr;return n.minX=t,n.minY=r,n.maxX=t,n.maxY=r,n}getBoundingBox(e){this.getCoordinates(e,le);const[t,r,n]=le;return On(t,r,n,t,r,n)}getObjectIdsArray(e,t=this._allFeatureIndices(),r=0){const n=this._reader,{objectIdFieldName:i,attributeIndices:s,fieldsIndex:o}=this._index,c=o.get(i).index,d=o.fields.length;for(const f of t){const l=s[f*d+c];n.move(l),e[r++]=Le(n)}return r}getCoordinatesArray(e,t=this._allFeatureIndices(),r=0){const n=this._reader,{transform:i,featureIndices:s}=this._index,{scale:o,translate:c}=i;for(const d of t){const f=s[d];n.move(f),r=this._readCoordinates(o,c,e,r)}return r}*objectIds(e=this._allFeatureIndices()){const t=this._reader,{objectIdFieldName:r,attributeIndices:n,fieldsIndex:i}=this._index,s=i.get(r).index,o=i.fields.length;for(const c of e){const d=n[c*o+s];t.move(d),yield Le(t)}}*_allFeatureIndices(){const{featureCount:e}=this;for(let t=0;t<e;++t)yield t}_readCoordinates([e,t,r],[n,i,s],o,c){const l=this._reader,u=l.getLength(),p=l.pos()+u;for(;l.pos()<p&&l.next();)switch(l.tag()){case 2:{const _=l.getLength(),w=l.pos()+_;for(;l.pos()<w&&l.next();)l.tag()===3?(l.getUInt32(),o[c++]=n+e*l.getSInt64(),o[c++]=i+t*l.getSInt64(),o[c++]=s+r*l.getSInt64()):l.skip();break}default:l.skip()}return c}};function os(a){for(;a.next();){if(a.tag()===2)return ls(a.getMessage());a.skip()}Ye()}function ls(a){for(;a.next();){if(a.tag()===1)return cs(a.getMessage());a.skip()}Ye()}function cs(a){let f,l,u=!1,p=!1,_=0;const w=new Array,C=new Array,m=new Array;for(;a.next();)switch(a.tag()){case 1:l=a.getString();break;case 7:a.getEnum()!==0&&Ye();break;case 9:u=a.getBool()??!1;break;case 12:f=ri(a.processMessage(ai));break;case 13:{const x=a.processMessage(ni);x.index=_++,w.push(x);break}case 15:{C.push(a.pos());const x=a.getUInt32(),I=a.pos()+x;for(;a.pos()<I&&a.next();)a.tag()===1&&m.push(a.pos()),a.skip();break}case 10:p=a.getBool()??!1;break;default:a.skip()}const y=new An(w);return f!=null&&p&&l!=null&&y.has(l)||Ye(),{transform:f,exceededTransferLimit:u,fieldsIndex:y,objectIdFieldName:l,featureIndices:C,attributeIndices:m}}function Ye(){const a=new Pn("pbf-parsing-failed","Error while parsing PBF",new Error);throw console.error(a),a}function Le(a){const f=a.getLength(),l=a.pos()+f;for(;a.pos()<l&&a.next();)switch(a.tag()){case 1:return a.getString();case 2:return a.getFloat();case 3:return a.getDouble();case 4:return a.getSInt32();case 5:return a.getUInt32();case 6:return a.getInt64();case 7:return a.getUInt64();case 8:return a.getSInt64();case 9:return a.getBool();default:return a.skip(),null}return null}const le=V(),ur=8e3,ds=4,us=4;let fs=class{constructor(e,t,r,n,i){this.spatialReference=e,this.url=r,this.objectIdField=n,this.capabilities=i;const{supportsMaxRecordCountFactor:s,maxRecordCount:o}=this.capabilities.query,c=s?ds:1,d=(o??ur)*c;this._pageSize=Math.min(ur,d);const f=t.clone();f.cacheHint=!0,f.resultType="tile",f.outSpatialReference=e,f.returnGeometry=!0,f.returnZ=!0,f.maxRecordCountFactor=c,f.num=this._pageSize,f.outFields=[n],this._baseQuery=f}async fetch(e,t){const{spatialReference:r,_pageSize:n}=this,i=$n(e.extent,r),s=this._baseQuery.clone();s.geometry=i;const o=new Array;let c=0,d=!1,f=1;for(;!d;){const l=[];for(let p=0;p<f;++p)l.push(this._fetchPage(s,c++,t));const u=await Promise.all(l);$e(t);for(const p of u){const _=p.featureCount!==0;d||(d=!p.exceededTransferLimit||!_),_&&o.push(p)}f=Math.min(f+1,us)}return new is(e,o,n)}async _fetchPage(e,t,r){const n=e.clone();n.start=t*this._pageSize;const i=(await ei(this.url,n,{signal:r})).data;return $e(r),new ss(i)}};function hs(a){return a instanceof Float32Array&&a.length>=16}function ms(a){return Array.isArray(a)&&a.length>=16}function ps(a){return hs(a)||ms(a)}const Wr=.5;function gs(a,e){a.include(Pr),a.attributes.add(g.POSITION,"vec3"),a.attributes.add(g.NORMAL,"vec3"),a.attributes.add(g.CENTEROFFSETANDDISTANCE,"vec4");const t=a.vertex;ea(t,e),ta(t,e),t.uniforms.add(new Et("viewport",r=>r.camera.fullViewport),new yt("polygonOffset",r=>r.shaderPolygonOffset),new Qe("cameraGroundRelative",r=>r.camera.aboveGround?1:-1)),e.hasVerticalOffset&&ra(t),t.code.add(b`struct ProjectHUDAux {
vec3 posModel;
vec3 posView;
vec3 vnormal;
float distanceToCamera;
float absCosAngle;
};`),t.code.add(b`
    float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {
      float pointGroundSign = ${e.terrainDepthTest?b.float(0):b`sign(pointGroundDistance)`};
      if (pointGroundSign == 0.0) {
        pointGroundSign = cameraGroundRelative;
      }

      // cameraGroundRelative is -1 if camera is below ground, 1 if above ground
      // groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise
      float groundRelative = cameraGroundRelative * pointGroundSign;

      // view angle dependent part of polygon offset emulation: we take the absolute value because the sign that is
      // dropped is instead introduced using the ground-relative position of the symbol and the camera
      if (polygonOffset > .0) {
        float cosAlpha = clamp(absCosAngle, 0.01, 1.0);
        float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;
        float factor = (1.0 - tanAlpha / viewport[2]);

        // same side of the terrain
        if (groundRelative > 0.0) {
          posView *= factor;
        }
        // opposite sides of the terrain
        else {
          posView /= factor;
        }
      }

      return groundRelative;
    }
  `),e.draped&&!e.hasVerticalOffset||na(t),e.draped||(t.uniforms.add(new Qe("perDistancePixelRatio",r=>Math.tan(r.camera.fovY/2)/(r.camera.fullViewport[2]/2))),t.code.add(b`
    void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {
      float distanceToCamera = length(posView);

      // Compute offset in world units for a half pixel shift
      float pixelOffset = distanceToCamera * perDistancePixelRatio * ${b.float(Wr)};

      // Apply offset along normal in the direction away from the ground surface
      vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;

      // Apply the same offset also on the view space position
      vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;

      posModel += modelOffset;
      posView += viewOffset;
    }
  `)),e.screenCenterOffsetUnitsEnabled&&$r(t),e.hasScreenSizePerspective&&Tr(t),t.code.add(b`
    vec4 projectPositionHUD(out ProjectHUDAux aux) {
      vec3 centerOffset = centerOffsetAndDistance.xyz;
      float pointGroundDistance = centerOffsetAndDistance.w;

      aux.posModel = position;
      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;
      aux.vnormal = normal;
      ${e.draped?"":"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);"}

      // Screen sized offset in world space, used for example for line callouts
      // Note: keep this implementation in sync with the CPU implementation, see
      //   - MaterialUtil.verticalOffsetAtDistance
      //   - HUDMaterial.applyVerticalOffsetTransformation

      aux.distanceToCamera = length(aux.posView);

      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);
      float cosAngle = dot(aux.vnormal, viewDirObjSpace);

      aux.absCosAngle = abs(cosAngle);

      ${e.hasScreenSizePerspective&&(e.hasVerticalOffset||e.screenCenterOffsetUnitsEnabled)?"vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);":""}

      ${e.hasVerticalOffset?e.hasScreenSizePerspective?"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);":"float verticalOffsetScreenHeight = verticalOffset.x;":""}

      ${e.hasVerticalOffset?b`
            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);
            vec3 modelOffset = aux.vnormal * worldOffset;
            aux.posModel += modelOffset;
            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
            aux.posView += viewOffset;
            // Since we elevate the object, we need to take that into account
            // in the distance to ground
            pointGroundDistance += worldOffset;`:""}

      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);

      ${e.screenCenterOffsetUnitsEnabled?"":b`
            // Apply x/y in view space, but z in screen space (i.e. along posView direction)
            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);

            // Same material all have same z != 0.0 condition so should not lead to
            // branch fragmentation and will save a normalization if it's not needed
            if (centerOffset.z != 0.0) {
              aux.posView -= normalize(aux.posView) * centerOffset.z;
            }
          `}

      vec4 posProj = proj * vec4(aux.posView, 1.0);

      ${e.screenCenterOffsetUnitsEnabled?e.hasScreenSizePerspective?"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);":"float centerOffsetY = centerOffset.y;":""}

      ${e.screenCenterOffsetUnitsEnabled?"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;":""}

      // constant part of polygon offset emulation
      posProj.z -= groundRelative * polygonOffset * posProj.w;
      return posProj;
    }
  `)}let ys=class{constructor(){this.factor=new fr,this.factorAlignment=new fr}},fr=class{constructor(){this.scale=0,this.factor=0,this.minScaleFactor=0}};function Ft(a){a.uniforms.add(new aa("alignPixelEnabled",e=>e.alignPixelEnabled)),a.code.add(b`vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`),a.code.add(b`vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`)}function _s(a,e){const{vertex:t,fragment:r}=a;a.include(ia,e),t.include(Ft),t.main.add(b`vec4 posProjCenter;
if (dot(position, position) > 0.0) {
ProjectHUDAux projectAux;
vec4 posProj = projectPositionHUD(projectAux);
posProjCenter = alignToPixelCenter(posProj, viewport.zw);
forwardViewPosDepth(projectAux.posView);
vec3 vpos = projectAux.posModel;
if (rejectBySlice(vpos)) {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
} else {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
gl_Position = posProjCenter;
gl_PointSize = 1.0;`),r.main.add(b`fragColor = vec4(1);
if(discardByTerrainDepth()) {
fragColor.g = 0.5;
}`)}var Ze;(function(a){a[a.Occluded=0]="Occluded",a[a.NotOccluded=1]="NotOccluded",a[a.Both=2]="Both",a[a.COUNT=3]="COUNT"})(Ze||(Ze={}));function bs(a){a.vertex.uniforms.add(new Qe("renderTransparentlyOccludedHUD",e=>e.hudRenderStyle===Ze.Occluded?1:e.hudRenderStyle===Ze.NotOccluded?0:.75),new Et("viewport",e=>e.camera.fullViewport),new Rr("hudVisibilityTexture",e=>e.hudVisibility?.getTexture())),a.vertex.include(Ft),a.vertex.code.add(b`bool testHUDVisibility(vec4 posProj) {
vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);
vec4 occlusionPixel = texture(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);
if (renderTransparentlyOccludedHUD > 0.5) {
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;
}
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;
}`)}function vs(a){const e=new sa,{signedDistanceFieldEnabled:t,occlusionTestEnabled:r,horizonCullingEnabled:n,pixelSnappingEnabled:i,hasScreenSizePerspective:s,debugDrawLabelBorder:o,vvSize:c,vvColor:d,hasRotation:f,occludedFragmentFade:l,sampleSignedDistanceFieldTexelCenter:u}=a;e.include(gs,a),e.vertex.include(oa,a);const{occlusionPass:p,output:_,oitPass:w}=a;if(p)return e.include(_s,a),e;const{vertex:C,fragment:m}=e;e.include(Pr),e.include(la,a),e.include(ca,a),r&&e.include(bs),m.include(hi),m.include(da),e.varyings.add("vcolor","vec4"),e.varyings.add("vtc","vec2"),e.varyings.add("vsize","vec2");const y=_===H.Highlight,x=y&&r;x&&e.varyings.add("voccluded","float"),C.uniforms.add(new Et("viewport",v=>v.camera.fullViewport),new Qt("screenOffset",(v,j)=>Tt(Ge,2*v.screenOffset[0]*j.camera.pixelRatio,2*v.screenOffset[1]*j.camera.pixelRatio)),new Qt("anchorPosition",v=>Re(v)),new at("materialColor",v=>v.color),new yt("materialRotation",v=>v.rotation),new Wt("tex",v=>v.texture)),$r(C),t&&(C.uniforms.add(new at("outlineColor",v=>v.outlineColor)),m.uniforms.add(new at("outlineColor",v=>hr(v)?v.outlineColor:vr),new yt("outlineSize",v=>hr(v)?v.outlineSize:0))),n&&C.uniforms.add(new mi("pointDistanceSphere",(v,j)=>{const z=j.camera.eye,T=v.origin;return Tn(T[0]-z[0],T[1]-z[1],T[2]-z[2],Rn.radius)})),i&&C.include(Ft),s&&(ua(C),Tr(C)),o&&e.varyings.add("debugBorderCoords","vec4"),e.attributes.add(g.UVI,"vec2"),e.attributes.add(g.COLOR,"vec4"),e.attributes.add(g.SIZE,"vec2"),e.attributes.add(g.ROTATION,"float"),(c||d)&&e.attributes.add(g.FEATUREATTRIBUTE,"vec4"),C.code.add(n?b`bool behindHorizon(vec3 posModel) {
vec3 camToEarthCenter = pointDistanceSphere.xyz - localOrigin;
vec3 camToPos = pointDistanceSphere.xyz + posModel;
float earthRadius = pointDistanceSphere.w;
float a = dot(camToPos, camToPos);
float b = dot(camToPos, camToEarthCenter);
float c = dot(camToEarthCenter, camToEarthCenter) - earthRadius * earthRadius;
return b > 0.0 && b < a && b * b  > a * c;
}`:b`bool behindHorizon(vec3 posModel) { return false; }`),C.main.add(b`
    ProjectHUDAux projectAux;
    vec4 posProj = projectPositionHUD(projectAux);
    forwardObjectAndLayerIdColor();

    if (rejectBySlice(projectAux.posModel)) {
      // Project outside of clip plane
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      return;
    }

    if (behindHorizon(projectAux.posModel)) {
      // Project outside of clip plane
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      return;
    }

    vec2 inputSize;
    ${M(s,b`
        inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
        vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);`,b`
        inputSize = size;
        vec2 screenOffsetScaled = screenOffset;`)}
    ${M(c,b`inputSize *= vvScale(featureAttribute).xx;`)}

    vec2 combinedSize = inputSize * pixelRatio;
    vec4 quadOffset = vec4(0.0);

    ${M(r,b`
    bool visible = testHUDVisibility(posProj);
    if (!visible) {
      vtc = vec2(0.0);
      ${M(o,"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);")}
      return;
    }`)}
    ${M(x,b`voccluded = visible ? 0.0 : 1.0;`)}
  `);const I=b`
      vec2 uvi1 = vec2(uvi.x < 0.0 ? 1.0 : 0.0, uvi.y < 0.0 ? 1.0 : 0.0);
      vec2 uv = abs(uvi + uvi1);
      vec2 texSize = vec2(textureSize(tex, 0));
      uv.x = uv.x >= ${mr} ? 1.0 : uv.x / texSize.x;
      uv.y = uv.y >= ${mr} ? 1.0 : uv.y / texSize.y;
      quadOffset.xy = (uvi1 - anchorPosition) * 2.0 * combinedSize;

      ${M(f,b`
          float angle = radians(materialRotation + rotation);
          float cosAngle = cos(angle);
          float sinAngle = sin(angle);
          mat2 rotate = mat2(cosAngle, -sinAngle, sinAngle,  cosAngle);

          quadOffset.xy = rotate * quadOffset.xy;
        `)}

      quadOffset.xy = (quadOffset.xy + screenOffsetScaled) / viewport.zw * posProj.w;
  `,h=i?t?b`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:b`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:b`posProj += quadOffset;`;C.main.add(b`
    ${I}
    ${d?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    ${M(_===H.ObjectAndLayerIdColor,b`vcolor.a = 1.0;`)}

    bool alphaDiscard = vcolor.a < ${b.float(K)};
    ${M(t,`alphaDiscard = alphaDiscard && outlineColor.a < ${b.float(K)};`)}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${h}
      gl_Position = posProj;
    }

    vtc = uv;

    ${M(o,b`debugBorderCoords = vec4(uv01, 1.5 / combinedSize);`)}
    vsize = inputSize;
  `),m.uniforms.add(new Wt("tex",v=>v.texture)),l&&!y&&m.uniforms.add(new Rr("depthMap",v=>v.mainDepth),new Qe("occludedOpacity",v=>v.hudOccludedFragmentOpacity));const P=o?b`(isBorder > 0.0 ? 0.0 : ${b.float(K)})`:b.float(K),R=b`
    ${M(o,b`float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`)}

    vec2 samplePos = vtc;

    ${M(u,b`
      float txSize = float(textureSize(tex, 0).x);
      float texelSize = 1.0 / txSize;

      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      samplePos += (vec2(1.0, -1.0) * texelSize) * scaleFactor;`)}

    ${t?b`
      vec4 fillPixelColor = vcolor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgbaTofloat(texture(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${P} ||
          fillPixelColor.a + outlinePixelColor.a < ${b.float(K)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        ${M(!y,b`fragColor = vec4(compositeColor, compositeAlpha);`)}
      } else {
        if (fillAlphaFactor < ${P}) {
          discard;
        }

        ${M(!y,b`fragColor = premultiplyAlpha(fillPixelColor);`)}
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:b`
          vec4 texColor = texture(tex, samplePos, -0.5);
          if (texColor.a < ${P}) {
            discard;
          }
          ${M(!y,b`fragColor = texColor * premultiplyAlpha(vcolor);`)}
          `}

    ${M(l&&!y,b`
        float zSample = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;
        if (zSample < gl_FragCoord.z) {
          fragColor *= occludedOpacity;
        }
        `)}

    ${M(!y&&o,b`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`)}
  `;switch(_){case H.Color:case H.ColorEmission:e.outputs.add("fragColor","vec4",0),_===H.ColorEmission&&e.outputs.add("fragEmission","vec4",1),w===Ae.ColorAlpha&&e.outputs.add("fragAlpha","float",_===H.ColorEmission?2:1),m.main.add(b`
        ${R}
        ${M(w===Ae.FrontFace,b`fragColor.rgb /= fragColor.a;`)}
        ${M(_===H.ColorEmission,b`fragEmission = vec4(0.0);`)}
        ${M(w===Ae.ColorAlpha,b`fragAlpha = fragColor.a;`)}`);break;case H.ObjectAndLayerIdColor:m.main.add(b`
        ${R}
        outputObjectAndLayerIdColor();`);break;case H.Highlight:e.include(fa,a),m.main.add(b`
        ${R}
        outputHighlight(${M(x,b`voccluded == 1.0`,b`false`)});`)}return e}function hr(a){return a.outlineColor[3]>0&&a.outlineSize>0}function Re(a){return a.textureIsSignedDistanceField?xs(a.anchorPosition,a.distanceFieldBoundingBox,Ge):Xn(Ge,a.anchorPosition),Ge}function xs(a,e,t){Tt(t,a[0]*(e[2]-e[0])+e[0],a[1]*(e[3]-e[1])+e[1])}const Ge=Rt(),Je=32e3,mr=b.float(Je),Cs=Object.freeze(Object.defineProperty({__proto__:null,build:vs,calculateAnchorPosition:Re,fullUV:Je},Symbol.toStringTag,{value:"Module"}));let ws=class extends ha{constructor(e,t){super(e,t,new ma(Cs,()=>En(()=>import("./HUDMaterial.glsl-4dcd104b.js"),["assets/HUDMaterial.glsl-4dcd104b.js","assets/vec2-08ad2285.js","assets/index-8ee34b61.js","assets/index-a5714ce2.css","assets/vec2f64-44b9a02c.js","assets/NormalAttribute.glsl-3245b73c.js","assets/VertexAttribute-123db042.js","assets/DefaultMaterial-e8c850aa.js","assets/videoUtils-18e4b8a5.js","assets/basicInterfaces-cbf2757f.js","assets/TextureFormat-60b88abd.js","assets/enums-ff43618c.js","assets/BufferView-b8fa1162.js","assets/vec32-37618b70.js","assets/sphere-2ec54985.js","assets/mat3-848c9a5e.js","assets/mat3f64-d34bdb1e.js","assets/vectorStacks-f3f45332.js","assets/mat4f64-a3dc1405.js","assets/quatf64-216ddd5a.js","assets/lineSegment-de126745.js","assets/orientedBoundingBox-8de5994f.js","assets/quat-3ef9ebee.js","assets/spatialReferenceEllipsoidUtils-b06c2c3c.js","assets/computeTranslationToOriginAndRotation-e96691a8.js","assets/plane-881ab901.js","assets/InterleavedLayout-842614cb.js","assets/types-d99602e0.js","assets/QueryEngine-bec069b7.js","assets/featureConversionUtils-ecf55d9c.js","assets/OptimizedFeature-eb8a9ca3.js","assets/memoryEstimations-95fc020c.js","assets/OptimizedFeatureSet-5dc8ee29.js","assets/WhereClauseCache-759b8fc8.js","assets/WhereClause-19211c9c.js","assets/FixedIntervalBinParameters-acb79cef.js","assets/normalizeUtils-0f48385e.js","assets/normalizeUtilsCommon-676995ec.js","assets/json-48e3ea08.js","assets/QueryEngineCapabilities-4b2bc619.js","assets/quantizationUtils-b1a838dd.js","assets/utils-a672495b.js","assets/utils-67389ce8.js","assets/utils-8e1c1b33.js","assets/ClassBreaksDefinition-5d917894.js","assets/signal-3a81bd24.js","assets/MeshLocalVertexSpace-b4d6a09d.js","assets/projectVectorToVector-05a9d263.js","assets/projectPointToVector-030380a1.js","assets/Indices-e0ee64fb.js","assets/floatRGBA-d8c359da.js","assets/vec3f32-5edf24fc.js","assets/IntersectorType-fff45762.js","assets/ReactiveMap-240c4127.js","assets/PooledRBush-f0ac9ac2.js","assets/quickselect-b7b34c34.js","assets/query-769e0ffd.js","assets/pbfQueryUtils-926ff7f8.js","assets/pbf-7aa9e413.js"]))),this.primitiveType=t.occlusionPass?Kt.POINTS:Kt.TRIANGLES}initializePipeline(e){const{oitPass:t,hasPolygonOffset:r,draped:n,output:i,depthTestEnabled:s,occlusionPass:o}=e,c=t===Ae.NONE,d=t===Ae.ColorAlpha,f=i===H.Highlight,l=s&&!n&&!d&&!o&&!f;return pa({blending:Lr(i)?c?ga:ya(t):null,depthTest:s&&!n?{func:ka.LEQUAL}:null,depthWrite:l?_a:null,drawBuffers:ba(t,i),colorWrite:va,polygonOffset:r?Is:null})}};const Is={factor:0,units:-4};class E extends xa{constructor(e){super(),this.spherical=e,this.screenCenterOffsetUnitsEnabled=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.hasRotation=!1,this.debugDrawLabelBorder=!1,this.hasPolygonOffset=!1,this.depthTestEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.occlusionPass=!1,this.occludedFragmentFade=!1,this.objectAndLayerIdColorInstanced=!1,this.horizonCullingEnabled=!0,this.isFocused=!0,this.textureCoordinateType=Ca.None,this.emissionSource=wa.None,this.discardInvisibleFragments=!0,this.hasVvInstancing=!1,this.snowCover=!1}}S([D()],E.prototype,"screenCenterOffsetUnitsEnabled",void 0),S([D()],E.prototype,"occlusionTestEnabled",void 0),S([D()],E.prototype,"signedDistanceFieldEnabled",void 0),S([D()],E.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),S([D()],E.prototype,"vvSize",void 0),S([D()],E.prototype,"vvColor",void 0),S([D()],E.prototype,"hasVerticalOffset",void 0),S([D()],E.prototype,"hasScreenSizePerspective",void 0),S([D()],E.prototype,"hasRotation",void 0),S([D()],E.prototype,"debugDrawLabelBorder",void 0),S([D()],E.prototype,"hasPolygonOffset",void 0),S([D()],E.prototype,"depthTestEnabled",void 0),S([D()],E.prototype,"pixelSnappingEnabled",void 0),S([D()],E.prototype,"draped",void 0),S([D()],E.prototype,"terrainDepthTest",void 0),S([D()],E.prototype,"cullAboveTerrain",void 0),S([D()],E.prototype,"occlusionPass",void 0),S([D()],E.prototype,"occludedFragmentFade",void 0),S([D()],E.prototype,"objectAndLayerIdColorInstanced",void 0),S([D()],E.prototype,"horizonCullingEnabled",void 0),S([D()],E.prototype,"isFocused",void 0);class Ss extends Ia{constructor(e,t){super(e,Es),this.produces=new Map([[re.HUD_MATERIAL,r=>it(r)&&!this.parameters.drawAsLabel],[re.LABEL_MATERIAL,r=>it(r)&&this.parameters.drawAsLabel],[re.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[re.DRAPED_MATERIAL,r=>this.parameters.draped&&it(r)]]),this._visible=!0,this._configuration=new E(t)}getConfiguration(e,t){const r=this.parameters.draped;return super.getConfiguration(e,t,this._configuration),this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled=this.parameters.centerOffsetUnits==="screen",this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=r,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===re.OCCLUSION_PIXELS,this._configuration.occludedFragmentFade=!r&&this.parameters.occludedFragmentFade,this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled,this._configuration.isFocused=this.parameters.isFocused,this._configuration.depthTestEnabled=this.parameters.depthEnabled||t.slot===re.OCCLUSION_PIXELS,Lr(e)&&(this._configuration.debugDrawLabelBorder=!!Sa.LABELS_SHOW_BORDER),this._configuration.oitPass=t.oitPass,this._configuration.terrainDepthTest=t.terrainDepthTest,this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration}intersect(e,t,r,n,i,s){const{options:{selectionMode:o,hud:c,excludeLabels:d},point:f,camera:l}=r,{parameters:u}=this;if(!o||!c||d&&u.isLabel||!e.visible||!f||!l)return;const p=e.attributes.get(g.FEATUREATTRIBUTE),_=p==null?null:Bt(p.data,St),{scaleX:w,scaleY:C}=Ot(_,u,l.pixelRatio);zr(ke,t),e.attributes.has(g.FEATUREATTRIBUTE)&&Ps(ke);const m=e.attributes.get(g.POSITION),y=e.attributes.get(g.SIZE),x=e.attributes.get(g.NORMAL),I=e.attributes.get(g.ROTATION),h=e.attributes.get(g.CENTEROFFSETANDDISTANCE);ii(m.size>=3);const P=Re(u),R=this.parameters.centerOffsetUnits==="screen";for(let v=0;v<m.data.length/m.size;v++){const j=v*m.size;Oe(O,m.data[j],m.data[j+1],m.data[j+2]),pe(O,O,t),pe(O,O,l.viewMatrix);const z=v*h.size;if(Oe($,h.data[z],h.data[z+1],h.data[z+2]),!R&&(O[0]+=$[0],O[1]+=$[1],$[2]!==0)){const W=$[2];me($,O),Z(O,O,J($,$,W))}const T=v*x.size;if(Oe(te,x.data[T],x.data[T+1],x.data[T+2]),wt(te,ke,l,Pe),At(this.parameters,O,Pe,l,be),l.applyProjection(O,A),A[0]>-1){R&&($[0]||$[1])&&(A[0]+=$[0]*l.pixelRatio,$[1]!==0&&(A[1]+=Er($[1],be.factorAlignment)*l.pixelRatio),l.unapplyProjection(A,O)),A[0]+=this.parameters.screenOffset[0]*l.pixelRatio,A[1]+=this.parameters.screenOffset[1]*l.pixelRatio,A[0]=Math.floor(A[0]),A[1]=Math.floor(A[1]);const W=v*y.size;F[0]=y.data[W],F[1]=y.data[W+1],Dr(F,be.factor,F);const Fe=Zr*l.pixelRatio;let Me=0;u.textureIsSignedDistanceField&&(Me=Math.min(u.outlineSize,.5*F[0])*l.pixelRatio/2),F[0]*=w,F[1]*=C;const rt=v*I.size,ze=u.rotation+I.data[rt];if(It(f,A[0],A[1],F,Fe,Me,ze,u,P)){const X=r.ray;if(pe(Ke,O,Pt(Yr,l.viewMatrix)),A[0]=f[0],A[1]=f[1],l.unprojectFromRenderScreen(A,O)){const Y=V();q(Y,X.direction);const Mt=1/Te(Y);J(Y,Y,Mt),s(Ar(X.origin,O)*Mt,Y,-1,Ke)}}}}}intersectDraped(e,t,r,n,i){const s=e.attributes.get(g.POSITION),o=e.attributes.get(g.SIZE),c=e.attributes.get(g.ROTATION),d=this.parameters,f=Re(d),l=e.attributes.get(g.FEATUREATTRIBUTE),u=l==null?null:Bt(l.data,St),{scaleX:p,scaleY:_}=Ot(u,d,e.screenToWorldRatio),w=Ts*e.screenToWorldRatio;for(let C=0;C<s.data.length/s.size;C++){const m=C*s.size,y=s.data[m],x=s.data[m+1],I=C*o.size;F[0]=o.data[I],F[1]=o.data[I+1];let h=0;d.textureIsSignedDistanceField&&(h=Math.min(d.outlineSize,.5*F[0])*e.screenToWorldRatio/2),F[0]*=p,F[1]*=_;const P=C*c.size,R=d.rotation+c.data[P];It(r,y,x,F,w,h,R,d,f)&&n(i.distance,i.normal,-1)}}createBufferWriter(){return new Fs}applyShaderOffsetsView(e,t,r,n,i,s,o){const c=wt(t,r,i,Pe);return this._applyVerticalGroundOffsetView(e,c,i,o),At(this.parameters,o,c,i,s),this._applyPolygonOffsetView(o,c,n[3],i,o),this._applyCenterOffsetView(o,n,o),o}applyShaderOffsetsNDC(e,t,r,n,i){return this._applyCenterOffsetNDC(e,t,r,n),i!=null&&q(i,n),this._applyPolygonOffsetNDC(n,t,r,n),n}_applyPolygonOffsetView(e,t,r,n,i){const s=n.aboveGround?1:-1;let o=Math.sign(r);o===0&&(o=s);const c=s*o;if(this.parameters.shaderPolygonOffset<=0)return q(i,e);const d=Dn(Math.abs(t.cosAngle),.01,1),f=1-Math.sqrt(1-d*d)/d/n.viewport[2];return J(i,e,c>0?f:1/f),i}_applyVerticalGroundOffsetView(e,t,r,n){const i=Te(e),s=r.aboveGround?1:-1,o=r.computeRenderPixelSizeAtDist(i)*Wr,c=J(O,t.normal,s*o);return $t(n,e,c),n}_applyCenterOffsetView(e,t,r){const n=this.parameters.centerOffsetUnits!=="screen";return r!==e&&q(r,e),n&&(r[0]+=t[0],r[1]+=t[1],t[2]&&(me(te,r),qn(r,r,J(te,te,t[2])))),r}_applyCenterOffsetNDC(e,t,r,n){const i=this.parameters.centerOffsetUnits!=="screen";return n!==e&&q(n,e),i||(n[0]+=t[0]/r.fullWidth*2,n[1]+=t[1]/r.fullHeight*2),n}_applyPolygonOffsetNDC(e,t,r,n){const i=this.parameters.shaderPolygonOffset;if(e!==n&&q(n,e),i){const s=r.aboveGround?1:-1,o=s*Math.sign(t[3]);n[2]-=(o||s)*i}return n}set visible(e){this._visible=e}get visible(){const{color:e,outlineSize:t,outlineColor:r}=this.parameters,n=e[3]>=K||t>=K&&r[3]>=K;return this._visible&&n}createGLMaterial(e){return new Os(e)}calculateRelativeScreenBounds(e,t,r=Ir()){return As(this.parameters,e,t,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r}}class Os extends Oa{constructor(e){super({...e,...e.material.parameters})}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique(ws,e)}}function As(a,e,t,r){r[0]=a.anchorPosition[0]*-e[0]+a.screenOffset[0]*t,r[1]=a.anchorPosition[1]*-e[1]+a.screenOffset[1]*t}function wt(a,e,t,r){return ps(e)&&(e=zr($s,e)),Qn(r.normal,a,e),pe(r.normal,r.normal,t.viewInverseTransposeMatrix),r.cosAngle=Wn(Xr,Rs),r}function Ps(a){const e=a[0],t=a[1],r=a[2],n=a[3],i=a[4],s=a[5],o=a[6],c=a[7],d=a[8],f=1/Math.sqrt(e*e+t*t+r*r),l=1/Math.sqrt(n*n+i*i+s*s),u=1/Math.sqrt(o*o+c*c+d*d);return a[0]=e*f,a[1]=t*f,a[2]=r*f,a[3]=n*l,a[4]=i*l,a[5]=s*l,a[6]=o*u,a[7]=c*u,a[8]=d*u,a}function It(a,e,t,r,n,i,s,o,c){let d=e-n-r[0]*c[0],f=d+r[0]+2*n,l=t-n-r[1]*c[1],u=l+r[1]+2*n;const p=o.distanceFieldBoundingBox;return o.textureIsSignedDistanceField&&p!=null&&(d+=r[0]*p[0],l+=r[1]*p[1],f-=r[0]*(1-p[2]),u-=r[1]*(1-p[3]),d-=i,f+=i,l-=i,u+=i),Tt(pr,e,t),Yn(Ie,a,pr,Fn(s)),Ie[0]>d&&Ie[0]<f&&Ie[1]>l&&Ie[1]<u}const be=new ys,O=V(),te=V(),A=tt(),Xr=V(),Ke=V(),Ie=Rt(),pr=Rt(),ke=jr(),$s=jr(),Yr=Ce(),Be=tt(),$=V(),dt=V(),St=tt(),Pe={normal:Xr,cosAngle:0},Zr=1,Ts=2,F=G(0,0),B=6,Rs=Mn(0,0,1);class Es extends Aa{constructor(){super(...arguments),this.renderOccluded=Pa.Occlude,this.isDecoration=!1,this.color=mt(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=G(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=mt(1,1,1,1),this.outlineSize=0,this.distanceFieldBoundingBox=tt(),this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!1,this.centerOffsetUnits="world",this.drawAsLabel=!1,this.depthEnabled=!0,this.isFocused=!0,this.focusStyle="bright",this.draped=!1,this.isLabel=!1}}const Jr=ci().vec3f(g.POSITION).vec3f(g.NORMAL).vec2i16(g.UVI).vec4u8(g.COLOR).vec2f(g.SIZE).f32(g.ROTATION).vec4f(g.CENTEROFFSETANDDISTANCE).vec4f(g.FEATUREATTRIBUTE),Ds=Jr.clone().vec4u8(g.OLIDCOLOR);class Fs{constructor(){this.vertexBufferLayout=$a()?Ds:Jr}elementCount(e){return e.get(g.POSITION).indices.length*B}write(e,t,r,n,i,s){const{position:o,normal:c,uvi:d,color:f,size:l,rotation:u,centerOffsetAndDistance:p,featureAttribute:_}=i;Ta(r.get(g.POSITION),e,o,s,B),Ra(r.get(g.NORMAL),t,c,s,B);const w=r.get(g.UVI)?.data;let C=0,m=0,y=-1-Je,x=-1-Je;w&&w.length>=4&&(C=w[0],m=w[1],y=-1-w[2],x=-1-w[3]);let I=r.get(g.POSITION).indices.length,h=s;for(let v=0;v<I;++v)d.set(h,0,C),d.set(h,1,m),h++,d.set(h,0,y),d.set(h,1,m),h++,d.set(h,0,y),d.set(h,1,x),h++,d.set(h,0,y),d.set(h,1,x),h++,d.set(h,0,C),d.set(h,1,x),h++,d.set(h,0,C),d.set(h,1,m),h++;Ea(r.get(g.COLOR),4,f,s,B);const{data:P,indices:R}=r.get(g.SIZE);I=R.length,h=s;for(let v=0;v<I;++v){const j=P[2*R[v]],z=P[2*R[v]+1];for(let T=0;T<B;++T)l.set(h,0,j),l.set(h,1,z),h++}if(Da(r.get(g.ROTATION),u,s,B),r.get(g.CENTEROFFSETANDDISTANCE)?Xt(r.get(g.CENTEROFFSETANDDISTANCE),p,s,B):Yt(p,s,I*B),r.get(g.FEATUREATTRIBUTE)?Xt(r.get(g.FEATUREATTRIBUTE),_,s,B):Yt(_,s,I*B),n!=null){const v=r.get(g.POSITION)?.indices;if(v){const j=v.length,z=i.getField(g.OLIDCOLOR,si);Fa(n,z,j,s,B)}}return{numVerticesPerItem:B,numItems:I}}intersect(e,t,r,n,i,s,o){const{options:{selectionMode:c,hud:d,excludeLabels:f},point:l,camera:u}=n;if(!c||!d||f&&t.isLabel||!l)return;const p=this.vertexBufferLayout.createView(e),_=p.getField(g.POSITION,rr),w=p.getField(g.NORMAL,rr),C=p.getField(g.ROTATION,oi),m=p.getField(g.SIZE,li),y=p.getField(g.FEATUREATTRIBUTE,nr),x=p.getField(g.CENTEROFFSETANDDISTANCE,nr),I=t.centerOffsetUnits==="screen",h=Re(t);if(_==null||w==null||C==null||m==null||x==null||u==null)return;const P=y==null?null:y.getVec(0,St),{scaleX:R,scaleY:v}=Ot(P,t,u.pixelRatio),j=_.count/B;for(let z=0;z<j;z++){const T=z*B;if(_.getVec(T,O),r!=null&&$t(O,O,r),pe(O,O,u.viewMatrix),x.getVec(T,Be),Oe($,Be[0],Be[1],Be[2]),!I&&(O[0]+=$[0],O[1]+=$[1],$[2]!==0)){const W=$[2];me($,O),Z(O,O,J($,$,W))}if(w.getVec(T,te),wt(te,ke,u,Pe),At(t,O,Pe,u,be),u.applyProjection(O,A),A[0]>-1){I&&($[0]||$[1])&&(A[0]+=$[0]*u.pixelRatio,$[1]!==0&&(A[1]+=Er($[1],be.factorAlignment)*u.pixelRatio),u.unapplyProjection(A,O)),A[0]+=t.screenOffset[0]*u.pixelRatio,A[1]+=t.screenOffset[1]*u.pixelRatio,A[0]=Math.floor(A[0]),A[1]=Math.floor(A[1]),m.getVec(T,F),Dr(F,be.factor,F);const W=Zr*u.pixelRatio;let Fe=0;t.textureIsSignedDistanceField&&(Fe=Math.min(t.outlineSize,.5*F[0])*u.pixelRatio/2),F[0]*=R,F[1]*=v;const Me=C.get(T),rt=t.rotation+Me;if(It(l,A[0],A[1],F,W,Fe,rt,t,h)){const ze=n.ray;if(pe(Ke,O,Pt(Yr,u.viewMatrix)),A[0]=l[0],A[1]=l[1],u.unprojectFromRenderScreen(A,O)){const X=V();q(X,ze.direction);const Y=1/Te(X);J(X,X,Y),o(Ar(ze.origin,O)*Y,X,z,Ke)}}}}}}function Ot(a,e,t){return a==null||e.vvSize==null?{scaleX:t,scaleY:t}:(Ma(dt,e,a),{scaleX:dt[0]*t,scaleY:dt[1]*t})}function At(a,e,t,r,n){if(!a.verticalOffset?.screenLength)return a.screenSizePerspective||a.screenSizePerspectiveAlignment?gr(a,n,Te(e),t.cosAngle):(n.factor.scale=1,n.factorAlignment.scale=1),e;const i=Te(e),s=a.screenSizePerspectiveAlignment??a.screenSizePerspective,o=za(r,i,a.verticalOffset,t.cosAngle,s);return gr(a,n,i,t.cosAngle),J(t.normal,t.normal,o),$t(e,e,t.normal)}function gr(a,e,t,r){a.screenSizePerspective!=null?Zt(r,t,a.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minScaleFactor=0),a.screenSizePerspectiveAlignment!=null?Zt(r,t,a.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minScaleFactor=e.factor.minScaleFactor)}class Ms{constructor(e,t){this._mainThreadDelegate=t,this._bufferWriters=new Map,this.globalViewingMode=e===fe.Global}createRenderCommandBuffer(e=[],t=[]){return{commands:e,transferList:t}}mergeRenderCommandBuffers(e){const t=this.createRenderCommandBuffer();for(const r of e)r!=null&&(t.commands.push(...r.commands),t.transferList.push(...r.transferList));return t}async createTexture(e){const{data:t,parameters:r}=e();return await this._mainThreadDelegate.createTexture(t,r)}async releaseTexture(e){const t=this._destroyTexture(e);return new Q(this,t,[])}_destroyTexture(e){return{commands:[{id:"destroy-texture",textureId:e}],transferList:[]}}async createMaterial(e){const{type:t,parameters:r}=e,n=Xe("material");let i,s;switch(t){case"default":i=new ja(e.parameters,{spherical:this.globalViewingMode}),s={type:t,materialId:n,parameters:e.parameters};break;case"hud":i=new Ss(r,this.globalViewingMode),s={type:t,materialId:n,parameters:e.parameters}}return this._bufferWriters.set(n,i.createBufferWriter()),await this._mainThreadDelegate.createMaterial(s),n}destroyMaterial(e){return{commands:[{id:"destroy-material",materialId:e}],transferList:[]}}updateMaterial(e){return{commands:[{...e,id:"update-material"}],transferList:[]}}async createDirectRenderer(e){return await this._mainThreadDelegate.createDirectRenderer(e),e}async destroyDirectRenderer(e){await this._mainThreadDelegate.destroyDirectRenderer(e)}addDirectRendererGeometry(e,t,r){const{materialId:n}=t;if(this._bufferWriters.get(n)==null)throw new Error(`no bufferwriter found for material ${n}`);const{renderGeometryBuffer:i,renderGeometryBufferItems:s}=this.createRenderGeometryBuffer(t,r);return this.addDirectRendererGeometryBuffer(n,e,i,s,r)}updateDirectRendererGeometry(e,t,r){const{materialId:n}=t;if(this._bufferWriters.get(n)==null)throw new Error(`no bufferwriter found for material ${n}`);const{renderGeometryBuffer:i,renderGeometryBufferItems:s}=this.createRenderGeometryBuffer(t,r);return this.updateDirectRendererGeometryBuffer(n,e,i,s,r)}addDirectRendererGeometryBuffer(e,t,r,n,i){const{objectIds:s,visibilities:o}=n;return{commands:[{id:"add-direct-renderer-geometry-buffer",rendererId:e,groupId:t,renderGeometryBuffer:r,renderGeometryBufferItems:n,localOrigin:i}],transferList:[r.data,s.buffer,o.buffer]}}updateDirectRendererGeometryBuffer(e,t,r,n,i){const{objectIds:s,visibilities:o}=n;return{commands:[{id:"update-direct-renderer-geometry-buffer",rendererId:e,groupId:t,renderGeometryBuffer:r,renderGeometryBufferItems:n,localOrigin:i}],transferList:[r.data,s.buffer,o.buffer]}}removeDirectRendererGeometryBuffer(e,t){return{commands:[{id:"remove-direct-renderer-geometry-buffer",rendererId:e,groupId:t}],transferList:[]}}async createLodRenderer(e){const t=Xe("lod-renderer"),r=new Set,n={levels:e.levels.map(i=>({components:i.components.map(s=>{const o=s.attributes.get(g.POSITION);if(!o||o.indices.length===0)throw new Error("positions attribute expected");const c=3,d=Na(o.indices.length/c),f=new La(d,c,o);if(this._bufferWriters.get(s.materialId)==null)throw new Error("writer not found");const{renderGeometryBuffer:l}=this.createRenderGeometryBuffer(s,null);return r.add(l.data),{materialId:s.materialId,renderGeometryBuffer:l,boundingInfo:{bbMax:f.bbMax,bbMin:f.bbMin}}}),minScreenSpaceRadius:i.minScreenSpaceRadius}))};return await this._mainThreadDelegate.createLodRenderer(t,n,Array.from(r)),t}destroyLodRenderer(e){return{commands:[{id:"destroy-lod-renderer",rendererId:e}],transferList:[]}}addLodInstances(e,t,r){return{commands:[{id:"add-lod-instances",rendererId:e,groupId:t,data:r}],transferList:[r.featureIds.buffer,r.globalTransforms.buffer,r.localTransforms.buffer,r.visibility.buffer]}}removeLodInstances(e,t){return{commands:[{id:"remove-lod-instances",rendererId:e,groupId:t}],transferList:[]}}updateLodInstancesData(e,t,r){return{commands:[{id:"update-lod-instance-data",rendererId:e,groupId:t,globalTransforms:r}],transferList:[r.buffer]}}updateVisibility(e,t,r){return{commands:[{id:"update-visibility",rendererId:e,groupId:t,visibility:r}],transferList:[r.buffer]}}async dispatchRenderCommands(e){e.commands.length!==0&&await this._mainThreadDelegate.executeRenderCommands(e)}createRenderGeometryBuffer(e,t){const{materialId:r,visibilities:n,objectIds:i}=e,s=this._bufferWriters.get(r);if(s==null)throw new Error("no registered bufferWriter for material found");let o=null;if(e.transformation&&t)Sr(ce,e.transformation),ce[12]-=t[0],ce[13]-=t[1],ce[14]-=t[2],o=ce;else{if(t)throw new Error("not implemented");e.transformation&&(o=e.transformation)}let c=null;o&&(Pt(Ue,ce),zn(Ue,Ue),c=Ue);const d=e.attributes,f=s.elementCount(d),l=s.vertexBufferLayout.stride/4;f>Math.floor(zs/l)&&console.warn("geometry with very large number of elements encountered");const u=s.vertexBufferLayout.createBuffer(f),p=0,_=s.write(o,c,d,e.objectAndLayerIdColor,u,p);if(_==null)throw new Error("Bufferwriter.write does not provide item information.");if(n.length!==_.numItems||i.length!==_.numItems)throw new Error("Unexpected mismatch between number of RenderGeometryBufferItems and provided objectIds/visibility flags.");return{renderGeometryBuffer:{data:u.buffer,elementCount:f},renderGeometryBufferItems:{objectIds:i,visibilities:n,ranges:{numVertices:_.numVerticesPerItem,numItems:_.numItems}}}}}const ce=Ce(),Ue=Ce(),zs=16777216/4;function js(a,e,t){return!!We(a,e,Ve,t.spatialReference)&&(t.x=Ve[0],t.y=Ve[1],t.z=Ve[2],!0)}const Ve=V();function Ls(a){const{value:e,operations:t}=a;return{operations:t,value:t.create(e)}}function Bs(a,e,t){return a.operations.setExtent(a.value,e,t.value),t}function Us(a,e){return a.operations.getExtent(a.value,e),e}function Vs(a){return{operations:a,value:a.create()}}function Kr(a,e,t=Vs(a)){return t.operations=a,a.copy(e,t.value),t}function Ns(a){return Kr(Wa,Qa(0,0,0,Or(a).radius))}const yr=2**50;function Gs(){return Kr(Ua,Ba([0,0,0],[yr,0,0],[0,yr,0]))}function ks(a,e,t){return a.operations.axisAt(a.value,e,Se.Z,t)}function Hs(a,e,t,r){return a.operations.axisAt(a.value,e,t,r)}function qs(a,e,t){return a.operations.intersectRay(a.value,e,t)}function Qs(a,e,t){return a.operations.intersectRayClosestSilhouette(a.value,e,t)}function Ws(a,e){return a.operations.altitudeAt(a.value,e)}function en(a,e,t,r){return a.operations.setAltitudeAt(a.value,e,t,r)}function Xs(a,e,t,r){return e!==r&&Sr(r,e),Oe(de,r[12],r[13],r[14]),en(a,de,t,de),r[12]=de[0],r[13]=de[1],r[14]=de[2],r}function ut(a,e,t){return a.operations.elevate(a.value,e,t.value)}const de=V();function _r(a){return a.type==="point"}class et{constructor(e,t,r,n){this.viewingMode=e,this.spatialReference=t,this.unitInMeters=r,this._coordinateSystem=n,this._tmpCoordinateSystem=Ls(n),this.referenceEllipsoid=Or(t),this.sphericalPCPF=ui(t)}set extent(e){e&&Bs(this._coordinateSystem,e,this._coordinateSystem)}get extent(){return Us(this._coordinateSystem,Ir())}getAltitude(e){return Ws(this._coordinateSystem,e)}setAltitude(e,t,r=e){return en(this._coordinateSystem,r,t,e)}setAltitudeOfTransformation(e,t){Xs(this._coordinateSystem,t,e,t)}worldUpAtPosition(e,t){return ks(this._coordinateSystem,e,t)}worldBasisAtPosition(e,t,r){return Hs(this._coordinateSystem,e,t,r)}basisMatrixAtPosition(e,t){const r=this.worldBasisAtPosition(e,Se.X,ee.get()),n=this.worldBasisAtPosition(e,Se.Y,ee.get()),i=this.worldBasisAtPosition(e,Se.Z,ee.get());return jn(t,r[0],r[1],r[2],0,n[0],n[1],n[2],0,i[0],i[1],i[2],0,0,0,0,1),t}headingAtPosition(e,t){const r=this.worldUpAtPosition(e,ee.get()),n=this.worldBasisAtPosition(e,Se.Y,ee.get()),i=Xa(t,n,r);return Ln(i)}intersectManifoldClosestSilhouette(e,t,r){return ut(this._coordinateSystem,t,this._tmpCoordinateSystem),Qs(this._tmpCoordinateSystem,e,r),r}intersectManifold(e,t,r){ut(this._coordinateSystem,t,this._tmpCoordinateSystem);const n=ee.get();return qs(this._tmpCoordinateSystem,e,n)?q(r,n):null}intersectInfiniteManifold(e,t,r){if(this.viewingMode===fe.Global)return this.intersectManifold(e,t,r);ut(this._coordinateSystem,t,this._tmpCoordinateSystem);const n=this._tmpCoordinateSystem.value,i=ee.get();return qa(n.plane,e,i)?q(r,i):null}toRenderCoords(e,t,r){return _r(e)?fi(e,t,this.spatialReference):We(e,t,r,this.spatialReference)}fromRenderCoords(e,t,r=null){return _r(t)?(r!=null&&(t.spatialReference=r),js(e,this.spatialReference,t)?t:null):We(e,this.spatialReference,t,r)?t:null}static create(e,t){switch(e){case fe.Local:return new et(fe.Local,t,Bn(t),Gs());case fe.Global:return new et(fe.Global,t,1,Ns(t))}}static renderUnitScaleFactor(e,t){return Ut(e)/Ut(t)}}let He=class extends wr.EventedAccessor{constructor(){super(...arguments),this.remoteClient=null,this._featureStore=new ns,this._tileLocks=new es,this._tileManager=null,this._renderer=null,this._fetcher=null,this._queryEngine=null,this._defaultQueryJSON=null,this._mainThreadDelegate=null,this._viewSpatialReference=null,this._renderCommandContext=null,this._context=null}get updating(){return this._tileManager.updating}destroy(){this._featureStore.clear(),this._tileManager?.destroy()}async setup({viewSpatialReference:a,renderSpatialReference:e,viewingMode:t,layerInfo:r,layerViewInfo:n}){const i=Vt.fromJSON(a);this._viewSpatialReference=i;const s=Vt.fromJSON(e);this._fetcher=new fs(this._viewSpatialReference,Nt.fromJSON(r.baseQuery),r.url,r.objectIdField,r.capabilities),this._queryEngine=new Hn({hasZ:!0,hasM:!1,geometryType:"esriGeometryPoint",featureIdInfo:{type:"object-id",fieldName:r.objectIdField},fieldsIndex:r.fieldIndex,availableFields:[r.objectIdField],spatialReference:a,featureStore:this._featureStore,timeInfo:r.timeInfo}),this._mainThreadDelegate={createTexture:async(l,u)=>{const p={data:l,parameters:u};return await this.remoteClient.invoke("createTexture",p,{transferList:[l.buffer]})},releaseTexture:async l=>{const u={uid:l};await this.remoteClient.invoke("releaseTexture",u)},createMaterial:async l=>{const u={materialJSON:l};await this.remoteClient.invoke("createMaterial",u)},destroyMaterial:async l=>{const u={materialId:l};await this.remoteClient.invoke("destroyMaterial",u)},createDirectRenderer:async l=>{const u={materialId:l};await this.remoteClient.invoke("createDirectRenderer",u)},destroyDirectRenderer:async l=>{const u={materialId:l};await this.remoteClient.invoke("destroyDirectRenderer",u)},createLodRenderer:async(l,u,p)=>{const _={rendererId:l,lodRenderGeometry:u};await this.remoteClient.invoke("createLoDRenderer",_,{transferList:p})},destroyLodRenderer:async l=>{const u={rendererId:l};await this.remoteClient.invoke("destroyLoDRenderer",u)},executeRenderCommands:async l=>{const u={commands:l.commands};await this.remoteClient.invoke("dispatchRenderCommands",u,{transferList:l.transferList})},applyElevationAlignmentTo:async l=>{const u={mapPoints:l};return await this.remoteClient.invoke("applyElevationAlignment",u,{transferList:[l.buffer]})}};const o=et.create(t,s),c=new Ms(t,this._mainThreadDelegate);this._renderCommandContext=c;const d=new Wi(i,s,this._mainThreadDelegate,o,c,r,n);this._context=d,this._renderer=d.symbolRendererFactory.createSymbolRendererFromJSON(r.renderer),this._defaultQueryJSON=new Nt({outSpatialReference:i}).toJSON();let f=null;if(r.fullExtent!=null){const l=Un.fromJSON(r.fullExtent);await Vn(l.spatialReference,i),f=Nn(l,i)}return this._tileManager=new U({loadTile:(l,u)=>this._fetcher.fetch(l,u),createAddCommand:(l,u)=>this._createAddFeatureDataCommand(l,u),createRemoveCommand:l=>this._createRemoveFeatureDataCommand(l),createUpdateCommand:(l,u)=>this._createUpdateFeatureDataVisibilityCommand(l,u),tileLocks:this._tileLocks,extent:f}),this.addHandles(Gn(()=>this.updating,l=>{this.emit("notify-updating",{updating:l})}),kn),this._renderer!=null&&await this._renderer.load(),ue}async executeQuery(a,e){return{result:await this._queryEngine.executeQuery(this._ensureQuery(a),e)}}async executeQueryForIds(a,e){const t=await this._queryEngine.executeQueryForIdSet(this._ensureQuery(a),e);return{result:Array.from(t)}}async executeQueryForCount(a,e){return{result:await this._queryEngine.executeQueryForCount(this._ensureQuery(a),e)}}async executeQueryForExtent(a,e){return{result:await this._queryEngine.executeQueryForExtent(this._ensureQuery(a),e)}}async executeQueryForLatestObservations(a,e){return{result:await this._queryEngine.executeQueryForLatestObservations(this._ensureQuery(a),e)}}onTileTreeChange(a){return this._tileManager.onTileTreeChange(a),Promise.resolve(ue)}async onElevationChange(a){return ue}async onLayerViewOpacityChange(a){const{_context:e,_renderer:t}=this;return e.layerViewInfo.fullOpacity=a,t==null||await(await t.createUpdateLayerViewOpacityCommand(a)).execute(),ue}async onRendererChange(a){const{_context:e}=this,t=e.symbolRendererFactory.createSymbolRendererFromJSON(a);await t.load();const r=this._renderer;this._renderer=t;const n=[...this._tileManager.loadedTiles()],i=n.map(o=>o.tileId);{const o={stack:[],error:void 0,hasError:!1};try{pt(o,await this._tileLocks.lock(i),!1);const c=n.flatMap(l=>[r.createRemoveCommand(l.id),t.createAddCommand(l)]),d=await Promise.all(c);await e.joinPipelineCommands(d).execute()}catch(c){o.error=c,o.hasError=!0}finally{gt(o)}}return await(await r.createDestroyCommand()).execute(),ue}async _createAddFeatureDataCommand(a,e){const t=this._featureStore,r=this._renderer;let n;return n=r!=null?await r.createAddCommand(a):Q.create(this._renderCommandContext),$e(e),n.appendPipelineStateCommand(()=>{t.addTile(a)}),n}async _createRemoveFeatureDataCommand(a){const e=this._featureStore,t=this._renderer;let r;return r=t!=null?await t.createRemoveCommand(a):Q.create(this._renderCommandContext),r.appendPipelineStateCommand(()=>{e.removeTile(a)}),r}async _createUpdateFeatureDataVisibilityCommand(a,e){const t=this._renderer;let r;return r=t!=null?await t.createUpdateVisibilityCommand(a):Q.create(this._renderCommandContext),$e(e),r}_ensureQuery(a){return a??this._defaultQueryJSON}};S([N()],He.prototype,"updating",null),He=S([xr("esri.views.3d.layers.graphics.pipeline.Feature3DPipelineWorker")],He);const Ys=He,ue={result:void 0},el=Object.freeze(Object.defineProperty({__proto__:null,default:Ys},Symbol.toStringTag,{value:"Module"}));export{vs as B,el as F,Re as M,Je as V};
