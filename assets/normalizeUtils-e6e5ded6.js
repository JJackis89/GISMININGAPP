import{g as H,dT as J,cC as O,H as U,az as W,bA as _,f$ as B,g0 as E,k as G,c1 as k,N as v,e9 as L,am as K,P as F,e7 as Q,p as V}from"./index-f00bd99f.js";import{r as q,o as z,i as b,s as X}from"./normalizeUtilsCommon-3a54feae.js";async function Y(e,s,l,n){const t=H(e),i=s[0].spatialReference,r={...n,responseType:"json",query:{...t.query,f:"json",sr:J(i),target:JSON.stringify({geometryType:O(s[0]),geometries:s}),cutter:JSON.stringify(l)}},o=await U(t.path+"/cut",r),{cutIndexes:a,geometries:u=[]}=o.data;return{cutIndexes:a,geometries:u.map(p=>{const x=W(p);return x.spatialReference=i,x})}}async function Z(e,s,l){const n=typeof e=="string"?_(e):e,t=s[0].spatialReference,i=O(s[0]),r={...l,query:{...n.query,f:"json",sr:J(t),geometries:JSON.stringify(B(s))}},{data:o}=await U(n.path+"/simplify",r);return E(o.geometries,i,t)}const D=()=>K.getLogger("esri.geometry.support.normalizeUtils");function ee(e){return e.type==="polygon"}function te(e){return e[0].type==="polygon"}function se(e){return e[0].type==="polyline"}function ne(e,s){if(!(e instanceof v||e instanceof F)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw D().error(t),new V("internal:geometry",t)}const l=z(e),n=[];for(const t of l){const i=[];n.push(i),i.push([t[0][0],t[0][1]]);for(let r=0;r<t.length-1;r++){const o=t[r][0],a=t[r][1],u=t[r+1][0],p=t[r+1][1],x=Math.sqrt((u-o)*(u-o)+(p-a)*(p-a)),h=(p-a)/x,d=(u-o)/x,g=x/s;if(g>1){for(let R=1;R<=g-1;R++){const N=R*s,c=d*N+o,f=h*N+a;i.push([c,f])}const M=(x+Math.floor(g-1)*s)/2,P=d*M+o,I=h*M+a;i.push([P,I])}i.push([u,p])}}return ee(e)?new F({rings:n,spatialReference:e.spatialReference}):new v({paths:n,spatialReference:e.spatialReference})}function T(e,s,l){if(s){const n=ne(e,1e6);e=Q(n,!0)}return l&&(e=X(e,l)),e}function C(e,s,l){if(Array.isArray(e)){const n=e[0];if(n>s){const t=b(n,s);e[0]=n+t*(-2*s)}else if(n<l){const t=b(n,l);e[0]=n+t*(-2*l)}}else{const n=e.x;if(n>s){const t=b(n,s);e=e.clone().offset(t*(-2*s),0)}else if(n<l){const t=b(n,l);e=e.clone().offset(t*(-2*l),0)}}return e}function oe(e,s){let l=-1;for(let n=0;n<s.cutIndexes.length;n++){const t=s.cutIndexes[n],i=s.geometries[n],r=z(i);for(let o=0;o<r.length;o++){const a=r[o];a.some(u=>{if(u[0]<180)return!0;{let p=0;for(let h=0;h<a.length;h++){const d=a[h][0];p=d>p?d:p}p=Number(p.toFixed(9));const x=-360*b(p,180);for(let h=0;h<a.length;h++){const d=i.getPoint(o,h);i.setPoint(o,h,d.clone().offset(x,0))}return!0}})}if(t===l){if(te(e))for(const o of z(i))e[t]=e[t].addRing(o);else if(se(e))for(const o of z(i))e[t]=e[t].addPath(o)}else l=t,e[t]=i}return e}async function re(e,s,l){if(!Array.isArray(e))return re([e],s);s&&typeof s!="string"&&D().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:s?.url??G.geometryServiceUrl;let t,i,r,o,a,u,p,x,h=0;const d=[],g=[];for(const c of e)if(c!=null)if(t||(t=c.spatialReference,i=k(t),r=t.isWebMercator,u=r?102100:4326,o=q[u].maxX,a=q[u].minX,p=q[u].plus180Line,x=q[u].minus180Line),i)if(c.type==="mesh")g.push(c);else if(c.type==="point")g.push(C(c.clone(),o,a));else if(c.type==="multipoint"){const f=c.clone();f.points=f.points.map(m=>C(m,o,a)),g.push(f)}else if(c.type==="extent"){const f=c.clone()._normalize(!1,!1,i);g.push(f.rings?new F(f):f)}else if(c.extent){const f=c.extent,m=b(f.xmin,a)*(2*o);let $=m===0?c.clone():X(c.clone(),m);f.offset(m,0);let{xmin:w,xmax:y}=f;w=Number(w.toFixed(9)),y=Number(y.toFixed(9)),f.intersects(p)&&y!==o?(h=y>h?y:h,$=T($,r),d.push($),g.push("cut")):f.intersects(x)&&w!==a?(h=y*(2*o)>h?y*(2*o):h,$=T($,r,360),d.push($),g.push("cut")):g.push($)}else g.push(c.clone());else g.push(c);else g.push(c);let M=b(h,o),P=-90;const I=M,R=new v;for(;M>0;){const c=360*M-180;R.addPath([[c,P],[c,-1*P]]),P*=-1,M--}if(d.length>0&&I>0){const c=oe(d,await Y(n,d,R,l)),f=[],m=[];for(let y=0;y<g.length;y++){const j=g[y];if(j!=="cut")m.push(j);else{const S=c.shift(),A=e[y];A!=null&&A.type==="polygon"&&A.rings&&A.rings.length>1&&S.rings.length>=A.rings.length?(f.push(S),m.push("simplify")):m.push(r?L(S):S)}}if(!f.length)return m;const $=await Z(n,f,l),w=[];for(let y=0;y<m.length;y++){const j=m[y];j!=="simplify"?w.push(j):w.push(r?L($.shift()):$.shift())}return w}const N=[];for(let c=0;c<g.length;c++){const f=g[c];if(f!=="cut")N.push(f);else{const m=d.shift();N.push(r===!0?L(m):m)}}return N}function le(e,s,l){const n=k(l);if(n==null)return e;const[t,i]=n.valid,r=2*i;let o=0,a=0;s>i?o=Math.ceil(Math.abs(s-i)/r):s<t&&(o=-Math.ceil(Math.abs(s-t)/r)),e>i?a=Math.ceil(Math.abs(e-i)/r):e<t&&(a=-Math.ceil(Math.abs(e-t)/r));let u=e+(o-a)*r;const p=u-s;return p>i?u-=r:p<t&&(u+=r),u}export{le as P,re as R};
